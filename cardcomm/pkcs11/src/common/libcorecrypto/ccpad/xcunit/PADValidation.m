/*
 * Copyright (c) 2014,2015 Apple Inc. All rights reserved.
 * 
 * corecrypto Internal Use License Agreement
 * 
 * IMPORTANT:  This Apple corecrypto software is supplied to you by Apple Inc. ("Apple")
 * in consideration of your agreement to the following terms, and your download or use
 * of this Apple software constitutes acceptance of these terms.  If you do not agree
 * with these terms, please do not download or use this Apple software.
 * 
 * 1.	As used in this Agreement, the term "Apple Software" collectively means and
 * includes all of the Apple corecrypto materials provided by Apple here, including
 * but not limited to the Apple corecrypto software, frameworks, libraries, documentation
 * and other Apple-created materials. In consideration of your agreement to abide by the
 * following terms, conditioned upon your compliance with these terms and subject to
 * these terms, Apple grants you, for a period of ninety (90) days from the date you
 * download the Apple Software, a limited, non-exclusive, non-sublicensable license
 * under Apple’s copyrights in the Apple Software to make a reasonable number of copies
 * of, compile, and run the Apple Software internally within your organization only on
 * devices and computers you own or control, for the sole purpose of verifying the
 * security characteristics and correct functioning of the Apple Software; provided
 * that you must retain this notice and the following text and disclaimers in all
 * copies of the Apple Software that you make. You may not, directly or indirectly,
 * redistribute the Apple Software or any portions thereof. The Apple Software is only
 * licensed and intended for use as expressly stated above and may not be used for other
 * purposes or in other contexts without Apple's prior written permission.  Except as
 * expressly stated in this notice, no other rights or licenses, express or implied, are
 * granted by Apple herein.
 * 
 * 2.	The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
 * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES
 * OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING
 * THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS,
 * SYSTEMS, OR SERVICES. APPLE DOES NOT WARRANT THAT THE APPLE SOFTWARE WILL MEET YOUR
 * REQUIREMENTS, THAT THE OPERATION OF THE APPLE SOFTWARE WILL BE UNINTERRUPTED OR
 * ERROR-FREE, THAT DEFECTS IN THE APPLE SOFTWARE WILL BE CORRECTED, OR THAT THE APPLE
 * SOFTWARE WILL BE COMPATIBLE WITH FUTURE APPLE PRODUCTS, SOFTWARE OR SERVICES. NO ORAL
 * OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE OR AN APPLE AUTHORIZED REPRESENTATIVE
 * WILL CREATE A WARRANTY. 
 * 
 * 3.	IN NO EVENT SHALL APPLE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING
 * IN ANY WAY OUT OF THE USE, REPRODUCTION, COMPILATION OR OPERATION OF THE APPLE
 * SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING
 * NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * 4.	This Agreement is effective until terminated. Your rights under this Agreement will
 * terminate automatically without notice from Apple if you fail to comply with any term(s)
 * of this Agreement.  Upon termination, you agree to cease all use of the Apple Software
 * and destroy all copies, full or partial, of the Apple Software. This Agreement will be
 * governed and construed in accordance with the laws of the State of California, without
 * regard to its choice of law rules.
 * 
 * You may report security issues about Apple products to product-security@apple.com,
 * as described here:  https://www.apple.com/support/security/.  Non-security bugs and
 * enhancement requests can be made via https://bugreport.apple.com as described
 * here: https://developer.apple.com/bug-reporting/
 *
 * EA1350 
 * 10/5/15
 */


#import "PADValidation.h"
#include <string.h>
#include <stdbool.h>

#include <corecrypto/ccaes.h>
#include <corecrypto/ccpad.h>
#include <corecrypto/ccmode_factory.h>

static const uint8_t kek[] = {
    0x63, 0x68, 0x69, 0x63, 0x6b, 0x65, 0x6e, 0x20,
    0x74, 0x65, 0x72, 0x69, 0x79, 0x61, 0x6b, 0x69
};

@implementation PADValidation


- (void) testCTSAES
{
    /*

     AES 128-bit key:
     0000:  63 68 69 63 6b 65 6e 20 74 65 72 69 79 61 6b 69

     IV:
     0000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     Input:
     0000:  49 20 77 6f 75 6c 64 20 6c 69 6b 65 20 74 68 65
     0010:  20
     Output:
     0000:  c6 35 35 68 f2 bf 8c b4 d8 a5 80 36 2d a7 ff 7f
     0010:  97
     Next IV:
     0000:  c6 35 35 68 f2 bf 8c b4 d8 a5 80 36 2d a7 ff 7f

     IV:
     0000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     Input:
     0000:  49 20 77 6f 75 6c 64 20 6c 69 6b 65 20 74 68 65
     0010:  20 47 65 6e 65 72 61 6c 20 47 61 75 27 73 20
     Output:
     0000:  fc 00 78 3e 0e fd b2 c1 d4 45 d4 c8 ef f7 ed 22
     0010:  97 68 72 68 d6 ec cc c0 c0 7b 25 e2 5e cf e5
     Next IV:
     0000:  fc 00 78 3e 0e fd b2 c1 d4 45 d4 c8 ef f7 ed 22

     IV:
     0000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     Input:
     0000:  49 20 77 6f 75 6c 64 20 6c 69 6b 65 20 74 68 65
     0010:  20 47 65 6e 65 72 61 6c 20 47 61 75 27 73 20 43
     Output:
     0000:  39 31 25 23 a7 86 62 d5 be 7f cb cc 98 eb f5 a8
     0010:  97 68 72 68 d6 ec cc c0 c0 7b 25 e2 5e cf e5 84
     Next IV:
     0000:  39 31 25 23 a7 86 62 d5 be 7f cb cc 98 eb f5 a8

     IV:
     0000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     Input:
     0000:  49 20 77 6f 75 6c 64 20 6c 69 6b 65 20 74 68 65
     0010:  20 47 65 6e 65 72 61 6c 20 47 61 75 27 73 20 43
     0020:  68 69 63 6b 65 6e 2c 20 70 6c 65 61 73 65 2c
     Output:
     0000:  97 68 72 68 d6 ec cc c0 c0 7b 25 e2 5e cf e5 84
     0010:  b3 ff fd 94 0c 16 a1 8c 1b 55 49 d2 f8 38 02 9e
     0020:  39 31 25 23 a7 86 62 d5 be 7f cb cc 98 eb f5
     Next IV:
     0000:  b3 ff fd 94 0c 16 a1 8c 1b 55 49 d2 f8 38 02 9e

     IV:
     0000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     Input:
     0000:  49 20 77 6f 75 6c 64 20 6c 69 6b 65 20 74 68 65
     0010:  20 47 65 6e 65 72 61 6c 20 47 61 75 27 73 20 43
     0020:  68 69 63 6b 65 6e 2c 20 70 6c 65 61 73 65 2c 20
     Output:
     0000:  97 68 72 68 d6 ec cc c0 c0 7b 25 e2 5e cf e5 84
     0010:  9d ad 8b bb 96 c4 cd c0 3b c1 03 e1 a1 94 bb d8
     0020:  39 31 25 23 a7 86 62 d5 be 7f cb cc 98 eb f5 a8
     Next IV:
     0000:  9d ad 8b bb 96 c4 cd c0 3b c1 03 e1 a1 94 bb d8



     */

    const uint8_t plain[] = {
        0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20,
        0x6c, 0x69, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,
        0x20, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c,
        0x20, 0x47, 0x61, 0x75, 0x27, 0x73, 0x20, 0x43,
        0x68, 0x69, 0x63, 0x6b, 0x65, 0x6e, 0x2c, 0x20,
        0x70, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x2c, 0 };

    uint8_t plain_tmp[64], cipher_tmp[64];
    const struct ccmode_cbc *cbc_encrypt = ccaes_cbc_encrypt_mode();
    const struct ccmode_cbc *cbc_decrypt = ccaes_cbc_decrypt_mode();


// Gladman has bug when used in CTS mode ?
//    const struct ccmode_cbc *cbc_encrypt = &ccaes_gladman_cbc_encrypt_mode;
//    const struct ccmode_cbc *cbc_decrypt = &ccaes_gladman_cbc_decrypt_mode;
    cccbc_ctx_decl(cbc_encrypt->size, cbc_ekey);
    cccbc_ctx_decl(cbc_decrypt->size, cbc_dkey);
    cccbc_iv_decl(cbc_encrypt->size, e_iv);
    cccbc_iv_decl(cbc_decrypt->size, d_iv);

    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    cccbc_init(cbc_encrypt, cbc_ekey, sizeof(kek), kek);
    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 17, plain, cipher_tmp);
    uint8_t t1[] = { 0xc6, 0x35, 0x35, 0x68, 0xf2, 0xbf, 0x8c, 0xb4, 0xd8, 0xa5, 0x80, 0x36, 0x2d, 0xa7, 0xff, 0x7f, 0x97 };
    XCAssertMemEquals(sizeof(t1), t1, cipher_tmp, @"cts cbc encrypt 17 bytes");

    memset(plain_tmp, 0, sizeof(plain_tmp));
    cccbc_init(cbc_decrypt, cbc_dkey, sizeof(kek), kek);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 17, cipher_tmp, plain_tmp);
    XCAssertMemEquals(17, plain, plain_tmp, @"cts cbc decrypt 17 bytes");

    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 31, plain, cipher_tmp);
    uint8_t t2[] = { 0xfc, 0x00, 0x78, 0x3e, 0x0e, 0xfd, 0xb2, 0xc1, 0xd4, 0x45, 0xd4, 0xc8, 0xef, 0xf7, 0xed, 0x22, 0x97, 0x68, 0x72, 0x68, 0xd6, 0xec, 0xcc, 0xc0, 0xc0, 0x7b, 0x25, 0xe2, 0x5e, 0xcf, 0xe5 };
    XCAssertMemEquals(sizeof(t2), t2, cipher_tmp, @"cts cbc encrypt 31 bytes");
    memset(plain_tmp, 0, sizeof(plain_tmp));
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 31, cipher_tmp, plain_tmp);
    XCAssertMemEquals(31, plain, plain_tmp, @"cts cbc decrypt 31 bytes");

    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 32, plain, cipher_tmp);
    uint8_t t3[] = { 0x39, 0x31, 0x25, 0x23, 0xa7, 0x86, 0x62, 0xd5, 0xbe, 0x7f, 0xcb, 0xcc, 0x98, 0xeb, 0xf5, 0xa8, 0x97, 0x68, 0x72, 0x68, 0xd6, 0xec, 0xcc, 0xc0, 0xc0, 0x7b, 0x25, 0xe2, 0x5e, 0xcf, 0xe5, 0x84 };
    XCAssertMemEquals(sizeof(t3), t3, cipher_tmp, @"cts cbc encrypt 32 bytes");
    memset(plain_tmp, 0, sizeof(plain_tmp));
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 32, cipher_tmp, plain_tmp);
    XCAssertMemEquals(32, plain, plain_tmp, @"cts cbc decrypt 32 bytes");

    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 47, plain, cipher_tmp);
    uint8_t t4[] = { 0x97, 0x68, 0x72, 0x68, 0xd6, 0xec, 0xcc, 0xc0, 0xc0, 0x7b, 0x25, 0xe2, 0x5e, 0xcf, 0xe5, 0x84, 0xb3, 0xff, 0xfd, 0x94, 0x0c, 0x16, 0xa1, 0x8c, 0x1b, 0x55, 0x49, 0xd2, 0xf8, 0x38, 0x02, 0x9e, 0x39, 0x31, 0x25, 0x23, 0xa7, 0x86, 0x62, 0xd5, 0xbe, 0x7f, 0xcb, 0xcc, 0x98, 0xeb, 0xf5 };
    XCAssertMemEquals(sizeof(t4), t4, cipher_tmp, @"cts cbc encrypt 47 bytes");
    memset(plain_tmp, 0, sizeof(plain_tmp));
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 47, cipher_tmp, plain_tmp);
    XCAssertMemEquals(47, plain, plain_tmp, @"cts cbc decrypt 47 bytes");

    // in place test enc
    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    memcpy(cipher_tmp, plain, 47);
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 47, cipher_tmp, cipher_tmp);
    // in place test dec
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 47, cipher_tmp, cipher_tmp);
    XCAssertMemEquals(47, plain, cipher_tmp,
                      @"cts cbc in place encrypt decrypt 47 bytes");

    // 3*blocksize test
    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    memcpy(cipher_tmp, plain, 48);
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 48, cipher_tmp, cipher_tmp);
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 48, cipher_tmp, cipher_tmp);
    //XCAssertMemEquals(48, plain, cipher_tmp,
    //                  @"cts cbc in place encrypt decrypt 48 bytes");

    // 40 byte test
    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    memcpy(cipher_tmp, plain, 40);
    ccpad_cts_encrypt(cbc_encrypt, cbc_ekey, e_iv, 40, cipher_tmp, cipher_tmp);
    ccpad_cts_decrypt(cbc_decrypt, cbc_dkey, d_iv, 40, cipher_tmp, cipher_tmp);
    XCAssertMemEquals(40, plain, cipher_tmp,
                      @"cts cbc in place encrypt decrypt 40 bytes");
}

- (void) testPKCS7AES
{
    const unsigned char
    key[] = {
        /* badfd2102e1e180a634204249c5a6933 */
        0xba,0xdf,0xd2,0x10,0x2e,0x1e,0x18,0x0a,0x63,0x42,0x04,0x24,0x9c,0x5a,0x69,0x33 },
    iv[] = {
        /* 84c06c16c151007ca9ed9bb926e66eec */
        0x84,0xc0,0x6c,0x16,0xc1,0x51,0x00,0x7c,0xa9,0xed,0x9b,0xb9,0x26,0xe6,0x6e,0xec },
	plainText[] = {
        0xfb, 0x58, 0x51, 0x0b, 0xeb, 0x65, 0x06, 0x2c,
        0x52, 0x5a, 0x3d, 0xe4, 0x2d, 0x93, 0x4d, 0x4b,
        0x4e, 0xc4, 0x33, 0xd6, 0x00, 0xa1, 0x46, 0x71,
        0x42, 0x75, 0x18, 0x86, 0xa1, 0x0e, 0x7b, 0xf9,
        0x6f, 0x23, 0x6c, 0x19, 0x6d, 0x12, 0xdc, 0xf0,
        0x69, 0x8e, 0x09, 0xef, 0xc7, 0x9a, 0x4b, 0xea,
        0x07, 0x2b, 0xc0, 0x83, 0x0d, 0xa8, 0x88, 0x66,
        0x74, 0xcf, 0x61, 0x74, 0x20, 0x6c, 0xca, 0x2d,
        0x4e, 0x9e, 0x54, 0x3f, 0x00, 0x16, 0xec, 0x4d,
        0xcc, 0x60, 0x2f, 0xfd, 0x0a, 0x41, 0x7c, 0x72,
        0x28, 0x79, 0xe2, 0x59, 0x49, 0x7f, 0x89, 0xae,
        0xe5, 0xad, 0x99, 0xa4, 0xf6, 0x58, 0x87, 0x05,
        0x82, 0x42, 0x25, 0x0f, 0xbe, 0x44, 0xf6, 0x1e,
        0xab, 0x5e, 0x66, 0x8a, 0xdb, 0xb7, 0x80, 0xa4,
        0xcb, 0xa9, 0x73, 0x93, 0xf6, 0xff, 0x15, 0x2c,
        0x13, 0xc3, 0x9b, 0x57, 0xed, 0x72, 0x7b, 0xb9,
        0x4c, 0xf1, 0x9d, 0x1b, 0x4a, 0x55, 0xf4, 0x5c,
        0xce, 0xb2, 0x2b, 0x6c, 0x4f, 0x26, 0xf7, 0x36,
        0xd2, 0x0a, 0x48, 0xcb, 0x62, 0x30, 0x57, 0x85,
        0x91, 0xc8, 0xd3, 0x3d, 0x72, 0xb7, 0x78, 0xd3,
        0x0b, 0x30, 0x48, 0x18, 0xb2, 0x0d, 0x91, 0x8e,
        0xf6, 0x54, 0xca, 0xbe, 0xae, 0x10, 0x38, 0xf2,
        0xa0, 0xdb, 0x51, 0x70, 0xd2, 0xb4, 0xdf, 0x38,
        0xc6, 0xef, 0xc8, 0x87, 0xbc, 0x1f, 0x83, 0x7f,
        0xba, 0x34, 0xe9, 0x7d, 0xaf, 0x89, 0x20, 0x41,
        0x4b, 0x74, 0x8a, 0x90, 0x9a, 0xd5, 0xef, 0x56,
        0xfb, 0x47, 0xfa, 0x53, 0xc6, 0x80, 0xaa, 0xe8,
        0x08, 0xf3, 0xe6, 0x06, 0x56, 0x89, 0x33, 0x97,
        0x28, 0x25, 0x1e, 0x18, 0xcd, 0x26, 0x4f, 0x53,
        0x85, 0xc9, 0x69, 0xf8, 0x71, 0x04, 0x09, 0x95,
        0x63, 0xa4, 0x11, 0xcf, 0xe6, 0x81, 0xd1, 0x91,
        0x34, 0xe9, 0x47, 0x9e, 0x05, 0x9d, 0x09, 0xb6,
        0x9f, 0x50, 0x10, 0x91, 0x22, 0x91, 0xd0, 0x23,
        0x2f, 0x73, 0x3a, 0x26, 0x88, 0xb3, 0x04, 0x2e,
        0xc4, 0xe8, 0x2c, 0xe5, 0x16, 0x3c, 0x38, 0x4e,
        0xe5, 0x4a, 0x9f, 0x10, 0xe4, 0x8a, 0x8a, 0xb4,
        0x6f, 0xd7, 0x14, 0x73, 0x51, 0xdd, 0x85, 0x14,
        0xbd, 0xa5, 0xd8, 0xc4, 0xce, 0x8b, 0xab, 0xcc,
        0x3e, 0xf8, 0x2d, 0xbf, 0x44, 0x79, 0x9f, 0xc5,
        0x9e, 0x37, 0xd8, 0xf3, 0xc9, 0x95, 0x06, 0xd2,
        0x16, 0x8c, 0x84, 0xd8, 0x38, 0x1f, 0x4f, 0x9a,
        0x84, 0xcb, 0xce, 0x7b, 0xd0, 0xbb, 0x4b, 0xbb,
        0xcd, 0xef, 0x0c, 0x62, 0x63, 0x56, 0xd3, 0xca,
        0x12, 0x6c, 0x87, 0x76, 0xe3, 0xa2, 0x91, 0x88,
        0x1a, 0xf5, 0x18, 0xe2, 0x3d, 0xbd, 0x06, 0x70,
        0x16, 0xc5, 0x89, 0x8b, 0xed, 0x5f, 0x64, 0xd6,
        0xe8, 0xf8, 0xac, 0xef, 0xba, 0x83, 0xf9, 0x2b,
        0x0c, 0x31, 0x8e, 0xc7, 0xb9, 0x05, 0x16, 0x5f,
        0xb6, 0xb8, 0x1b, 0xc6, 0x05, 0x28, 0xc0, 0xa0,
        0xe3, 0xdb, 0x38, 0xab, 0x1e, 0xe6, 0xf3, 0x7e,
        0x56, 0xdb, 0xf2, 0x70, 0xc0, 0x75, 0x16, 0x74,
        0xe0, 0xdd, 0xb1, 0xa6, 0x07, 0x6d, 0x8f, 0x78,
        0x08, 0x4c, 0xe3, 0x1f, 0x0d, 0x36, 0x73, 0xe6,
        0x38, 0xe0, 0x11, 0x05, 0x75, 0xb1, 0x6d, 0x9d,
        0x9f, 0x15, 0x1c, 0x1b, 0x9a, 0xca, 0x8d, 0x15,
        0xd7, 0xa8, 0x11, 0x1c, 0x0d, 0xe5, 0xac, 0xf5,
        0xae, 0x3b, 0x30, 0x7e, 0x80, 0x64, 0xc9, 0x03,
        0x29, 0xe4, 0x21, 0xe3, 0x43, 0x4a, 0x1e, 0xcd,
        0x25, 0x3b, 0x15, 0x34, 0x47, 0xc2, 0x1c, 0x79,
        0xc9, 0x94, 0x66, 0x66, 0xda, 0xe4, 0x44, 0xc4,
        0x9a, 0x31, 0xb1, 0xf9, 0x4d, 0xa6, 0x03, 0xa8,
        0x37, 0x71, 0x68, 0xdc, 0x4f, 0x87, 0x4e, 0x98,
        0xff, 0xf5, 0xae, 0x89, 0xdd, 0x35, 0xd4, 0x4e,
        0x89, 0xdf, 0x57, 0x48, 0x22, 0x3b, 0x7a, 0x24
    },
    cipherText[] = {
        0x4b, 0x52, 0xb5, 0xe8, 0x5a, 0xec, 0xaa, 0xaf,
        0x88, 0x6b, 0xd9, 0xe8, 0x80, 0x53, 0x90, 0xc6,
        0x2e, 0x12, 0xe1, 0x33, 0x57, 0xe4, 0xbe, 0xb3,
        0xb7, 0x13, 0xe3, 0x7d, 0x21, 0x7c, 0x6f, 0x7a,
        0x9e, 0x43, 0x2a, 0x04, 0xf8, 0x7b, 0xd8, 0xa4,
        0xdd, 0x0e, 0xf7, 0x9e, 0xb7, 0xbf, 0x41, 0xb5,
        0xa2, 0xa2, 0x7e, 0x63, 0x36, 0x1d, 0x7c, 0xb7,
        0xaf, 0x7b, 0x3c, 0x9a, 0x8f, 0x0b, 0x56, 0xae,
        0x27, 0xdc, 0x9c, 0xfd, 0x6c, 0x10, 0xeb, 0x1a,
        0x79, 0xc7, 0xbe, 0x35, 0xd3, 0x1c, 0x39, 0x65,
        0xb8, 0xe7, 0x09, 0x97, 0x75, 0xf7, 0x64, 0x40,
        0x29, 0xbd, 0x79, 0x32, 0x1f, 0x5d, 0xd1, 0x2c,
        0x55, 0x28, 0x0a, 0x30, 0xfa, 0xbd, 0x1b, 0x95,
        0xe2, 0x7c, 0x2d, 0x4d, 0xec, 0x6c, 0xa4, 0xd8,
        0x71, 0x6f, 0x36, 0xe7, 0xab, 0xe3, 0x40, 0x8f,
        0x51, 0x20, 0x56, 0x0b, 0x57, 0x3e, 0x54, 0x95,
        0xae, 0x7a, 0xad, 0x66, 0x8f, 0xa8, 0x4d, 0x6a,
        0x8a, 0x11, 0x56, 0xc2, 0x31, 0xa5, 0xb6, 0xd9,
        0x83, 0xec, 0xe3, 0xe2, 0x7d, 0x19, 0x9a, 0x80,
        0x6d, 0xc6, 0x29, 0xc1, 0xa6, 0x0c, 0x08, 0xcc,
        0xb0, 0xe4, 0x80, 0x7d, 0x9f, 0xed, 0x88, 0xf2,
        0x8c, 0xe0, 0xf5, 0x95, 0x83, 0x70, 0x8f, 0x54,
        0x0f, 0x97, 0x11, 0x0b, 0x26, 0x20, 0xb1, 0x67,
        0x92, 0x20, 0xab, 0xe1, 0x3e, 0x3c, 0x4b, 0x72,
        0x71, 0x86, 0xb2, 0x89, 0x79, 0x45, 0x83, 0xb2,
        0x01, 0x54, 0xce, 0x9a, 0x07, 0xa2, 0x84, 0xdf,
        0x3e, 0x63, 0x57, 0x2f, 0x46, 0x21, 0x42, 0xca,
        0xe8, 0x94, 0x9d, 0x7d, 0xd6, 0xf2, 0xb2, 0x6f,
        0xb9, 0x0d, 0x55, 0x6e, 0xc7, 0x5e, 0x93, 0xdd,
        0x33, 0xb5, 0x9d, 0x69, 0x78, 0x83, 0x31, 0x2a,
        0xf8, 0x9e, 0x52, 0x94, 0x5b, 0x9b, 0xae, 0xdf,
        0xeb, 0xe2, 0x87, 0x59, 0xcd, 0xba, 0x4d, 0xfb,
        0xf6, 0xe6, 0xf2, 0x01, 0xb0, 0x87, 0x47, 0x86,
        0x42, 0xcf, 0x0b, 0x34, 0xf9, 0x83, 0x59, 0x3c,
        0x68, 0x94, 0x7e, 0x4e, 0xe0, 0x5b, 0xd1, 0x77,
        0x16, 0xe6, 0xcf, 0xb7, 0xc7, 0x4c, 0x87, 0x6c,
        0x0b, 0xa6, 0x50, 0xf3, 0x97, 0x9f, 0x5e, 0xce,
        0xb7, 0x2a, 0x71, 0xd0, 0xd4, 0x6a, 0xac, 0x44,
        0x74, 0xae, 0x20, 0x48, 0xd2, 0xa9, 0x88, 0x4a,
        0xa1, 0x2e, 0x29, 0x29, 0x50, 0xc7, 0x7b, 0x17,
        0xde, 0x11, 0xe8, 0xd3, 0xe8, 0x95, 0xe6, 0x0b,
        0x1c, 0x58, 0x4b, 0x1c, 0x8d, 0x9e, 0xdd, 0x40,
        0xba, 0x79, 0x17, 0xe3, 0x96, 0xd1, 0xd3, 0xbf,
        0xd1, 0x94, 0x19, 0x23, 0xaa, 0x40, 0x21, 0x31,
        0x95, 0xe8, 0xb8, 0xf7, 0xf4, 0xd5, 0xae, 0x10,
        0x57, 0xcb, 0xec, 0xdf, 0x89, 0xc8, 0x95, 0x97,
        0x45, 0xd1, 0xfc, 0xec, 0xe5, 0x91, 0x15, 0x81,
        0x9d, 0xc6, 0x61, 0xe7, 0xb0, 0x97, 0xc1, 0x32,
        0xe8, 0xf9, 0x87, 0x20, 0xa5, 0x7a, 0x83, 0x46,
        0x9c, 0xb8, 0x2c, 0x37, 0x4f, 0xde, 0xbc, 0x97,
        0xba, 0xdd, 0x7c, 0xef, 0x8d, 0x16, 0x0a, 0x7f,
        0x27, 0xd5, 0x0f, 0x35, 0xb7, 0xe4, 0xaf, 0x6f,
        0x1b, 0x78, 0x36, 0x18, 0x28, 0xe3, 0x2a, 0x55,
        0xb2, 0x5f, 0xd5, 0x6e, 0xfb, 0xc1, 0x2f, 0x8f,
        0xcb, 0x7e, 0x2e, 0x4f, 0x88, 0x2a, 0xfa, 0x0c,
        0x77, 0x47, 0xa4, 0x55, 0xa1, 0xfa, 0xe0, 0x0a,
        0x56, 0x1c, 0xbb, 0x87, 0x8e, 0x01, 0xb3, 0x2f,
        0xaf, 0xb2, 0x3f, 0x39, 0x73, 0x71, 0xa8, 0xb3,
        0x44, 0x1c, 0x8d, 0xa6, 0x54, 0xb9, 0x02, 0xd8,
        0x48, 0x93, 0x83, 0x54, 0x21, 0x88, 0x82, 0x18,
        0x59, 0xa4, 0x4f, 0x0f, 0xb2, 0xb6, 0x3a, 0x49,
        0x83, 0x5f, 0x8b, 0xa5, 0xf0, 0x23, 0x1f, 0xf0,
        0xf8, 0xf5, 0xfc, 0x3d, 0x5c, 0x81, 0x23, 0x31,
        0xb1, 0x1e, 0x39, 0xbc, 0x03, 0x39, 0x4e, 0x28,
        0x75, 0x31, 0x31, 0x66, 0xac, 0x5f, 0x77, 0xe4,
        0x90, 0x01, 0x46, 0xc6, 0xfa, 0xaf, 0xba, 0x81
    };

    uint8_t plain_tmp[528], cipher_tmp[528];
    const struct ccmode_cbc *cbc_encrypt = ccaes_cbc_encrypt_mode();
    const struct ccmode_cbc *cbc_decrypt = ccaes_cbc_decrypt_mode();
    cccbc_ctx_decl(cbc_encrypt->size, cbc_ekey);
    cccbc_ctx_decl(cbc_decrypt->size, cbc_dkey);
    cccbc_iv_decl(cbc_encrypt->block_size, e_iv);
    cccbc_iv_decl(cbc_decrypt->block_size, d_iv);
    unsigned long len;

    memset(cipher_tmp, 0, sizeof(cipher_tmp));
    cccbc_init(cbc_encrypt, cbc_ekey, sizeof(key), key);
    cccbc_set_iv(cbc_encrypt, e_iv, iv);
    ccpad_pkcs7_encrypt(cbc_encrypt, cbc_ekey, e_iv, sizeof(plainText), plainText, cipher_tmp);
    XCAssertMemEquals(sizeof(cipherText), cipher_tmp, cipherText, @"pkcs7 cbc encrypt 512->528 bytes");

    memset(plain_tmp, 0, sizeof(plain_tmp));
    cccbc_init(cbc_decrypt, cbc_dkey, sizeof(key), key);
    cccbc_set_iv(cbc_decrypt, d_iv, iv);
    len = ccpad_pkcs7_decrypt(cbc_decrypt, cbc_dkey, d_iv, sizeof(cipherText), cipherText, plain_tmp);
    XCTAssertEqual(len, sizeof(plainText), @"pkcs7 cbc decrypt len %d != %d", (unsigned int)len, (unsigned int)sizeof(plainText));
    XCAssertMemEquals(sizeof(plainText), plain_tmp, plainText, @"pkcs7 cbc decrypt 528->512 bytes");

    cccbc_set_iv(cbc_encrypt, e_iv, NULL);
    cccbc_set_iv(cbc_decrypt, d_iv, NULL);
}

@end
