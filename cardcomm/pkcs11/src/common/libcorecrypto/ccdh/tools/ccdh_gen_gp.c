/*
 * Copyright (c) 2011,2012,2014,2015 Apple Inc. All rights reserved.
 * 
 * corecrypto Internal Use License Agreement
 * 
 * IMPORTANT:  This Apple corecrypto software is supplied to you by Apple Inc. ("Apple")
 * in consideration of your agreement to the following terms, and your download or use
 * of this Apple software constitutes acceptance of these terms.  If you do not agree
 * with these terms, please do not download or use this Apple software.
 * 
 * 1.	As used in this Agreement, the term "Apple Software" collectively means and
 * includes all of the Apple corecrypto materials provided by Apple here, including
 * but not limited to the Apple corecrypto software, frameworks, libraries, documentation
 * and other Apple-created materials. In consideration of your agreement to abide by the
 * following terms, conditioned upon your compliance with these terms and subject to
 * these terms, Apple grants you, for a period of ninety (90) days from the date you
 * download the Apple Software, a limited, non-exclusive, non-sublicensable license
 * under Apple’s copyrights in the Apple Software to make a reasonable number of copies
 * of, compile, and run the Apple Software internally within your organization only on
 * devices and computers you own or control, for the sole purpose of verifying the
 * security characteristics and correct functioning of the Apple Software; provided
 * that you must retain this notice and the following text and disclaimers in all
 * copies of the Apple Software that you make. You may not, directly or indirectly,
 * redistribute the Apple Software or any portions thereof. The Apple Software is only
 * licensed and intended for use as expressly stated above and may not be used for other
 * purposes or in other contexts without Apple's prior written permission.  Except as
 * expressly stated in this notice, no other rights or licenses, express or implied, are
 * granted by Apple herein.
 * 
 * 2.	The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
 * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES
 * OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING
 * THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS,
 * SYSTEMS, OR SERVICES. APPLE DOES NOT WARRANT THAT THE APPLE SOFTWARE WILL MEET YOUR
 * REQUIREMENTS, THAT THE OPERATION OF THE APPLE SOFTWARE WILL BE UNINTERRUPTED OR
 * ERROR-FREE, THAT DEFECTS IN THE APPLE SOFTWARE WILL BE CORRECTED, OR THAT THE APPLE
 * SOFTWARE WILL BE COMPATIBLE WITH FUTURE APPLE PRODUCTS, SOFTWARE OR SERVICES. NO ORAL
 * OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE OR AN APPLE AUTHORIZED REPRESENTATIVE
 * WILL CREATE A WARRANTY. 
 * 
 * 3.	IN NO EVENT SHALL APPLE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING
 * IN ANY WAY OUT OF THE USE, REPRODUCTION, COMPILATION OR OPERATION OF THE APPLE
 * SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING
 * NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * 4.	This Agreement is effective until terminated. Your rights under this Agreement will
 * terminate automatically without notice from Apple if you fail to comply with any term(s)
 * of this Agreement.  Upon termination, you agree to cease all use of the Apple Software
 * and destroy all copies, full or partial, of the Apple Software. This Agreement will be
 * governed and construed in accordance with the laws of the State of California, without
 * regard to its choice of law rules.
 * 
 * You may report security issues about Apple products to product-security@apple.com,
 * as described here:  https://www.apple.com/support/security/.  Non-security bugs and
 * enhancement requests can be made via https://bugreport.apple.com as described
 * here: https://developer.apple.com/bug-reporting/
 *
 * EA1350 
 * 10/5/15
 */


/* This tool can be used to generate group parameters as static ccdh_gp_t.
   This is using corecrypto itself
   CAVEAT: this tool can only generate the parameters for the native cc_unit size
 */

#include <stdlib.h>
#include <inttypes.h>

#include <corecrypto/ccdh.h>
#include <corecrypto/cc_debug.h>

#include "rfc3526DhGroups.h"
#include "rfc5114DhGroups.h"
#include "rfc5054SrpGroups.h"

/* template for header file :*/
static char *h_template =
"ccdh_const_gp_t %s(void);\n";

/* template for source file :*/
static char *c_template = 
"/* Autogenerated file - Use scheme ccdh_gen_gp */\n"
"#include <corecrypto/ccdh_priv.h>\n"
"#include <corecrypto/%s_gp.h>\n"
"\n"
"static const ccdh_gp_decl_static(%d) _%s =\n"
"{\n"
"    .zp = {\n"
"        .n = ccn_nof(%d),\n"
"        .options = %d,\n"
"        .mod_prime = cczp_mod\n"
"    },\n"
"    .p = {\n"
"        /* prime */\n"
"        %s\n"
"    },\n"
"    .recip = {\n"
"        /* recip */\n"
"        %s\n"
"    },\n"
"    .g = {\n"
"        /* g */\n"
"        %s\n"
"    },\n"
"    .q = {\n"
"        /* q */\n"
"        %s\n"
"    },\n"
"    .l = %zu,\n"
"};\n"
"\n"
"ccdh_const_gp_t %s(void)\n"
"{\n"
"    return (ccdh_const_gp_t)(cczp_const_t)(const cc_unit *)&_%s;\n"
"}\n\n";

static void sprint_ccnc(char **s, const cc_unit *u, size_t bytes)
{
    bool comma = false;
    *s += sprintf(*s, "CCN%zu_C(", bytes * 8);
    for (size_t i = ((bytes + CCN_UNIT_SIZE - 1) / CCN_UNIT_SIZE); i-- > 0;) {
        cc_unit v = u[i];
        for (size_t j = (CCN_UNIT_SIZE - bytes) % CCN_UNIT_SIZE;
             j < CCN_UNIT_SIZE && bytes > 0; ++j, --bytes) {
            uint8_t byte = v >> ((CCN_UNIT_SIZE - 1 - j) * 8);
            *s += sprintf(*s, "%s%.02" PRIx8, comma ? "," :"", byte);
            comma = true;
        }
    }
    *s += sprintf(*s, ")");
}

static void sprint_ccunits(char *s, cc_size n, const cc_unit *u)
{
    size_t i;
    size_t n8 = ((n * CCN_UNIT_SIZE)-1) / 8;
    for (i = 0; i < n8; ++i) {
        if (i)
            s += sprintf(s, ",");
        if ((i%2)==0 && i <= n8 && i) {s += sprintf(s, "\n        ");};
        sprint_ccnc(&s, u, 8);
        u += 8 / CCN_UNIT_SIZE;
    }

    size_t remainder = n * CCN_UNIT_SIZE - n8 * 8;
    if (remainder) {
        size_t bytes_todo = ccn_write_uint_size(remainder / CCN_UNIT_SIZE, u);
        if (!bytes_todo)
            bytes_todo = 1;
        u += (remainder - bytes_todo) / CCN_UNIT_SIZE;
        s += sprintf(s, ",");
        if ((i%2)==0 && i <= n8 && i) {s += sprintf(s, "\n        ");};
        sprint_ccnc(&s, u, bytes_todo);
    }
}

/* Debugger does not like stack arrays with variable size */
#if 0
#define strsize(n) ((n)*(CCN_UNIT_SIZE*4+9))
#else
#define strsize(n) (8192)
#endif

#define H_FILENAME "%s/ccdh/corecrypto/ccdh_gp.h"
#define C_FILENAME "%s/%s/src/%s.c"

static void print_params(FILE *hfile, const char *path, const char *inc, const char *name, ccdh_const_gp_t gp)
{
    FILE *cfile;
    cc_size n = ccdh_gp_n(gp);
   
    char prime[strsize(n)+n];
    char recip[strsize(n+1)+n];
    char g[strsize(n)+n];
    char q[strsize(n)+n];
    char filename[strlen(C_FILENAME)+strlen(path)+strlen(inc)+strlen(name)];
    cc_size l = ccdh_gp_l(gp);

    sprint_ccunits(prime, n, ccdh_gp_prime(gp));
    sprint_ccunits(recip, n+1, ccdh_gp_recip(gp));
    sprint_ccunits(g, n, ccdh_gp_g(gp));
    sprint_ccunits(q, n, ccdh_gp_order(gp));

    sprintf(filename, C_FILENAME, path, inc, name);
    
    cfile=fopen(filename, "w");
    assert(cfile!=NULL);    

    fprintf(cfile, c_template, inc, ccn_bitsof_n(n), name, ccn_bitsof_n(n),ccdh_gp_options(gp), prime, recip, g, q, l, name, name);
    fprintf(hfile, h_template, name);
    
    fclose(cfile);
    
}

#define GROUP_VECTOR(_group_) \
    .pLen = sizeof(_group_.p),          \
    .p = _group_.p,                     \
    .gLen = sizeof(_group_.g),          \
    .g = _group_.g,                     \
    .qLen = sizeof(_group_.q),          \
    .q = _group_.q,                     \
    .lLen = sizeof(_group_.l),          \
    .l = _group_.l,                     \

#define GROUP_VECTOR_NO_ORDER(_group_)  \
    .pLen = sizeof(_group_.p),          \
    .p = _group_.p,                     \
    .gLen = sizeof(_group_.g),          \
    .g = _group_.g,                     \
    .qLen = 0,                          \
    .q = NULL,                          \
    .lLen = sizeof(_group_.l),          \
    .l = _group_.l,                     \


#define GROUP_VECTOR_DH(_len_, _group_) \
{                                       \
    .len  = _len_,                      \
    .inc  = "ccdh",                     \
    .name = "ccdh_gp_" #_group_,        \
    GROUP_VECTOR(_group_) \
}

#define GROUP_VECTOR_DH_NO_ORDER(_len_, _group_) \
{                                       \
    .len  = _len_,                      \
    .inc  = "ccdh",                     \
    .name = "ccdh_gp_" #_group_,        \
    GROUP_VECTOR_NO_ORDER(_group_) \
}

#define GROUP_VECTOR_SRP_NO_ORDER(_len_, _group_)\
{                                       \
    .len = _len_,                       \
    .inc  = "ccsrp",               \
    .name = "ccsrp_gp_" #_group_,       \
    GROUP_VECTOR_NO_ORDER(_group_) \
}

static struct ccdh_gen_vectors {
    unsigned int len;
    char *inc;
    char *name;
    size_t pLen;
    const uint8_t *p;
    size_t gLen;
    const uint8_t *g;
    size_t qLen;
    const uint8_t *q;
    size_t lLen;
    const uint8_t *l;
} dh_gen_vectors[] = {
    GROUP_VECTOR_DH(1024, rfc5114_MODP_1024_160),
    GROUP_VECTOR_DH(2048, rfc5114_MODP_2048_224),
    GROUP_VECTOR_DH(2048, rfc5114_MODP_2048_256),
    
    GROUP_VECTOR_DH_NO_ORDER(1536, rfc3526group05),
    GROUP_VECTOR_DH_NO_ORDER(2048, rfc3526group14),
    GROUP_VECTOR_DH_NO_ORDER(3072, rfc3526group15),
    GROUP_VECTOR_DH_NO_ORDER(4096, rfc3526group16),
    GROUP_VECTOR_DH_NO_ORDER(6144, rfc3526group17),
    GROUP_VECTOR_DH_NO_ORDER(8192, rfc3526group18),
    
    GROUP_VECTOR_SRP_NO_ORDER(1024, rfc5054_1024),
    GROUP_VECTOR_SRP_NO_ORDER(2048, rfc5054_2048),
    GROUP_VECTOR_SRP_NO_ORDER(3072, rfc5054_3072),
    GROUP_VECTOR_SRP_NO_ORDER(4096, rfc5054_4096),
    GROUP_VECTOR_SRP_NO_ORDER(8192, rfc5054_8192),
};

#define N_GROUPS (sizeof(dh_gen_vectors)/sizeof(dh_gen_vectors[0]))

static void generate_static_groups(const char *path)
{
    FILE *hfile;
    char hfilename[strlen(H_FILENAME)+strlen(path)];
    sprintf(hfilename, H_FILENAME, path);
    hfile=fopen(hfilename, "w");
    assert(hfile!=NULL);    

    fprintf(hfile, "/* Autogenerated by %s */\n", __FILE__);
    fprintf(hfile, "#ifndef _CORECRYPTO_CCDH_GP_H_\n");
    fprintf(hfile, "#define _CORECRYPTO_CCDH_GP_H_\n\n");
    fprintf(hfile, "#include <corecrypto/ccdh.h>\n\n");

    for(unsigned int i=0; i<N_GROUPS; i++) {
        struct ccdh_gen_vectors *v = &dh_gen_vectors[i];
        const cc_size n = ccn_nof(v->len);
        ccdh_gp_decl(ccn_sizeof(v->len), gp);
        cc_unit p[n];
        cc_unit g[n];
        cc_unit q[n];
        cc_size l = 0;

        ccn_read_uint(n, p, v->pLen, v->p); /* Prime */
        ccn_read_uint(n, g, v->gLen, v->g); /* Generator */
        for (size_t j = 0; j < v->lLen; ++j) /* Private key length */
            l = (l << 8) |  v->l[j];

        // Order is optional
        if (v->qLen && v->q!=NULL){
            ccn_read_uint(n, q, v->qLen, v->q);
            ccdh_init_gp_with_order(gp, n, p, g, q);
        }
        else {
            ccdh_init_gp(gp, n, p, g, l);
        }

        print_params(hfile, path, v->inc, v->name, gp);
    }

    fprintf(hfile, "\n#endif /* _CORECRYPTO_CCDH_GP_H_ */\n");

    fclose(hfile);
}

int main (void)
{
    // insert code here...
    char *path=getenv("DIR");
    
    cc_printf("Generating files in %s\n", path);
    
    generate_static_groups(path);
    
    return 0;
}
