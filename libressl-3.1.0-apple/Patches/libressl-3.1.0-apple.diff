Binary files libressl-3.1.0/.DS_Store and libressl-3.1.0-apple/.DS_Store differ
diff -Nur libressl-3.1.0/MacOS/GUSI_Init.cpp libressl-3.1.0-apple/MacOS/GUSI_Init.cpp
--- libressl-3.1.0/MacOS/GUSI_Init.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GUSI_Init.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,62 @@
+/**************** BEGIN GUSI CONFIGURATION ****************************
+ *
+ * GUSI Configuration section generated by GUSI Configurator
+ * last modified: Wed Jan  5 20:33:51 2000
+ *
+ * This section will be overwritten by the next run of Configurator.
+ */
+
+#define GUSI_SOURCE
+#include <GUSIConfig.h>
+#include <sys/cdefs.h>
+
+/* Declarations of Socket Factories */
+
+__BEGIN_DECLS
+void GUSIwithInetSockets();
+void GUSIwithLocalSockets();
+void GUSIwithMTInetSockets();
+void GUSIwithMTTcpSockets();
+void GUSIwithMTUdpSockets();
+void GUSIwithOTInetSockets();
+void GUSIwithOTTcpSockets();
+void GUSIwithOTUdpSockets();
+void GUSIwithPPCSockets();
+void GUSISetupFactories();
+__END_DECLS
+
+/* Configure Socket Factories */
+
+void GUSISetupFactories()
+{
+#ifdef GUSISetupFactories_BeginHook
+	GUSISetupFactories_BeginHook
+#endif
+	GUSIwithInetSockets();
+#ifdef GUSISetupFactories_EndHook
+	GUSISetupFactories_EndHook
+#endif
+}
+
+/* Declarations of File Devices */
+
+__BEGIN_DECLS
+void GUSIwithDConSockets();
+void GUSIwithNullSockets();
+void GUSISetupDevices();
+__END_DECLS
+
+/* Configure File Devices */
+
+void GUSISetupDevices()
+{
+#ifdef GUSISetupDevices_BeginHook
+	GUSISetupDevices_BeginHook
+#endif
+	GUSIwithNullSockets();
+#ifdef GUSISetupDevices_EndHook
+	GUSISetupDevices_EndHook
+#endif
+}
+
+/**************** END GUSI CONFIGURATION *************************/
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/CPStringUtils.cpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/CPStringUtils.cpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/CPStringUtils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/CPStringUtils.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,2753 @@
+/* ====================================================================
+ * Copyright (c) 1998-1999 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+ 
+ 
+ 
+ #include "CPStringUtils.hpp"
+#include "ErrorHandling.hpp"
+
+
+
+#define kNumberFormatString			"\p########0.00#######;-########0.00#######"
+
+
+
+//	Useful utility functions which could be optimized a whole lot
+
+
+void CopyPStrToCStr(const unsigned char *thePStr,char *theCStr,const int maxCStrLength)
+{
+int		i,numPChars;
+
+
+	if (thePStr != nil && theCStr != nil && maxCStrLength > 0)
+	{
+		numPChars = thePStr[0];
+		
+		for (i = 0;;i++)
+		{
+			if (i >= numPChars || i >= maxCStrLength - 1)
+			{
+				theCStr[i] = 0;
+				
+				break;
+			}
+			
+			else
+			{
+				theCStr[i] = thePStr[i + 1];
+			}
+		}
+	}
+}
+
+
+void CopyPStrToPStr(const unsigned char *theSrcPStr,unsigned char *theDstPStr,const int maxDstStrLength)
+{
+int		theMaxDstStrLength;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+	
+	
+	if (theDstPStr != nil && theSrcPStr != nil && theMaxDstStrLength > 0)
+	{
+		if (theMaxDstStrLength > 255)
+		{
+			theMaxDstStrLength = 255;
+		}
+		
+		
+		if (theMaxDstStrLength - 1 < theSrcPStr[0])
+		{
+			BlockMove(theSrcPStr + 1,theDstPStr + 1,theMaxDstStrLength - 1);
+			
+			theDstPStr[0] = theMaxDstStrLength - 1;
+		}
+		
+		else
+		{
+			BlockMove(theSrcPStr,theDstPStr,theSrcPStr[0] + 1);
+		}
+	}
+}
+
+
+void CopyCStrToCStr(const char *theSrcCStr,char *theDstCStr,const int maxDstStrLength)
+{
+int		i;
+
+
+	if (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0)
+	{
+		for (i = 0;;i++)
+		{
+			if (theSrcCStr[i] == 0 || i >= maxDstStrLength - 1)
+			{
+				theDstCStr[i] = 0;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstCStr[i] = theSrcCStr[i];
+			}
+		}
+	}
+}
+
+
+
+void CopyCSubstrToCStr(const char *theSrcCStr,const int maxCharsToCopy,char *theDstCStr,const int maxDstStrLength)
+{
+int		i;
+
+
+	if (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0)
+	{
+		for (i = 0;;i++)
+		{
+			if (theSrcCStr[i] == 0 || i >= maxDstStrLength - 1 || i >= maxCharsToCopy)
+			{
+				theDstCStr[i] = 0;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstCStr[i] = theSrcCStr[i];
+			}
+		}
+	}
+}
+
+
+
+void CopyCSubstrToPStr(const char *theSrcCStr,const int maxCharsToCopy,unsigned char *theDstPStr,const int maxDstStrLength)
+{
+int		i;
+int		theMaxDstStrLength;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+
+	if (theDstPStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
+	{
+		if (theMaxDstStrLength > 255)
+		{
+			theMaxDstStrLength = 255;
+		}
+		
+		
+		for (i = 0;;i++)
+		{
+			if (theSrcCStr[i] == 0 || i >= theMaxDstStrLength - 1 || i >= maxCharsToCopy)
+			{
+				theDstPStr[0] = i;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstPStr[i + 1] = theSrcCStr[i];
+			}
+		}
+	}
+}
+
+
+
+void CopyCStrToPStr(const char *theSrcCStr,unsigned char *theDstPStr,const int maxDstStrLength)
+{
+int		i;
+int		theMaxDstStrLength;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+
+	if (theDstPStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
+	{
+		if (theMaxDstStrLength > 255)
+		{
+			theMaxDstStrLength = 255;
+		}
+		
+		
+		for (i = 0;;i++)
+		{
+			if (i >= theMaxDstStrLength - 1 || theSrcCStr[i] == 0)
+			{
+				theDstPStr[0] = i;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstPStr[i + 1] = theSrcCStr[i];
+			}
+		}
+	}
+}
+
+
+void ConcatPStrToCStr(const unsigned char *thePStr,char *theCStr,const int maxCStrLength)
+{
+int		i,numPChars,cStrLength;
+
+
+	if (thePStr != nil && theCStr != nil && maxCStrLength > 0)
+	{
+		for (cStrLength = 0;theCStr[cStrLength] != 0;cStrLength++)
+		{
+		
+		}
+		
+
+		numPChars = thePStr[0];
+		
+		
+		for (i = 0;;i++)
+		{
+			if (i >= numPChars || cStrLength >= maxCStrLength - 1)
+			{
+				theCStr[cStrLength++] = 0;
+				
+				break;
+			}
+			
+			else
+			{
+				theCStr[cStrLength++] = thePStr[i + 1];
+			}
+		}
+	}
+}
+
+
+
+void ConcatPStrToPStr(const unsigned char *theSrcPStr,unsigned char *theDstPStr,const int maxDstStrLength)
+{
+int		theMaxDstStrLength;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+	
+	if (theSrcPStr != nil && theDstPStr != nil && theMaxDstStrLength > 0)
+	{
+		if (theMaxDstStrLength > 255)
+		{
+			theMaxDstStrLength = 255;
+		}
+		
+		
+		if (theMaxDstStrLength - theDstPStr[0] - 1 < theSrcPStr[0])
+		{
+			BlockMove(theSrcPStr + 1,theDstPStr + theDstPStr[0] + 1,theMaxDstStrLength - 1 - theDstPStr[0]);
+			
+			theDstPStr[0] = theMaxDstStrLength - 1;
+		}
+		
+		else
+		{
+			BlockMove(theSrcPStr + 1,theDstPStr + theDstPStr[0] + 1,theSrcPStr[0]);
+			
+			theDstPStr[0] += theSrcPStr[0];
+		}
+	}
+}
+
+
+
+void ConcatCStrToPStr(const char *theSrcCStr,unsigned char *theDstPStr,const int maxDstStrLength)
+{
+int		i,thePStrLength;
+int		theMaxDstStrLength;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+
+	if (theSrcCStr != nil && theDstPStr != nil && theMaxDstStrLength > 0)
+	{
+		if (theMaxDstStrLength > 255)
+		{
+			theMaxDstStrLength = 255;
+		}
+		
+		
+		thePStrLength = theDstPStr[0];
+		
+		for (i = 0;;i++)
+		{
+			if (theSrcCStr[i] == 0 || thePStrLength >= theMaxDstStrLength - 1)
+			{
+				theDstPStr[0] = thePStrLength;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstPStr[thePStrLength + 1] = theSrcCStr[i];
+				
+				thePStrLength++;
+			}
+		}
+	}
+}
+
+
+
+void ConcatCStrToCStr(const char *theSrcCStr,char *theDstCStr,const int maxCStrLength)
+{
+int		cStrLength;
+
+
+	if (theSrcCStr != nil && theDstCStr != nil && maxCStrLength > 0)
+	{
+		for (cStrLength = 0;theDstCStr[cStrLength] != 0;cStrLength++)
+		{
+		
+		}
+		
+
+		for (;;)
+		{
+			if (*theSrcCStr == 0 || cStrLength >= maxCStrLength - 1)
+			{
+				theDstCStr[cStrLength++] = 0;
+				
+				break;
+			}
+			
+			else
+			{
+				theDstCStr[cStrLength++] = *theSrcCStr++;
+			}
+		}
+	}
+}
+
+
+
+void ConcatCharToCStr(const char theChar,char *theDstCStr,const int maxCStrLength)
+{
+int		cStrLength;
+
+
+	if (theDstCStr != nil && maxCStrLength > 0)
+	{
+		cStrLength = CStrLength(theDstCStr);
+		
+		if (cStrLength < maxCStrLength - 1)
+		{
+			theDstCStr[cStrLength++] = theChar;
+			theDstCStr[cStrLength++] = '\0';
+		}
+	}
+}
+
+
+
+void ConcatCharToPStr(const char theChar,unsigned char *theDstPStr,const int maxPStrLength)
+{
+int		pStrLength;
+
+
+	if (theDstPStr != nil && maxPStrLength > 0)
+	{
+		pStrLength = PStrLength(theDstPStr);
+		
+		if (pStrLength < maxPStrLength - 1 && pStrLength < 255)
+		{
+			theDstPStr[pStrLength + 1] = theChar;
+			theDstPStr[0] += 1;
+		}
+	}
+}
+
+
+
+
+int CompareCStrs(const char *theFirstCStr,const char *theSecondCStr,const Boolean ignoreCase)
+{
+int		returnValue;
+char	firstChar,secondChar;
+
+	
+	returnValue = 0;
+	
+	
+	if (theFirstCStr != nil && theSecondCStr != nil)
+	{
+		for (;;)
+		{
+			firstChar = *theFirstCStr;
+			secondChar = *theSecondCStr;
+			
+			if (ignoreCase == true)
+			{
+				if (firstChar >= 'A' && firstChar <= 'Z')
+				{
+					firstChar = 'a' + (firstChar - 'A');
+				}
+				
+				if (secondChar >= 'A' && secondChar <= 'Z')
+				{
+					secondChar = 'a' + (secondChar - 'A');
+				}
+			}
+			
+			
+			if (firstChar == 0 && secondChar != 0)
+			{
+				returnValue = -1;
+				
+				break;
+			}
+			
+			else if (firstChar != 0 && secondChar == 0)
+			{
+				returnValue = 1;
+				
+				break;
+			}
+			
+			else if (firstChar == 0 && secondChar == 0)
+			{
+				returnValue = 0;
+				
+				break;
+			}
+			
+			else if (firstChar < secondChar)
+			{
+				returnValue = -1;
+				
+				break;
+			}
+			
+			else if (firstChar > secondChar)
+			{
+				returnValue = 1;
+				
+				break;
+			}
+			
+			theFirstCStr++;
+			theSecondCStr++;
+		}
+	}
+	
+	
+	return(returnValue);
+}
+
+
+
+Boolean CStrsAreEqual(const char *theFirstCStr,const char *theSecondCStr,const Boolean ignoreCase)
+{
+	if (CompareCStrs(theFirstCStr,theSecondCStr,ignoreCase) == 0)
+	{
+		return true;
+	}
+	
+	else
+	{
+		return false;
+	}
+}
+
+
+Boolean PStrsAreEqual(const unsigned char *theFirstPStr,const unsigned char *theSecondPStr,const Boolean ignoreCase)
+{
+	if (ComparePStrs(theFirstPStr,theSecondPStr,ignoreCase) == 0)
+	{
+		return true;
+	}
+	
+	else
+	{
+		return false;
+	}
+}
+
+
+
+int ComparePStrs(const unsigned char *theFirstPStr,const unsigned char *theSecondPStr,const Boolean ignoreCase)
+{
+int		i,returnValue;
+char	firstChar,secondChar;
+
+	
+	returnValue = 0;
+	
+	
+	if (theFirstPStr != nil && theSecondPStr != nil)
+	{
+		for (i = 1;;i++)
+		{
+			firstChar = theFirstPStr[i];
+			secondChar = theSecondPStr[i];
+
+			if (ignoreCase == true)
+			{
+				if (firstChar >= 'A' && firstChar <= 'Z')
+				{
+					firstChar = 'a' + (firstChar - 'A');
+				}
+				
+				if (secondChar >= 'A' && secondChar <= 'Z')
+				{
+					secondChar = 'a' + (secondChar - 'A');
+				}
+			}
+
+
+			if (theFirstPStr[0] < i && theSecondPStr[0] >= i)
+			{
+				returnValue = -1;
+				
+				break;
+			}
+			
+			else if (theFirstPStr[0] >= i && theSecondPStr[0] < i)
+			{
+				returnValue = 1;
+				
+				break;
+			}
+			
+			else if (theFirstPStr[0] < i && theSecondPStr[0] < i)
+			{
+				returnValue = 0;
+				
+				break;
+			}
+			
+			else if (firstChar < secondChar)
+			{
+				returnValue = -1;
+				
+				break;
+			}
+			
+			else if (firstChar > secondChar)
+			{
+				returnValue = 1;
+				
+				break;
+			}
+		}
+	}
+	
+	
+	return(returnValue);
+}
+
+
+
+int CompareCStrToPStr(const char *theCStr,const unsigned char *thePStr,const Boolean ignoreCase)
+{
+int		returnValue;
+char	tempString[256];
+
+	
+	returnValue = 0;
+	
+	if (theCStr != nil && thePStr != nil)
+	{
+		CopyPStrToCStr(thePStr,tempString,sizeof(tempString));
+		
+		returnValue = CompareCStrs(theCStr,tempString,ignoreCase);
+	}
+	
+	
+	return(returnValue);
+}
+
+
+
+void ConcatLongIntToCStr(const long theNum,char *theCStr,const int maxCStrLength,const int numDigits)
+{
+Str255 		theStr255;
+
+
+	NumToString(theNum,theStr255);
+
+
+	if (numDigits > 0)
+	{
+	int 	charsToInsert;
+	
+		
+		charsToInsert = numDigits - PStrLength(theStr255);
+		
+		if (charsToInsert > 0)
+		{
+		char	tempString[256];
+			
+			CopyCStrToCStr("",tempString,sizeof(tempString));
+			
+			for (;charsToInsert > 0;charsToInsert--)
+			{
+				ConcatCStrToCStr("0",tempString,sizeof(tempString));
+			}
+			
+			ConcatPStrToCStr(theStr255,tempString,sizeof(tempString));
+			
+			CopyCStrToPStr(tempString,theStr255,sizeof(theStr255));
+		}
+	}
+
+
+	ConcatPStrToCStr(theStr255,theCStr,maxCStrLength);
+}
+
+
+
+
+void ConcatLongIntToPStr(const long theNum,unsigned char *thePStr,const int maxPStrLength,const int numDigits)
+{
+Str255 		theStr255;
+
+
+	NumToString(theNum,theStr255);
+
+
+	if (numDigits > 0)
+	{
+	int 	charsToInsert;
+	
+		
+		charsToInsert = numDigits - PStrLength(theStr255);
+		
+		if (charsToInsert > 0)
+		{
+		char	tempString[256];
+			
+			CopyCStrToCStr("",tempString,sizeof(tempString));
+			
+			for (;charsToInsert > 0;charsToInsert--)
+			{
+				ConcatCStrToCStr("0",tempString,sizeof(tempString));
+			}
+			
+			ConcatPStrToCStr(theStr255,tempString,sizeof(tempString));
+			
+			CopyCStrToPStr(tempString,theStr255,sizeof(theStr255));
+		}
+	}
+
+
+	ConcatPStrToPStr(theStr255,thePStr,maxPStrLength);
+}
+
+
+
+void CopyCStrAndConcatLongIntToCStr(const char *theSrcCStr,const long theNum,char *theDstCStr,const int maxDstStrLength)
+{
+	CopyCStrToCStr(theSrcCStr,theDstCStr,maxDstStrLength);
+	
+	ConcatLongIntToCStr(theNum,theDstCStr,maxDstStrLength);
+}
+
+
+
+void CopyLongIntToCStr(const long theNum,char *theCStr,const int maxCStrLength,const int numDigits)
+{
+Str255 		theStr255;
+
+
+	NumToString(theNum,theStr255);
+
+
+	if (numDigits > 0)
+	{
+	int 	charsToInsert;
+	
+		
+		charsToInsert = numDigits - PStrLength(theStr255);
+		
+		if (charsToInsert > 0)
+		{
+		char	tempString[256];
+			
+			CopyCStrToCStr("",tempString,sizeof(tempString));
+			
+			for (;charsToInsert > 0;charsToInsert--)
+			{
+				ConcatCStrToCStr("0",tempString,sizeof(tempString));
+			}
+			
+			ConcatPStrToCStr(theStr255,tempString,sizeof(tempString));
+			
+			CopyCStrToPStr(tempString,theStr255,sizeof(theStr255));
+		}
+	}
+
+
+	CopyPStrToCStr(theStr255,theCStr,maxCStrLength);
+}
+
+
+
+
+
+void CopyUnsignedLongIntToCStr(const unsigned long theNum,char *theCStr,const int maxCStrLength)
+{
+char			tempString[256];
+int				srcCharIndex,dstCharIndex;
+unsigned long	tempNum,quotient,remainder;
+
+	
+	if (theNum == 0)
+	{
+		CopyCStrToCStr("0",theCStr,maxCStrLength);
+	}
+	
+	else
+	{
+		srcCharIndex = 0;
+		
+		tempNum = theNum;
+		
+		for (;;)
+		{
+			if (srcCharIndex >= sizeof(tempString) - 1 || tempNum == 0)
+			{
+				for (dstCharIndex = 0;;)
+				{
+					if (dstCharIndex >= maxCStrLength - 1 || srcCharIndex <= 0)
+					{
+						theCStr[dstCharIndex] = 0;
+						
+						break;
+					}
+					
+					theCStr[dstCharIndex++] = tempString[--srcCharIndex];
+				}
+				
+				break;
+			}
+			
+
+			quotient = tempNum / 10;
+			
+			remainder = tempNum - (quotient * 10);
+			
+			tempString[srcCharIndex] = '0' + remainder;
+			
+			srcCharIndex++;
+			
+			tempNum = quotient;
+		}
+	}
+}
+
+
+
+
+void CopyLongIntToPStr(const long theNum,unsigned char *thePStr,const int maxPStrLength,const int numDigits)
+{
+char	tempString[256];
+
+
+	CopyLongIntToCStr(theNum,tempString,sizeof(tempString),numDigits);
+	
+	CopyCStrToPStr(tempString,thePStr,maxPStrLength);
+}
+
+
+
+OSErr CopyLongIntToNewHandle(const long inTheLongInt,Handle *theHandle)
+{
+OSErr		errCode = noErr;
+char		tempString[32];
+	
+	
+	CopyLongIntToCStr(inTheLongInt,tempString,sizeof(tempString));
+	
+	errCode = CopyCStrToNewHandle(tempString,theHandle);
+
+	return(errCode);
+}
+
+
+OSErr CopyLongIntToExistingHandle(const long inTheLongInt,Handle theHandle)
+{
+OSErr		errCode = noErr;
+char		tempString[32];
+	
+	
+	CopyLongIntToCStr(inTheLongInt,tempString,sizeof(tempString));
+	
+	errCode = CopyCStrToExistingHandle(tempString,theHandle);
+
+	return(errCode);
+}
+
+
+
+
+OSErr CopyCStrToExistingHandle(const char *theCString,Handle theHandle)
+{
+OSErr	errCode = noErr;
+long	stringLength;
+
+	
+	if (theCString == nil)
+	{
+		SetErrorMessageAndBail(("CopyCStrToExistingHandle: Bad parameter, theCString == nil"));
+	}
+
+	if (theHandle == nil)
+	{
+		SetErrorMessageAndBail(("CopyCStrToExistingHandle: Bad parameter, theHandle == nil"));
+	}
+
+	if (*theHandle == nil)
+	{
+		SetErrorMessageAndBail(("CopyCStrToExistingHandle: Bad parameter, *theHandle == nil"));
+	}
+
+
+
+	stringLength = CStrLength(theCString) + 1;
+	
+	SetHandleSize(theHandle,stringLength);
+	
+	if (GetHandleSize(theHandle) < stringLength)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyCStrToExistingHandle: Can't set Handle size, MemError() = ",MemError());
+	}
+	
+	
+	::BlockMove(theCString,*theHandle,stringLength);
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+
+
+
+OSErr CopyCStrToNewHandle(const char *theCString,Handle *theHandle)
+{
+OSErr	errCode = noErr;
+long	stringLength;
+
+	
+	if (theCString == nil)
+	{
+		SetErrorMessageAndBail(("CopyCStrToNewHandle: Bad parameter, theCString == nil"));
+	}
+
+	if (theHandle == nil)
+	{
+		SetErrorMessageAndBail(("CopyCStrToNewHandle: Bad parameter, theHandle == nil"));
+	}
+
+
+
+	stringLength = CStrLength(theCString) + 1;
+	
+	*theHandle = NewHandle(stringLength);
+	
+	if (*theHandle == nil)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyCStrToNewHandle: Can't allocate Handle, MemError() = ",MemError());
+	}
+	
+	
+	::BlockMove(theCString,**theHandle,stringLength);
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+
+OSErr CopyPStrToNewHandle(const unsigned char *thePString,Handle *theHandle)
+{
+OSErr	errCode = noErr;
+long	stringLength;
+
+	
+	if (thePString == nil)
+	{
+		SetErrorMessageAndBail(("CopyPStrToNewHandle: Bad parameter, thePString == nil"));
+	}
+
+	if (theHandle == nil)
+	{
+		SetErrorMessageAndBail(("CopyPStrToNewHandle: Bad parameter, theHandle == nil"));
+	}
+
+
+
+	stringLength = PStrLength(thePString) + 1;
+	
+	*theHandle = NewHandle(stringLength);
+	
+	if (*theHandle == nil)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyPStrToNewHandle: Can't allocate Handle, MemError() = ",MemError());
+	}
+	
+	
+	if (stringLength > 1)
+	{
+		BlockMove(thePString + 1,**theHandle,stringLength - 1);
+	}
+	
+	(**theHandle)[stringLength - 1] = 0;
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+OSErr AppendPStrToHandle(const unsigned char *thePString,Handle theHandle,long *currentLength)
+{
+OSErr		errCode = noErr;
+char		tempString[256];
+
+	
+	CopyPStrToCStr(thePString,tempString,sizeof(tempString));
+	
+	errCode = AppendCStrToHandle(tempString,theHandle,currentLength);
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+
+OSErr AppendCStrToHandle(const char *theCString,Handle theHandle,long *currentLength,long *maxLength)
+{
+OSErr		errCode = noErr;
+long		handleMaxLength,handleCurrentLength,stringLength,byteCount;
+
+
+	if (theCString == nil)
+	{
+		SetErrorMessageAndBail(("AppendCStrToHandle: Bad parameter, theCString == nil"));
+	}
+
+	if (theHandle == nil)
+	{
+		SetErrorMessageAndBail(("AppendCStrToHandle: Bad parameter, theHandle == nil"));
+	}
+	
+	
+	if (maxLength != nil)
+	{
+		handleMaxLength = *maxLength;
+	}
+	
+	else
+	{
+		handleMaxLength = GetHandleSize(theHandle);
+	}
+	
+	
+	if (currentLength != nil && *currentLength >= 0)
+	{
+		handleCurrentLength = *currentLength;
+	}
+	
+	else
+	{
+		handleCurrentLength = CStrLength(*theHandle);
+	}
+	
+	
+	stringLength = CStrLength(theCString);
+	
+	byteCount = handleCurrentLength + stringLength + 1;
+	
+	if (byteCount > handleMaxLength)
+	{
+		SetHandleSize(theHandle,handleCurrentLength + stringLength + 1);
+		
+		if (maxLength != nil)
+		{
+			*maxLength = GetHandleSize(theHandle);
+			
+			handleMaxLength = *maxLength;
+		}
+		
+		else
+		{
+			handleMaxLength = GetHandleSize(theHandle);
+		}
+
+		if (byteCount > handleMaxLength)
+		{
+			SetErrorMessageAndLongIntAndBail("AppendCStrToHandle: Can't increase Handle allocation, MemError() = ",MemError());
+		}
+	}
+	
+	
+	BlockMove(theCString,*theHandle + handleCurrentLength,stringLength + 1);
+	
+	
+	if (currentLength != nil)
+	{
+		*currentLength += stringLength;
+	}
+
+
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr AppendCharsToHandle(const char *theChars,const int numChars,Handle theHandle,long *currentLength,long *maxLength)
+{
+OSErr		errCode = noErr;
+long		handleMaxLength,handleCurrentLength,byteCount;
+
+
+	if (theChars == nil)
+	{
+		SetErrorMessageAndBail(("AppendCharsToHandle: Bad parameter, theChars == nil"));
+	}
+
+	if (theHandle == nil)
+	{
+		SetErrorMessageAndBail(("AppendCharsToHandle: Bad parameter, theHandle == nil"));
+	}
+	
+	
+	if (maxLength != nil)
+	{
+		handleMaxLength = *maxLength;
+	}
+	
+	else
+	{
+		handleMaxLength = GetHandleSize(theHandle);
+	}
+	
+	
+	if (currentLength != nil && *currentLength >= 0)
+	{
+		handleCurrentLength = *currentLength;
+	}
+	
+	else
+	{
+		handleCurrentLength = CStrLength(*theHandle);
+	}
+	
+	
+	byteCount = handleCurrentLength + numChars + 1;
+	
+	if (byteCount > handleMaxLength)
+	{
+		SetHandleSize(theHandle,handleCurrentLength + numChars + 1);
+		
+		if (maxLength != nil)
+		{
+			*maxLength = GetHandleSize(theHandle);
+			
+			handleMaxLength = *maxLength;
+		}
+		
+		else
+		{
+			handleMaxLength = GetHandleSize(theHandle);
+		}
+
+		if (byteCount > handleMaxLength)
+		{
+			SetErrorMessageAndLongIntAndBail("AppendCharsToHandle: Can't increase Handle allocation, MemError() = ",MemError());
+		}
+	}
+	
+	
+	BlockMove(theChars,*theHandle + handleCurrentLength,numChars);
+	
+	(*theHandle)[handleCurrentLength + numChars] = '\0';
+	
+	if (currentLength != nil)
+	{
+		*currentLength += numChars;
+	}
+
+
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr AppendLongIntToHandle(const long inTheLongInt,Handle theHandle,long *currentLength)
+{
+OSErr		errCode = noErr;
+char		tempString[32];
+	
+	
+	CopyLongIntToCStr(inTheLongInt,tempString,sizeof(tempString));
+	
+	errCode = AppendCStrToHandle(tempString,theHandle,currentLength);
+
+	return(errCode);
+}
+
+
+
+
+long CStrLength(const char *theCString)
+{
+long	cStrLength = 0;
+
+	
+	if (theCString != nil)
+	{
+		for (cStrLength = 0;theCString[cStrLength] != 0;cStrLength++)
+		{
+		
+		}
+	}
+	
+	
+	return(cStrLength);
+}
+
+
+
+long PStrLength(const unsigned char *thePString)
+{
+long	pStrLength = 0;
+
+	
+	if (thePString != nil)
+	{
+		pStrLength = thePString[0];
+	}
+	
+	
+	return(pStrLength);
+}
+
+
+
+
+
+void ZeroMem(void *theMemPtr,const unsigned long numBytes)
+{
+unsigned char	*theBytePtr;
+unsigned long	*theLongPtr;
+unsigned long	numSingleBytes;
+unsigned long	theNumBytes;
+
+	
+	theNumBytes = numBytes;
+	
+	if (theMemPtr != nil && theNumBytes > 0)
+	{
+		theBytePtr = (unsigned char	*) theMemPtr;
+		
+		numSingleBytes = (unsigned long) theBytePtr & 0x0003;
+		
+		while (numSingleBytes > 0)
+		{
+			*theBytePtr++ = 0;
+			
+			theNumBytes--;
+			numSingleBytes--;
+		}
+		
+
+		theLongPtr = (unsigned long	*) theBytePtr;
+		
+		while (theNumBytes >= 4)
+		{
+			*theLongPtr++ = 0;
+			
+			theNumBytes -= 4;
+		}
+		
+		
+		theBytePtr = (unsigned char	*) theLongPtr;
+		
+		while (theNumBytes > 0)
+		{
+			*theBytePtr++ = 0;
+			
+			theNumBytes--;
+		}
+	}
+}
+
+
+
+
+char *FindCharInCStr(const char theChar,const char *theCString)
+{
+char	*theStringSearchPtr;
+
+	
+	theStringSearchPtr = (char	*) theCString;
+	
+	if (theStringSearchPtr != nil)
+	{
+		while (*theStringSearchPtr != '\0' && *theStringSearchPtr != theChar)
+		{
+			theStringSearchPtr++;
+		}
+		
+		if (*theStringSearchPtr == '\0')
+		{
+			theStringSearchPtr = nil;
+		}
+	}
+	
+	return(theStringSearchPtr);
+}
+
+
+
+long FindCharOffsetInCStr(const char theChar,const char *theCString,const Boolean inIgnoreCase)
+{
+long	theOffset = -1;
+
+
+	if (theCString != nil)
+	{
+		theOffset = 0;
+		
+
+		if (inIgnoreCase)
+		{
+		char	searchChar = theChar;
+		
+			if (searchChar >= 'a' && searchChar <= 'z')
+			{
+				searchChar = searchChar - 'a' + 'A';
+			}
+			
+			
+			while (*theCString != 0)
+			{
+			char	currentChar = *theCString;
+			
+				if (currentChar >= 'a' && currentChar <= 'z')
+				{
+					currentChar = currentChar - 'a' + 'A';
+				}
+			
+				if (currentChar == searchChar)
+				{
+					break;
+				}
+				
+				theCString++;
+				theOffset++;
+			}
+		}
+		
+		else
+		{
+			while (*theCString != 0 && *theCString != theChar)
+			{
+				theCString++;
+				theOffset++;
+			}
+		}
+		
+		if (*theCString == 0)
+		{
+			theOffset = -1;
+		}
+	}
+	
+	return(theOffset);
+}
+
+
+long FindCStrOffsetInCStr(const char *theCSubstring,const char *theCString,const Boolean inIgnoreCase)
+{
+long	theOffset = -1;
+
+
+	if (theCSubstring != nil && theCString != nil)
+	{
+		for (theOffset = 0;;theOffset++)
+		{
+			if (theCString[theOffset] == 0)
+			{
+				theOffset = -1;
+				
+				goto EXITPOINT;
+			}
+			
+			
+			for (const char	*tempSubstringPtr = theCSubstring,*tempCStringPtr = theCString + theOffset;;tempSubstringPtr++,tempCStringPtr++)
+			{
+				if (*tempSubstringPtr == 0)
+				{
+					goto EXITPOINT;
+				}
+				
+				else if (*tempCStringPtr == 0)
+				{
+					break;
+				}
+			
+			char	searchChar = *tempSubstringPtr;
+			char	currentChar = *tempCStringPtr;
+			
+				if (inIgnoreCase && searchChar >= 'a' && searchChar <= 'z')
+				{
+					searchChar = searchChar - 'a' + 'A';
+				}
+				
+				if (inIgnoreCase && currentChar >= 'a' && currentChar <= 'z')
+				{
+					currentChar = currentChar - 'a' + 'A';
+				}
+				
+				if (currentChar != searchChar)
+				{
+					break;
+				}
+			}
+		}
+		
+		theOffset = -1;
+	}
+
+
+EXITPOINT:
+	
+	return(theOffset);
+}
+
+
+
+void InsertCStrIntoCStr(const char *theSrcCStr,const int theInsertionOffset,char *theDstCStr,const int maxDstStrLength)
+{
+int		currentLength;
+int		insertLength;
+int		numCharsToInsert;
+int		numCharsToShift;
+
+	
+	if (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0 && theInsertionOffset < maxDstStrLength - 1)
+	{
+		currentLength = CStrLength(theDstCStr);
+		
+		insertLength = CStrLength(theSrcCStr);
+		
+
+		if (theInsertionOffset + insertLength < maxDstStrLength - 1)
+		{
+			numCharsToInsert = insertLength;
+		}
+		
+		else
+		{
+			numCharsToInsert = maxDstStrLength - 1 - theInsertionOffset;
+		}
+		
+
+		if (numCharsToInsert + currentLength < maxDstStrLength - 1)
+		{
+			numCharsToShift = currentLength - theInsertionOffset;
+		}
+		
+		else
+		{
+			numCharsToShift = maxDstStrLength - 1 - theInsertionOffset - numCharsToInsert;
+		}
+
+		
+		if (numCharsToShift > 0)
+		{
+			BlockMove(theDstCStr + theInsertionOffset,theDstCStr + theInsertionOffset + numCharsToInsert,numCharsToShift);
+		}
+		
+		if (numCharsToInsert > 0)
+		{
+			BlockMove(theSrcCStr,theDstCStr + theInsertionOffset,numCharsToInsert);
+		}
+		
+		theDstCStr[theInsertionOffset + numCharsToInsert + numCharsToShift] = 0;
+	}
+}
+
+
+
+void InsertPStrIntoCStr(const unsigned char *theSrcPStr,const int theInsertionOffset,char *theDstCStr,const int maxDstStrLength)
+{
+int		currentLength;
+int		insertLength;
+int		numCharsToInsert;
+int		numCharsToShift;
+
+	
+	if (theDstCStr != nil && theSrcPStr != nil && maxDstStrLength > 0 && theInsertionOffset < maxDstStrLength - 1)
+	{
+		currentLength = CStrLength(theDstCStr);
+		
+		insertLength = PStrLength(theSrcPStr);
+		
+
+		if (theInsertionOffset + insertLength < maxDstStrLength - 1)
+		{
+			numCharsToInsert = insertLength;
+		}
+		
+		else
+		{
+			numCharsToInsert = maxDstStrLength - 1 - theInsertionOffset;
+		}
+		
+
+		if (numCharsToInsert + currentLength < maxDstStrLength - 1)
+		{
+			numCharsToShift = currentLength - theInsertionOffset;
+		}
+		
+		else
+		{
+			numCharsToShift = maxDstStrLength - 1 - theInsertionOffset - numCharsToInsert;
+		}
+
+		
+		if (numCharsToShift > 0)
+		{
+			BlockMove(theDstCStr + theInsertionOffset,theDstCStr + theInsertionOffset + numCharsToInsert,numCharsToShift);
+		}
+		
+		if (numCharsToInsert > 0)
+		{
+			BlockMove(theSrcPStr + 1,theDstCStr + theInsertionOffset,numCharsToInsert);
+		}
+		
+		theDstCStr[theInsertionOffset + numCharsToInsert + numCharsToShift] = 0;
+	}
+}
+
+
+
+OSErr InsertCStrIntoHandle(const char *theCString,Handle theHandle,const long inInsertOffset)
+{
+OSErr	errCode;
+int		currentLength;
+int		insertLength;
+
+	
+	SetErrorMessageAndBailIfNil(theCString,"InsertCStrIntoHandle: Bad parameter, theCString == nil");
+
+	SetErrorMessageAndBailIfNil(theHandle,"InsertCStrIntoHandle: Bad parameter, theHandle == nil");
+	
+	currentLength = CStrLength(*theHandle);
+	
+	if (currentLength + 1 > ::GetHandleSize(theHandle))
+	{
+		SetErrorMessageAndBail("InsertCStrIntoHandle: Handle has been overflowed");
+	}
+	
+	if (inInsertOffset > currentLength)
+	{
+		SetErrorMessageAndBail("InsertCStrIntoHandle: Insertion offset is greater than string length");
+	}
+	
+	insertLength = CStrLength(theCString);
+	
+	::SetHandleSize(theHandle,currentLength + 1 + insertLength);
+	
+	if (::GetHandleSize(theHandle) < currentLength + 1 + insertLength)
+	{
+		SetErrorMessageAndLongIntAndBail("InsertCStrIntoHandle: Can't expand storage for Handle, MemError() = ",MemError());
+	}
+	
+	::BlockMove(*theHandle + inInsertOffset,*theHandle + inInsertOffset + insertLength,currentLength - inInsertOffset + 1);
+	
+	::BlockMove(theCString,*theHandle + inInsertOffset,insertLength);
+
+
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+
+void CopyCStrAndInsert1LongIntIntoCStr(const char *theSrcCStr,const long theNum,char *theDstCStr,const int maxDstStrLength)
+{
+	CopyCStrAndInsertCStrLongIntIntoCStr(theSrcCStr,nil,theNum,theDstCStr,maxDstStrLength);
+}
+
+
+void CopyCStrAndInsert2LongIntsIntoCStr(const char *theSrcCStr,const long long1,const long long2,char *theDstCStr,const int maxDstStrLength)
+{
+const long	theLongInts[] = { long1,long2 };
+
+	CopyCStrAndInsertCStrsLongIntsIntoCStr(theSrcCStr,nil,theLongInts,theDstCStr,maxDstStrLength);
+}
+
+
+void CopyCStrAndInsert3LongIntsIntoCStr(const char *theSrcCStr,const long long1,const long long2,const long long3,char *theDstCStr,const int maxDstStrLength)
+{
+const long	theLongInts[] = { long1,long2,long3 };
+
+	CopyCStrAndInsertCStrsLongIntsIntoCStr(theSrcCStr,nil,theLongInts,theDstCStr,maxDstStrLength);
+}
+
+
+void CopyCStrAndInsertCStrIntoCStr(const char *theSrcCStr,const char *theInsertCStr,char *theDstCStr,const int maxDstStrLength)
+{
+const char	*theCStrs[2] = { theInsertCStr,nil };
+
+	CopyCStrAndInsertCStrsLongIntsIntoCStr(theSrcCStr,theCStrs,nil,theDstCStr,maxDstStrLength);
+}
+
+
+
+void CopyCStrAndInsertCStrLongIntIntoCStr(const char *theSrcCStr,const char *theInsertCStr,const long theNum,char *theDstCStr,const int maxDstStrLength)
+{
+const char	*theCStrs[2] = { theInsertCStr,nil };
+const long	theLongInts[1] = { theNum };
+
+	CopyCStrAndInsertCStrsLongIntsIntoCStr(theSrcCStr,theCStrs,theLongInts,theDstCStr,maxDstStrLength);
+}
+
+
+
+void CopyCStrAndInsertCStrsLongIntsIntoCStr(const char *theSrcCStr,const char **theInsertCStrs,const long *theLongInts,char *theDstCStr,const int maxDstStrLength)
+{
+int			dstCharIndex,srcCharIndex,theMaxDstStrLength;
+int			theCStrIndex = 0;
+int			theLongIntIndex = 0;
+
+	
+	theMaxDstStrLength = maxDstStrLength;
+	
+	if (theDstCStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
+	{
+		dstCharIndex = 0;
+		
+		srcCharIndex = 0;
+		
+		
+		//	Allow room for NULL at end of string
+		
+		theMaxDstStrLength--;
+		
+		
+		for (;;)
+		{
+			//	Hit end of buffer?
+			
+			if (dstCharIndex >= theMaxDstStrLength)
+			{
+				theDstCStr[dstCharIndex++] = 0;
+				
+				goto EXITPOINT;
+			}
+			
+			//	End of source string?
+			
+			else if (theSrcCStr[srcCharIndex] == 0)
+			{
+				theDstCStr[dstCharIndex++] = 0;
+				
+				goto EXITPOINT;
+			}
+			
+			//	Did we find a '%s'?
+			
+			else if (theInsertCStrs != nil && theInsertCStrs[theCStrIndex] != nil && theSrcCStr[srcCharIndex] == '%' && theSrcCStr[srcCharIndex + 1] == 's')
+			{
+				//	Skip over the '%s'
+				
+				srcCharIndex += 2;
+				
+				
+				//	Terminate the dest string and then concat the string
+				
+				theDstCStr[dstCharIndex] = 0;
+				
+				ConcatCStrToCStr(theInsertCStrs[theCStrIndex],theDstCStr,theMaxDstStrLength);
+				
+				dstCharIndex = CStrLength(theDstCStr);
+				
+				theCStrIndex++;
+			}
+			
+			//	Did we find a '%ld'?
+			
+			else if (theLongInts != nil && theSrcCStr[srcCharIndex] == '%' && theSrcCStr[srcCharIndex + 1] == 'l' && theSrcCStr[srcCharIndex + 2] == 'd')
+			{
+				//	Skip over the '%ld'
+				
+				srcCharIndex += 3;
+				
+				
+				//	Terminate the dest string and then concat the number
+				
+				theDstCStr[dstCharIndex] = 0;
+				
+				ConcatLongIntToCStr(theLongInts[theLongIntIndex],theDstCStr,theMaxDstStrLength);
+				
+				theLongIntIndex++;
+				
+				dstCharIndex = CStrLength(theDstCStr);
+			}
+			
+			else
+			{
+				theDstCStr[dstCharIndex++] = theSrcCStr[srcCharIndex++];
+			}
+		}
+	}
+
+
+
+EXITPOINT:
+
+	return;
+}
+
+
+
+
+
+OSErr CopyCStrAndInsertCStrLongIntIntoHandle(const char *theSrcCStr,const char *theInsertCStr,const long theNum,Handle *theHandle)
+{
+OSErr	errCode;
+long	byteCount;
+
+	
+	if (theHandle != nil)
+	{
+		byteCount = CStrLength(theSrcCStr) + CStrLength(theInsertCStr) + 32;
+		
+		*theHandle = NewHandle(byteCount);
+		
+		if (*theHandle == nil)
+		{
+			SetErrorMessageAndLongIntAndBail("CopyCStrAndInsertCStrLongIntIntoHandle: Can't allocate Handle, MemError() = ",MemError());
+		}
+		
+		
+		HLock(*theHandle);
+		
+		CopyCStrAndInsertCStrLongIntIntoCStr(theSrcCStr,theInsertCStr,theNum,**theHandle,byteCount);
+		
+		HUnlock(*theHandle);
+	}
+	
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+
+
+OSErr CopyIndexedWordToCStr(char *theSrcCStr,int whichWord,char *theDstCStr,int maxDstCStrLength)
+{
+OSErr		errCode;
+char		*srcCharPtr,*dstCharPtr;
+int			wordCount;
+int			byteCount;
+
+
+	if (theSrcCStr == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToCStr: Bad parameter, theSrcCStr == nil"));
+	}
+	
+	if (theDstCStr == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToCStr: Bad parameter, theDstCStr == nil"));
+	}
+	
+	if (whichWord < 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToCStr: Bad parameter, whichWord < 0"));
+	}
+	
+	if (maxDstCStrLength <= 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToCStr: Bad parameter, maxDstCStrLength <= 0"));
+	}
+
+	
+	*theDstCStr = '\0';
+	
+	srcCharPtr = theSrcCStr;
+
+	while (*srcCharPtr == ' ' || *srcCharPtr == '\t')
+	{
+		srcCharPtr++;
+	}
+	
+
+	for (wordCount = 0;wordCount < whichWord;wordCount++)
+	{
+		while (*srcCharPtr != ' ' && *srcCharPtr != '\t' && *srcCharPtr != '\r' && *srcCharPtr != '\n' && *srcCharPtr != '\0')
+		{
+			srcCharPtr++;
+		}
+		
+		if (*srcCharPtr == '\r' || *srcCharPtr == '\n' || *srcCharPtr == '\0')
+		{
+			errCode = noErr;
+			
+			goto EXITPOINT;
+		}
+
+		while (*srcCharPtr == ' ' || *srcCharPtr == '\t')
+		{
+			srcCharPtr++;
+		}
+		
+		if (*srcCharPtr == '\r' || *srcCharPtr == '\n' || *srcCharPtr == '\0')
+		{
+			errCode = noErr;
+			
+			goto EXITPOINT;
+		}
+	}
+
+
+	dstCharPtr = theDstCStr;
+	byteCount = 0;
+	
+	
+	for(;;)
+	{
+		if (byteCount >= maxDstCStrLength - 1 || *srcCharPtr == '\0' || *srcCharPtr == ' ' || *srcCharPtr == '\t' || *srcCharPtr == '\r' || *srcCharPtr == '\n')
+		{
+			*dstCharPtr = '\0';
+			break;
+		}
+		
+		*dstCharPtr++ = *srcCharPtr++;
+		
+		byteCount++;
+	}
+
+
+	errCode = noErr;
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+
+
+OSErr CopyIndexedWordToNewHandle(char *theSrcCStr,int whichWord,Handle *outTheHandle)
+{
+OSErr		errCode;
+char		*srcCharPtr;
+int			wordCount;
+int			byteCount;
+
+
+	if (theSrcCStr == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToNewHandle: Bad parameter, theSrcCStr == nil"));
+	}
+	
+	if (outTheHandle == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToNewHandle: Bad parameter, outTheHandle == nil"));
+	}
+	
+	if (whichWord < 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedWordToNewHandle: Bad parameter, whichWord < 0"));
+	}
+
+	
+	*outTheHandle = nil;
+	
+
+	srcCharPtr = theSrcCStr;
+
+	while (*srcCharPtr == ' ' || *srcCharPtr == '\t')
+	{
+		srcCharPtr++;
+	}
+	
+
+	for (wordCount = 0;wordCount < whichWord;wordCount++)
+	{
+		while (*srcCharPtr != ' ' && *srcCharPtr != '\t' && *srcCharPtr != '\r' && *srcCharPtr != '\n' && *srcCharPtr != '\0')
+		{
+			srcCharPtr++;
+		}
+		
+		if (*srcCharPtr == '\r' || *srcCharPtr == '\n' || *srcCharPtr == '\0')
+		{
+			break;
+		}
+
+		while (*srcCharPtr == ' ' || *srcCharPtr == '\t')
+		{
+			srcCharPtr++;
+		}
+		
+		if (*srcCharPtr == '\r' || *srcCharPtr == '\n' || *srcCharPtr == '\0')
+		{
+			break;
+		}
+	}
+
+
+	for (byteCount = 0;;byteCount++)
+	{
+		if (srcCharPtr[byteCount] == ' ' || srcCharPtr[byteCount] == '\t' || srcCharPtr[byteCount] == '\r' || srcCharPtr[byteCount] == '\n' || srcCharPtr[byteCount] == '\0')
+		{
+			break;
+		}
+	}
+
+	
+	*outTheHandle = NewHandle(byteCount + 1);
+	
+	if (*outTheHandle == nil)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyIndexedWordToNewHandle: Can't allocate Handle, MemError() = ",MemError());
+	}
+	
+	
+	::BlockMove(srcCharPtr,**outTheHandle,byteCount);
+	
+	(**outTheHandle)[byteCount] = '\0';
+
+	errCode = noErr;
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr CopyIndexedLineToCStr(const char *theSrcCStr,int inWhichLine,int *lineEndIndex,Boolean *gotLastLine,char *theDstCStr,const int maxDstCStrLength)
+{
+OSErr		errCode;
+int			theCurrentLine;
+int			theCurrentLineOffset;
+int			theEOSOffset;
+
+
+	if (theSrcCStr == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedLineToCStr: Bad parameter, theSrcCStr == nil"));
+	}
+	
+	if (theDstCStr == nil)
+	{
+		SetErrorMessageAndBail(("CopyIndexedLineToCStr: Bad parameter, theDstCStr == nil"));
+	}
+	
+	if (inWhichLine < 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedLineToCStr: Bad parameter, inWhichLine < 0"));
+	}
+	
+	if (maxDstCStrLength <= 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedLineToCStr: Bad parameter, maxDstCStrLength <= 0"));
+	}
+	
+	
+	if (gotLastLine != nil)
+	{
+		*gotLastLine = false;
+	}
+
+	
+	*theDstCStr = 0;
+	
+	theCurrentLineOffset = 0;
+	
+	theCurrentLine = 0;
+	
+	
+	while (theCurrentLine < inWhichLine)
+	{
+		while (theSrcCStr[theCurrentLineOffset] != '\r' && theSrcCStr[theCurrentLineOffset] != 0)
+		{
+			theCurrentLineOffset++;
+		}
+		
+		if (theSrcCStr[theCurrentLineOffset] == 0)
+		{
+			break;
+		}
+		
+		theCurrentLineOffset++;
+		theCurrentLine++;
+	}
+		
+	if (theSrcCStr[theCurrentLineOffset] == 0)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyIndexedLineToCStr: Too few lines in source text, can't get line ",inWhichLine);
+	}
+
+
+	theEOSOffset = FindCharOffsetInCStr('\r',theSrcCStr + theCurrentLineOffset);
+	
+	if (theEOSOffset >= 0)
+	{
+		CopyCSubstrToCStr(theSrcCStr + theCurrentLineOffset,theEOSOffset,theDstCStr,maxDstCStrLength);
+		
+		if (gotLastLine != nil)
+		{
+			*gotLastLine = false;
+		}
+	
+		if (lineEndIndex != nil)
+		{
+			*lineEndIndex = theEOSOffset;
+		}
+	}
+	
+	else
+	{
+		theEOSOffset = CStrLength(theSrcCStr + theCurrentLineOffset);
+
+		CopyCSubstrToCStr(theSrcCStr + theCurrentLineOffset,theEOSOffset,theDstCStr,maxDstCStrLength);
+		
+		if (gotLastLine != nil)
+		{
+			*gotLastLine = true;
+		}
+	
+		if (lineEndIndex != nil)
+		{
+			*lineEndIndex = theEOSOffset;
+		}
+	}
+	
+
+	errCode = noErr;
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr CopyIndexedLineToNewHandle(const char *theSrcCStr,int inWhichLine,Handle *outNewHandle)
+{
+OSErr		errCode;
+int			theCurrentLine;
+int			theCurrentLineOffset;
+int			byteCount;
+
+
+	SetErrorMessageAndBailIfNil(theSrcCStr,"CopyIndexedLineToNewHandle: Bad parameter, theSrcCStr == nil");
+	SetErrorMessageAndBailIfNil(outNewHandle,"CopyIndexedLineToNewHandle: Bad parameter, outNewHandle == nil");
+	
+	if (inWhichLine < 0)
+	{
+		SetErrorMessageAndBail(("CopyIndexedLineToNewHandle: Bad parameter, inWhichLine < 0"));
+	}
+	
+
+	theCurrentLineOffset = 0;
+	
+	theCurrentLine = 0;
+	
+	
+	while (theCurrentLine < inWhichLine)
+	{
+		while (theSrcCStr[theCurrentLineOffset] != '\r' && theSrcCStr[theCurrentLineOffset] != '\0')
+		{
+			theCurrentLineOffset++;
+		}
+		
+		if (theSrcCStr[theCurrentLineOffset] == '\0')
+		{
+			break;
+		}
+		
+		theCurrentLineOffset++;
+		theCurrentLine++;
+	}
+		
+	if (theSrcCStr[theCurrentLineOffset] == '\0')
+	{
+		SetErrorMessageAndLongIntAndBail("CopyIndexedLineToNewHandle: Too few lines in source text, can't get line #",inWhichLine);
+	}
+
+	
+	byteCount = 0;
+	
+	while (theSrcCStr[theCurrentLineOffset + byteCount] != '\r' && theSrcCStr[theCurrentLineOffset + byteCount] != '\0')
+	{
+		byteCount++;
+	}
+		
+	
+	*outNewHandle = NewHandle(byteCount + 1);
+	
+	if (*outNewHandle == nil)
+	{
+		SetErrorMessageAndLongIntAndBail("CopyIndexedLineToNewHandle: Can't allocate Handle, MemError() = ",MemError());
+	}
+	
+	::BlockMove(theSrcCStr + theCurrentLineOffset,**outNewHandle,byteCount);
+	
+	(**outNewHandle)[byteCount] = '\0';
+
+	errCode = noErr;
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+
+OSErr CountDigits(const char *inCStr,int *outNumIntegerDigits,int *outNumFractDigits)
+{
+OSErr	errCode = noErr;
+int		numIntDigits = 0;
+int		numFractDigits = 0;
+int 	digitIndex = 0;
+
+	
+	SetErrorMessageAndBailIfNil(inCStr,"CountDigits: Bad parameter, theSrcCStr == nil");
+	SetErrorMessageAndBailIfNil(outNumIntegerDigits,"CountDigits: Bad parameter, outNumIntegerDigits == nil");
+	SetErrorMessageAndBailIfNil(outNumFractDigits,"CountDigits: Bad parameter, outNumFractDigits == nil");
+	
+	digitIndex = 0;
+	
+	while (inCStr[digitIndex] >= '0' && inCStr[digitIndex] <= '9')
+	{
+		digitIndex++;
+		numIntDigits++;
+	}
+	
+	if (inCStr[digitIndex] == '.')
+	{
+		digitIndex++;
+		
+		while (inCStr[digitIndex] >= '0' && inCStr[digitIndex] <= '9')
+		{
+			digitIndex++;
+			numFractDigits++;
+		}
+	}
+	
+	*outNumIntegerDigits = numIntDigits;
+	
+	*outNumFractDigits = numFractDigits;
+	
+	errCode = noErr;
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr ExtractIntFromCStr(const char *theSrcCStr,int *outInt,Boolean skipLeadingSpaces)
+{
+OSErr		errCode;
+int			theCharIndex;
+
+
+	if (theSrcCStr == nil)
+	{
+		SetErrorMessageAndBail(("ExtractIntFromCStr: Bad parameter, theSrcCStr == nil"));
+	}
+	
+	if (outInt == nil)
+	{
+		SetErrorMessageAndBail(("ExtractIntFromCStr: Bad parameter, outInt == nil"));
+	}	
+
+	
+	*outInt = 0;
+	
+	theCharIndex = 0;
+	
+	if (skipLeadingSpaces == true)
+	{
+		while (theSrcCStr[theCharIndex] == ' ')
+		{
+			theCharIndex++;
+		}
+	}
+	
+	if (theSrcCStr[theCharIndex] < '0' || theSrcCStr[theCharIndex] > '9')
+	{
+		SetErrorMessageAndBail(("ExtractIntFromCStr: Bad parameter, theSrcCStr contains a bogus numeric representation"));
+	}
+
+
+	while (theSrcCStr[theCharIndex] >= '0' && theSrcCStr[theCharIndex] <= '9')
+	{
+		*outInt = (*outInt * 10) + (theSrcCStr[theCharIndex] - '0');
+		
+		theCharIndex++;
+	}
+	
+
+	errCode = noErr;
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+OSErr ExtractIntFromPStr(const unsigned char *theSrcPStr,int *outInt,Boolean skipLeadingSpaces)
+{
+OSErr		errCode;
+char		theCStr[256];
+
+
+	if (theSrcPStr == nil)
+	{
+		SetErrorMessageAndBail(("ExtractIntFromPStr: Bad parameter, theSrcPStr == nil"));
+	}
+	
+	if (outInt == nil)
+	{
+		SetErrorMessageAndBail(("ExtractIntFromPStr: Bad parameter, outInt == nil"));
+	}
+	
+	
+	CopyPStrToCStr(theSrcPStr,theCStr,sizeof(theCStr));
+	
+	
+	errCode = ExtractIntFromCStr(theCStr,outInt,skipLeadingSpaces);
+
+
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+int CountOccurencesOfCharInCStr(const char inChar,const char *inSrcCStr)
+{
+int		theSrcCharIndex;
+int		numOccurrences = -1;
+
+
+	if (inSrcCStr != nil && inChar != '\0')
+	{
+		numOccurrences = 0;
+		
+		for (theSrcCharIndex = 0;inSrcCStr[theSrcCharIndex] != '\0';theSrcCharIndex++)
+		{
+			if (inSrcCStr[theSrcCharIndex] == inChar)
+			{
+				numOccurrences++;
+			}
+		}
+	}
+	
+	return(numOccurrences);
+}
+
+
+int CountWordsInCStr(const char *inSrcCStr)
+{
+int		numWords = -1;
+
+
+	if (inSrcCStr != nil)
+	{
+		numWords = 0;
+		
+		//	Skip lead spaces
+		
+		while (*inSrcCStr == ' ')
+		{
+			inSrcCStr++;
+		}
+
+		while (*inSrcCStr != '\0')
+		{
+			numWords++;
+
+			while (*inSrcCStr != ' ' && *inSrcCStr != '\0')
+			{
+				inSrcCStr++;
+			}
+			
+			while (*inSrcCStr == ' ')
+			{
+				inSrcCStr++;
+			}
+		}
+	}
+	
+	return(numWords);
+}
+
+
+
+
+void ConvertCStrToUpperCase(char *theSrcCStr)
+{
+char		*theCharPtr;
+
+
+	if (theSrcCStr != nil)
+	{
+		theCharPtr = theSrcCStr;
+		
+		while (*theCharPtr != 0)
+		{
+			if (*theCharPtr >= 'a' && *theCharPtr <= 'z')
+			{
+				*theCharPtr = *theCharPtr - 'a' + 'A';
+			}
+			
+			theCharPtr++;
+		}
+	}
+}
+
+
+
+
+
+
+
+void ExtractCStrItemFromCStr(const char *inSrcCStr,const char inItemDelimiter,const int inItemNumber,Boolean *foundItem,char *outDstCharPtr,const int inDstCharPtrMaxLength,const Boolean inTreatMultipleDelimsAsSingleDelim)
+{
+int		theItem;
+int		theSrcCharIndex;
+int		theDstCharIndex;
+
+
+	if (foundItem != nil)
+	{
+		*foundItem = false;
+	}
+	
+	
+	if (outDstCharPtr != nil && inDstCharPtrMaxLength > 0 && inItemNumber >= 0 && inItemDelimiter != 0)
+	{
+		*outDstCharPtr = 0;
+		
+
+		theSrcCharIndex = 0;
+		
+		for (theItem = 0;theItem < inItemNumber;theItem++)
+		{
+			while (inSrcCStr[theSrcCharIndex] != inItemDelimiter && inSrcCStr[theSrcCharIndex] != '\0')
+			{
+				theSrcCharIndex++;
+			}
+			
+			if (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
+			{
+				theSrcCharIndex++;
+				
+				if (inTreatMultipleDelimsAsSingleDelim)
+				{
+					while (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
+					{
+						theSrcCharIndex++;
+					}
+				}
+			}
+			
+			
+			if (inSrcCStr[theSrcCharIndex] == '\0')
+			{
+				goto EXITPOINT;
+			}
+		}
+		
+
+		if (foundItem != nil)
+		{
+			*foundItem = true;
+		}
+		
+		
+		theDstCharIndex = 0;
+		
+		for (;;)
+		{
+			if (inSrcCStr[theSrcCharIndex] == 0 || inSrcCStr[theSrcCharIndex] == inItemDelimiter || theDstCharIndex >= inDstCharPtrMaxLength - 1)
+			{
+				outDstCharPtr[theDstCharIndex] = 0;
+				
+				break;
+			}
+			
+			outDstCharPtr[theDstCharIndex++] = inSrcCStr[theSrcCharIndex++];
+		}
+	}
+	
+	
+EXITPOINT:
+
+	return;
+}
+
+
+
+OSErr ExtractCStrItemFromCStrIntoNewHandle(const char *inSrcCStr,const char inItemDelimiter,const int inItemNumber,Boolean *foundItem,Handle *outNewHandle,const Boolean inTreatMultipleDelimsAsSingleDelim)
+{
+OSErr	errCode;
+int		theItem;
+int		theSrcCharIndex;
+int		theItemLength;
+
+
+	if (inSrcCStr == nil)
+	{
+		SetErrorMessage("ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, inSrcCStr == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (outNewHandle == nil)
+	{
+		SetErrorMessage("ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, outNewHandle == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (foundItem == nil)
+	{
+		SetErrorMessage("ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, foundItem == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (inItemNumber < 0)
+	{
+		SetErrorMessage("ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, inItemNumber < 0");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (inItemDelimiter == 0)
+	{
+		SetErrorMessage("ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, inItemDelimiter == 0");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+
+	*foundItem = false;
+	
+	theSrcCharIndex = 0;
+	
+	for (theItem = 0;theItem < inItemNumber;theItem++)
+	{
+		while (inSrcCStr[theSrcCharIndex] != inItemDelimiter && inSrcCStr[theSrcCharIndex] != '\0')
+		{
+			theSrcCharIndex++;
+		}
+		
+		if (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
+		{
+			theSrcCharIndex++;
+			
+			if (inTreatMultipleDelimsAsSingleDelim)
+			{
+				while (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
+				{
+					theSrcCharIndex++;
+				}
+			}
+		}
+		
+		
+		if (inSrcCStr[theSrcCharIndex] == '\0')
+		{
+			errCode = noErr;
+			
+			goto EXITPOINT;
+		}
+	}
+	
+
+	*foundItem = true;
+	
+	
+	for (theItemLength = 0;;theItemLength++)
+	{
+		if (inSrcCStr[theSrcCharIndex + theItemLength] == 0 || inSrcCStr[theSrcCharIndex + theItemLength] == inItemDelimiter)
+		{
+			break;
+		}
+	}
+	
+
+	*outNewHandle = NewHandle(theItemLength + 1);
+	
+	if (*outNewHandle == nil)
+	{
+		SetErrorMessageAndLongIntAndBail("ExtractCStrItemFromCStrIntoNewHandle: Can't allocate Handle, MemError() = ",MemError());
+	}
+	
+	
+	BlockMove(inSrcCStr + theSrcCharIndex,**outNewHandle,theItemLength);
+	
+	(**outNewHandle)[theItemLength] = 0;
+	
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	return(errCode);
+}
+
+
+
+
+
+
+OSErr ExtractFloatFromCStr(const char *inCString,extended80 *outFloat)
+{
+OSErr				errCode;
+Str255				theStr255;
+Handle				theNumberPartsTableHandle = nil;
+long				theNumberPartsOffset,theNumberPartsLength;
+FormatResultType	theFormatResultType;
+NumberParts			theNumberPartsTable;
+NumFormatStringRec	theNumFormatStringRec;
+
+
+	if (inCString == nil)
+	{
+		SetErrorMessage("ExtractFloatFromCStr: Bad parameter, inCString == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+	if (outFloat == nil)
+	{
+		SetErrorMessage("ExtractFloatFromCStr: Bad parameter, outFloat == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	
+//	GetIntlResourceTable(smRoman,smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);
+
+	GetIntlResourceTable(GetScriptManagerVariable(smSysScript),smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);	
+	
+	if (theNumberPartsTableHandle == nil)
+	{
+		SetErrorMessage("ExtractFloatFromCStr: Can't get number parts table for converting string representations to/from numeric representations");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (theNumberPartsLength > sizeof(theNumberPartsTable))
+	{
+		SetErrorMessage("ExtractFloatFromCStr: Number parts table has bad length");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+
+	BlockMove(*theNumberPartsTableHandle + theNumberPartsOffset,&theNumberPartsTable,theNumberPartsLength);
+	
+	
+	theFormatResultType = (FormatResultType) StringToFormatRec(kNumberFormatString,&theNumberPartsTable,&theNumFormatStringRec);
+	
+	if (theFormatResultType != fFormatOK)
+	{
+		SetErrorMessage("ExtractFloatFromCStr: StringToFormatRec() != fFormatOK");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+	
+	CopyCStrToPStr(inCString,theStr255,sizeof(theStr255));
+
+
+	theFormatResultType = (FormatResultType) StringToExtended(theStr255,&theNumFormatStringRec,&theNumberPartsTable,outFloat);
+	
+	if (theFormatResultType != fFormatOK && theFormatResultType != fBestGuess)
+	{
+		SetErrorMessageAndLongIntAndBail("ExtractFloatFromCStr: StringToExtended() = ",theFormatResultType);
+	}
+
+	
+	errCode = noErr;
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+
+OSErr CopyFloatToCStr(const extended80 *theFloat,char *theCStr,const int maxCStrLength,const int inMaxNumIntDigits,const int inMaxNumFractDigits)
+{
+OSErr				errCode;
+Str255				theStr255;
+Handle				theNumberPartsTableHandle = nil;
+long				theNumberPartsOffset,theNumberPartsLength;
+FormatResultType	theFormatResultType;
+NumberParts			theNumberPartsTable;
+NumFormatStringRec	theNumFormatStringRec;
+
+
+	if (theCStr == nil)
+	{
+		SetErrorMessage("CopyFloatToCStr: Bad parameter, theCStr == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+	if (theFloat == nil)
+	{
+		SetErrorMessage("CopyFloatToCStr: Bad parameter, theFloat == nil");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+
+//	GetIntlResourceTable(smRoman,smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);
+
+	GetIntlResourceTable(GetScriptManagerVariable(smSysScript),smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);	
+	
+	if (theNumberPartsTableHandle == nil)
+	{
+		SetErrorMessage("CopyFloatToCStr: Can't get number parts table for converting string representations to/from numeric representations");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	if (theNumberPartsLength > sizeof(theNumberPartsTable))
+	{
+		SetErrorMessage("CopyFloatToCStr: Number parts table has bad length");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+	
+	
+	BlockMove(*theNumberPartsTableHandle + theNumberPartsOffset,&theNumberPartsTable,theNumberPartsLength);
+	
+	
+	if (inMaxNumIntDigits >= 0 || inMaxNumFractDigits >= 0)
+	{
+	char	numberFormat[64];
+	int		numberFormatLength = 0;
+	
+		for (int i = 0;i < inMaxNumIntDigits && numberFormatLength < sizeof(numberFormat) - 1;i++)
+		{
+			numberFormat[numberFormatLength++] = '0';
+		}
+		
+		if (inMaxNumFractDigits > 0 && numberFormatLength < sizeof(numberFormat) - 1)
+		{
+			numberFormat[numberFormatLength++] = '.';
+			
+			for (int i = 0;i < inMaxNumFractDigits && numberFormatLength < sizeof(numberFormat) - 1;i++)
+			{
+				numberFormat[numberFormatLength++] = '0';
+			}
+		}
+
+		
+		if (numberFormatLength < sizeof(numberFormat) - 1)
+		{
+			numberFormat[numberFormatLength++] = ';';
+		}
+		
+		if (numberFormatLength < sizeof(numberFormat) - 1)
+		{
+			numberFormat[numberFormatLength++] = '-';
+		}
+		
+
+		for (int i = 0;i < inMaxNumIntDigits && numberFormatLength < sizeof(numberFormat) - 1;i++)
+		{
+			numberFormat[numberFormatLength++] = '0';
+		}
+		
+		if (inMaxNumFractDigits > 0 && numberFormatLength < sizeof(numberFormat) - 1)
+		{
+			numberFormat[numberFormatLength++] = '.';
+			
+			for (int i = 0;i < inMaxNumFractDigits && numberFormatLength < sizeof(numberFormat) - 1;i++)
+			{
+				numberFormat[numberFormatLength++] = '0';
+			}
+		}
+		
+		numberFormat[numberFormatLength] = '\0';
+
+
+	Str255	tempStr255;
+	
+		CopyCStrToPStr(numberFormat,tempStr255,sizeof(tempStr255));
+		
+		theFormatResultType = (FormatResultType) StringToFormatRec(tempStr255,&theNumberPartsTable,&theNumFormatStringRec);
+	}
+	
+	else
+	{
+		theFormatResultType = (FormatResultType) StringToFormatRec(kNumberFormatString,&theNumberPartsTable,&theNumFormatStringRec);
+	}
+	
+	if (theFormatResultType != fFormatOK)
+	{
+		SetErrorMessage("CopyFloatToCStr: StringToFormatRec() != fFormatOK");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+
+	theFormatResultType = (FormatResultType) ExtendedToString(theFloat,&theNumFormatStringRec,&theNumberPartsTable,theStr255);
+	
+	if (theFormatResultType != fFormatOK)
+	{
+		SetErrorMessage("CopyFloatToCStr: ExtendedToString() != fFormatOK");
+		errCode = kGenericError;
+		goto EXITPOINT;
+	}
+
+	
+	CopyPStrToCStr(theStr255,theCStr,maxCStrLength);
+	
+	errCode = noErr;
+	
+
+EXITPOINT:
+	
+	return(errCode);
+}
+
+
+
+
+
+void SkipWhiteSpace(char **ioSrcCharPtr,const Boolean inStopAtEOL)
+{
+	if (ioSrcCharPtr != nil && *ioSrcCharPtr != nil)
+	{
+		if (inStopAtEOL)
+		{
+			while ((**ioSrcCharPtr == ' ' || **ioSrcCharPtr == '\t') && **ioSrcCharPtr != '\r' && **ioSrcCharPtr != '\n')
+			{
+				*ioSrcCharPtr++;
+			}
+		}
+		
+		else
+		{
+			while (**ioSrcCharPtr == ' ' || **ioSrcCharPtr == '\t')
+			{
+				*ioSrcCharPtr++;
+			}
+		}
+	}
+}
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/CPStringUtils.hpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/CPStringUtils.hpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/CPStringUtils.hpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/CPStringUtils.hpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,104 @@
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void CopyPStrToCStr(const unsigned char *thePStr,char *theCStr,const int maxCStrLength);
+void CopyPStrToPStr(const unsigned char *theSrcPStr,unsigned char *theDstPStr,const int maxDstStrLength);
+void CopyCStrToCStr(const char *theSrcCStr,char *theDstCStr,const int maxDstStrLength);
+void CopyCStrToPStr(const char *theSrcCStr,unsigned char *theDstPStr,const int maxDstStrLength);
+void ConcatPStrToCStr(const unsigned char *thePStr,char *theCStr,const int maxCStrLength);
+void ConcatPStrToPStr(const unsigned char *theSrcPStr,unsigned char *theDstPStr,const int maxDstStrLength);
+void ConcatCStrToPStr(const char *theSrcCStr,unsigned char *theDstPStr,const int maxDstStrLength);
+void ConcatCStrToCStr(const char *theSrcCStr,char *theDstCStr,const int maxCStrLength);
+
+void ConcatCharToCStr(const char theChar,char *theDstCStr,const int maxCStrLength);
+void ConcatCharToPStr(const char theChar,unsigned char *theDstPStr,const int maxPStrLength);
+
+int ComparePStrs(const unsigned char *theFirstPStr,const unsigned char *theSecondPStr,const Boolean ignoreCase = true);
+int CompareCStrs(const char *theFirstCStr,const char *theSecondCStr,const Boolean ignoreCase = true);
+int CompareCStrToPStr(const char *theCStr,const unsigned char *thePStr,const Boolean ignoreCase = true);
+
+Boolean CStrsAreEqual(const char *theFirstCStr,const char *theSecondCStr,const Boolean ignoreCase = true);
+Boolean PStrsAreEqual(const unsigned char *theFirstCStr,const unsigned char *theSecondCStr,const Boolean ignoreCase = true);
+
+void CopyLongIntToCStr(const long theNum,char *theCStr,const int maxCStrLength,const int numDigits = -1);
+void CopyUnsignedLongIntToCStr(const unsigned long theNum,char *theCStr,const int maxCStrLength);
+void ConcatLongIntToCStr(const long theNum,char *theCStr,const int maxCStrLength,const int numDigits = -1);
+void CopyCStrAndConcatLongIntToCStr(const char *theSrcCStr,const long theNum,char *theDstCStr,const int maxDstStrLength);
+
+void CopyLongIntToPStr(const long theNum,unsigned char *thePStr,const int maxPStrLength,const int numDigits = -1);
+void ConcatLongIntToPStr(const long theNum,unsigned char *thePStr,const int maxPStrLength,const int numDigits = -1);
+
+long CStrLength(const char *theCString);
+long PStrLength(const unsigned char *thePString);
+
+OSErr CopyCStrToExistingHandle(const char *theCString,Handle theHandle);
+OSErr CopyLongIntToExistingHandle(const long inTheLongInt,Handle theHandle);
+
+OSErr CopyCStrToNewHandle(const char *theCString,Handle *theHandle);
+OSErr CopyPStrToNewHandle(const unsigned char *thePString,Handle *theHandle);
+OSErr CopyLongIntToNewHandle(const long inTheLongInt,Handle *theHandle);
+
+OSErr AppendCStrToHandle(const char *theCString,Handle theHandle,long *currentLength = nil,long *maxLength = nil);
+OSErr AppendCharsToHandle(const char *theChars,const int numChars,Handle theHandle,long *currentLength = nil,long *maxLength = nil);
+OSErr AppendPStrToHandle(const unsigned char *thePString,Handle theHandle,long *currentLength = nil);
+OSErr AppendLongIntToHandle(const long inTheLongInt,Handle theHandle,long *currentLength = nil);
+
+void ZeroMem(void *theMemPtr,const unsigned long numBytes);
+
+char *FindCharInCStr(const char theChar,const char *theCString);
+long FindCharOffsetInCStr(const char theChar,const char *theCString,const Boolean inIgnoreCase = false);
+long FindCStrOffsetInCStr(const char *theCSubstring,const char *theCString,const Boolean inIgnoreCase = false);
+
+void CopyCSubstrToCStr(const char *theSrcCStr,const int maxCharsToCopy,char *theDstCStr,const int maxDstStrLength);
+void CopyCSubstrToPStr(const char *theSrcCStr,const int maxCharsToCopy,unsigned char *theDstPStr,const int maxDstStrLength);
+
+void InsertCStrIntoCStr(const char *theSrcCStr,const int theInsertionOffset,char *theDstCStr,const int maxDstStrLength);
+void InsertPStrIntoCStr(const unsigned char *theSrcPStr,const int theInsertionOffset,char *theDstCStr,const int maxDstStrLength);
+OSErr InsertCStrIntoHandle(const char *theCString,Handle theHandle,const long inInsertOffset);
+
+void CopyCStrAndInsertCStrIntoCStr(const char *theSrcCStr,const char *theInsertCStr,char *theDstCStr,const int maxDstStrLength);
+
+void CopyCStrAndInsertCStrsLongIntsIntoCStr(const char *theSrcCStr,const char **theInsertCStrs,const long *theLongInts,char *theDstCStr,const int maxDstStrLength);
+
+void CopyCStrAndInsert1LongIntIntoCStr(const char *theSrcCStr,const long theNum,char *theDstCStr,const int maxDstStrLength);
+void CopyCStrAndInsert2LongIntsIntoCStr(const char *theSrcCStr,const long long1,const long long2,char *theDstCStr,const int maxDstStrLength);
+void CopyCStrAndInsert3LongIntsIntoCStr(const char *theSrcCStr,const long long1,const long long2,const long long3,char *theDstCStr,const int maxDstStrLength);
+
+void CopyCStrAndInsertCStrLongIntIntoCStr(const char *theSrcCStr,const char *theInsertCStr,const long theNum,char *theDstCStr,const int maxDstStrLength);
+OSErr CopyCStrAndInsertCStrLongIntIntoHandle(const char *theSrcCStr,const char *theInsertCStr,const long theNum,Handle *theHandle);
+
+
+OSErr CopyIndexedWordToCStr(char *theSrcCStr,int whichWord,char *theDstCStr,int maxDstCStrLength);
+OSErr CopyIndexedWordToNewHandle(char *theSrcCStr,int whichWord,Handle *outTheHandle);
+
+OSErr CopyIndexedLineToCStr(const char *theSrcCStr,int inWhichLine,int *lineEndIndex,Boolean *gotLastLine,char *theDstCStr,const int maxDstCStrLength);
+OSErr CopyIndexedLineToNewHandle(const char *theSrcCStr,int inWhichLine,Handle *outNewHandle);
+
+OSErr ExtractIntFromCStr(const char *theSrcCStr,int *outInt,Boolean skipLeadingSpaces = true);
+OSErr ExtractIntFromPStr(const unsigned char *theSrcPStr,int *outInt,Boolean skipLeadingSpaces = true);
+
+
+void ConvertCStrToUpperCase(char *theSrcCStr);
+
+
+int CountOccurencesOfCharInCStr(const char inChar,const char *inSrcCStr);
+int CountWordsInCStr(const char *inSrcCStr);
+
+OSErr CountDigits(const char *inCStr,int *outNumIntegerDigits,int *outNumFractDigits);
+
+void ExtractCStrItemFromCStr(const char *inSrcCStr,const char inItemDelimiter,const int inItemNumber,Boolean *foundItem,char *outDstCharPtr,const int inDstCharPtrMaxLength,const Boolean inTreatMultipleDelimsAsSingleDelim = false);
+OSErr ExtractCStrItemFromCStrIntoNewHandle(const char *inSrcCStr,const char inItemDelimiter,const int inItemNumber,Boolean *foundItem,Handle *outNewHandle,const Boolean inTreatMultipleDelimsAsSingleDelim = false);
+
+
+OSErr ExtractFloatFromCStr(const char *inCString,extended80 *outFloat);
+OSErr CopyFloatToCStr(const extended80 *theFloat,char *theCStr,const int maxCStrLength,const int inMaxNumIntDigits = -1,const int inMaxNumFractDigits = -1);
+
+void SkipWhiteSpace(char **ioSrcCharPtr,const Boolean inStopAtEOL = false);
+
+
+#ifdef __cplusplus
+}
+#endif
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/ErrorHandling.cpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/ErrorHandling.cpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/ErrorHandling.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/ErrorHandling.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,170 @@
+/* ====================================================================
+ * Copyright (c) 1998-1999 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+ 
+ 
+ 
+ #include "ErrorHandling.hpp"
+#include "CPStringUtils.hpp"
+
+#ifdef __EXCEPTIONS_ENABLED__
+	#include "CMyException.hpp"
+#endif
+
+
+static char					gErrorMessageBuffer[512];
+
+char 						*gErrorMessage = gErrorMessageBuffer;
+int							gErrorMessageMaxLength = sizeof(gErrorMessageBuffer);
+
+
+
+void SetErrorMessage(const char *theErrorMessage)
+{
+	if (theErrorMessage != nil)
+	{
+		CopyCStrToCStr(theErrorMessage,gErrorMessage,gErrorMessageMaxLength);
+	}
+}
+
+
+void SetErrorMessageAndAppendLongInt(const char *theErrorMessage,const long theLongInt)
+{
+	if (theErrorMessage != nil)
+	{
+		CopyCStrAndConcatLongIntToCStr(theErrorMessage,theLongInt,gErrorMessage,gErrorMessageMaxLength);
+	}
+}
+
+void SetErrorMessageAndCStrAndLongInt(const char *theErrorMessage,const char * theCStr,const long theLongInt)
+{
+	if (theErrorMessage != nil)
+	{
+		CopyCStrAndInsertCStrLongIntIntoCStr(theErrorMessage,theCStr,theLongInt,gErrorMessage,gErrorMessageMaxLength);
+	}
+
+}
+
+void SetErrorMessageAndCStr(const char *theErrorMessage,const char * theCStr)
+{
+	if (theErrorMessage != nil)
+	{
+		CopyCStrAndInsertCStrLongIntIntoCStr(theErrorMessage,theCStr,-1,gErrorMessage,gErrorMessageMaxLength);
+	}
+}
+
+
+void AppendCStrToErrorMessage(const char *theErrorMessage)
+{
+	if (theErrorMessage != nil)
+	{
+		ConcatCStrToCStr(theErrorMessage,gErrorMessage,gErrorMessageMaxLength);
+	}
+}
+
+
+void AppendLongIntToErrorMessage(const long theLongInt)
+{
+	ConcatLongIntToCStr(theLongInt,gErrorMessage,gErrorMessageMaxLength);
+}
+
+
+
+char *GetErrorMessage(void)
+{
+	return gErrorMessage;
+}
+
+
+OSErr GetErrorMessageInNewHandle(Handle *inoutHandle)
+{
+OSErr		errCode;
+
+
+	errCode = CopyCStrToNewHandle(gErrorMessage,inoutHandle);
+	
+	return(errCode);
+}
+
+
+OSErr GetErrorMessageInExistingHandle(Handle inoutHandle)
+{
+OSErr		errCode;
+
+
+	errCode = CopyCStrToExistingHandle(gErrorMessage,inoutHandle);
+	
+	return(errCode);
+}
+
+
+
+OSErr AppendErrorMessageToHandle(Handle inoutHandle)
+{
+OSErr		errCode;
+
+
+	errCode = AppendCStrToHandle(gErrorMessage,inoutHandle,nil);
+	
+	return(errCode);
+}
+
+
+#ifdef __EXCEPTIONS_ENABLED__
+
+void ThrowErrorMessageException(void)
+{
+	ThrowDescriptiveException(gErrorMessage);
+}
+
+#endif
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/ErrorHandling.hpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/ErrorHandling.hpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/ErrorHandling.hpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/ErrorHandling.hpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,147 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef kGenericError
+	#define kGenericError		-1
+#endif
+
+extern char	*gErrorMessage;
+
+
+void SetErrorMessage(const char *theErrorMessage);
+void SetErrorMessageAndAppendLongInt(const char *theErrorMessage,const long theLongInt);
+void SetErrorMessageAndCStrAndLongInt(const char *theErrorMessage,const char * theCStr,const long theLongInt);
+void SetErrorMessageAndCStr(const char *theErrorMessage,const char * theCStr);
+void AppendCStrToErrorMessage(const char *theErrorMessage);
+void AppendLongIntToErrorMessage(const long theLongInt);
+
+
+char *GetErrorMessage(void);
+OSErr GetErrorMessageInNewHandle(Handle *inoutHandle);
+OSErr GetErrorMessageInExistingHandle(Handle inoutHandle);
+OSErr AppendErrorMessageToHandle(Handle inoutHandle);
+
+
+#ifdef __EXCEPTIONS_ENABLED__
+	void ThrowErrorMessageException(void);
+#endif
+
+
+
+//	A bunch of evil macros that would be unnecessary if I were always using C++ !
+
+#define SetErrorMessageAndBailIfNil(theArg,theMessage)								\
+{																					\
+	if (theArg == nil)																\
+	{																				\
+		SetErrorMessage(theMessage);												\
+		errCode = kGenericError;													\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define SetErrorMessageAndBail(theMessage)											\
+{																					\
+		SetErrorMessage(theMessage);												\
+		errCode = kGenericError;													\
+		goto EXITPOINT;																\
+}
+
+
+#define SetErrorMessageAndLongIntAndBail(theMessage,theLongInt)						\
+{																					\
+		SetErrorMessageAndAppendLongInt(theMessage,theLongInt);						\
+		errCode = kGenericError;													\
+		goto EXITPOINT;																\
+}
+
+
+#define SetErrorMessageAndLongIntAndBailIfError(theErrCode,theMessage,theLongInt)	\
+{																					\
+	if (theErrCode != noErr)														\
+	{																				\
+		SetErrorMessageAndAppendLongInt(theMessage,theLongInt);						\
+		errCode = theErrCode;														\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define SetErrorMessageCStrLongIntAndBailIfError(theErrCode,theMessage,theCStr,theLongInt)	\
+{																					\
+	if (theErrCode != noErr)														\
+	{																				\
+		SetErrorMessageAndCStrAndLongInt(theMessage,theCStr,theLongInt);			\
+		errCode = theErrCode;														\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define SetErrorMessageAndCStrAndBail(theMessage,theCStr)							\
+{																					\
+	SetErrorMessageAndCStr(theMessage,theCStr);										\
+	errCode = kGenericError;														\
+	goto EXITPOINT;																	\
+}
+
+
+#define SetErrorMessageAndBailIfError(theErrCode,theMessage)						\
+{																					\
+	if (theErrCode != noErr)														\
+	{																				\
+		SetErrorMessage(theMessage);												\
+		errCode = theErrCode;														\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define SetErrorMessageAndLongIntAndBailIfNil(theArg,theMessage,theLongInt)			\
+{																					\
+	if (theArg == nil)																\
+	{																				\
+		SetErrorMessageAndAppendLongInt(theMessage,theLongInt);						\
+		errCode = kGenericError;													\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define BailIfError(theErrCode)														\
+{																					\
+	if ((theErrCode) != noErr)														\
+	{																				\
+		goto EXITPOINT;																\
+	}																				\
+}
+
+
+#define SetErrCodeAndBail(theErrCode)												\
+{																					\
+	errCode = theErrCode;															\
+																					\
+	goto EXITPOINT;																	\
+}
+
+
+#define SetErrorCodeAndMessageAndBail(theErrCode,theMessage)						\
+{																					\
+	SetErrorMessage(theMessage);													\
+	errCode = theErrCode;															\
+	goto EXITPOINT;																	\
+}
+
+
+#define BailNow()																	\
+{																					\
+	errCode = kGenericError;														\
+	goto EXITPOINT;																	\
+}
+
+
+#ifdef __cplusplus
+}
+#endif
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/GetHTTPS.cpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/GetHTTPS.cpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/GetHTTPS.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/GetHTTPS.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,209 @@
+/*
+ *	An demo illustrating how to retrieve a URI from a secure HTTP server.
+ *
+ *	Author: 	Roy Wood
+ *	Date:		September 7, 1999
+ *	Comments:	This relies heavily on my MacSockets library.
+ *				This project is also set up so that it expects the OpenSSL source folder (0.9.4 as I write this)
+ *				to live in a folder called "OpenSSL-0.9.4" in this project's parent folder.  For example:
+ *
+ *					Macintosh HD:
+ *						Development:
+ *							OpenSSL-0.9.4:
+ *								(OpenSSL sources here)
+ *							OpenSSL Example:
+ *								(OpenSSL example junk here)
+ *
+ *
+ *				Also-- before attempting to compile this, make sure the aliases in "OpenSSL-0.9.4:include:openssl" 
+ *				are installed!  Use the AppleScript applet in the "openssl-0.9.4" folder to do this!
+ */
+/* modified to seed the PRNG */
+/* modified to use CRandomizer for seeding */
+
+
+//	Include some funky libs I've developed over time
+
+#include "CPStringUtils.hpp"
+#include "ErrorHandling.hpp"
+#include "MacSocket.h"
+#include "Randomizer.h"
+
+//	We use the OpenSSL implementation of SSL....
+//	This was a lot of work to finally get going, though you wouldn't know it by the results!
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+
+#include <timer.h>
+
+//	Let's try grabbing some data from here:
+
+#define kHTTPS_DNS		"www.apache-ssl.org"
+#define kHTTPS_Port		443
+#define kHTTPS_URI		"/"
+
+
+//	Forward-declare this
+
+OSErr MyMacSocket_IdleWaitCallback(void *inUserRefPtr);
+
+//	My idle-wait callback.  Doesn't do much, does it?  Silly cooperative multitasking.
+
+OSErr MyMacSocket_IdleWaitCallback(void *inUserRefPtr)
+{
+#pragma unused(inUserRefPtr)
+
+EventRecord		theEvent;
+	::EventAvail(everyEvent,&theEvent);
+	
+	CRandomizer *randomizer = (CRandomizer*)inUserRefPtr;
+	if (randomizer)
+		randomizer->PeriodicAction();
+
+	return(noErr);
+}
+
+
+//	Finally!
+
+void main(void)
+{
+	OSErr				errCode;
+	int					theSocket = -1;
+	int					theTimeout = 30;
+
+	SSL_CTX				*ssl_ctx = nil;
+	SSL					*ssl = nil;
+
+	char				tempString[256];
+	UnsignedWide		microTickCount;
+
+
+	CRandomizer randomizer;
+	
+	printf("OpenSSL Demo by Roy Wood, roy@centricsystems.ca\n\n");
+	
+	BailIfError(errCode = MacSocket_Startup());
+
+
+
+	//	Create a socket-like object
+	
+	BailIfError(errCode = MacSocket_socket(&theSocket,false,theTimeout * 60,MyMacSocket_IdleWaitCallback,&randomizer));
+
+	
+	//	Set up the connect string and try to connect
+	
+	CopyCStrAndInsertCStrLongIntIntoCStr("%s:%ld",kHTTPS_DNS,kHTTPS_Port,tempString,sizeof(tempString));
+	
+	printf("Connecting to %s....\n",tempString);
+
+	BailIfError(errCode = MacSocket_connect(theSocket,tempString));
+	
+	
+	//	Init SSL stuff
+	
+	SSL_load_error_strings();
+	
+	SSLeay_add_ssl_algorithms();
+	
+	
+	//	Pick the SSL method
+	
+//	ssl_ctx = SSL_CTX_new(SSLv2_client_method());
+	ssl_ctx = SSL_CTX_new(SSLv23_client_method());
+//	ssl_ctx = SSL_CTX_new(SSLv3_client_method());
+			
+
+	//	Create an SSL thingey and try to negotiate the connection
+	
+	ssl = SSL_new(ssl_ctx);
+	
+	SSL_set_fd(ssl,theSocket);
+	
+	errCode = SSL_connect(ssl);
+	
+	if (errCode < 0)
+	{
+		SetErrorMessageAndLongIntAndBail("OpenSSL: Can't initiate SSL connection, SSL_connect() = ",errCode);
+	}
+	
+	//	Request the URI from the host
+	
+	CopyCStrToCStr("GET ",tempString,sizeof(tempString));
+	ConcatCStrToCStr(kHTTPS_URI,tempString,sizeof(tempString));
+	ConcatCStrToCStr(" HTTP/1.0\r\n\r\n",tempString,sizeof(tempString));
+
+	
+	errCode = SSL_write(ssl,tempString,CStrLength(tempString));
+	
+	if (errCode < 0)
+	{
+		SetErrorMessageAndLongIntAndBail("OpenSSL: Error writing data via ssl, SSL_write() = ",errCode);
+	}
+	
+
+	for (;;)
+	{
+	char	tempString[256];
+	int		bytesRead;
+		
+
+		//	Read some bytes and dump them to the console
+		
+		bytesRead = SSL_read(ssl,tempString,sizeof(tempString) - 1);
+		
+		if (bytesRead == 0 && MacSocket_RemoteEndIsClosing(theSocket))
+		{
+			break;
+		}
+		
+		else if (bytesRead < 0)
+		{
+			SetErrorMessageAndLongIntAndBail("OpenSSL: Error reading data via ssl, SSL_read() = ",bytesRead);
+		}
+		
+		
+		tempString[bytesRead] = '\0';
+		
+		printf("%s", tempString);
+	}
+	
+	printf("\n\n\n");
+	
+	//	All done!
+	
+	errCode = noErr;
+	
+	
+EXITPOINT:
+
+	//	Clean up and go home
+	
+	if (theSocket >= 0)
+	{
+		MacSocket_close(theSocket);
+	}
+	
+	if (ssl != nil)
+	{
+		SSL_free(ssl);
+	}
+	
+	if (ssl_ctx != nil)
+	{
+		SSL_CTX_free(ssl_ctx);
+	}
+	
+	
+	if (errCode != noErr)
+	{
+		printf("An error occurred:\n");
+		
+		printf("%s",GetErrorMessage());
+	}
+	
+	
+	MacSocket_Shutdown();
+}
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/MacSocket.cpp libressl-3.1.0-apple/MacOS/GetHTTPS.src/MacSocket.cpp
--- libressl-3.1.0/MacOS/GetHTTPS.src/MacSocket.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/MacSocket.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,1607 @@
+/*
+ *	A simple socket-like package.  
+ *	This could undoubtedly be improved, since it does polling and busy-waiting.  
+ *	At least it uses asynch I/O and implements timeouts!
+ *
+ *	Other funkiness includes the use of my own (possibly brain-damaged) error-handling infrastructure.
+ *
+ *	-Roy Wood (roy@centricsystems.ca)
+ *
+ */
+
+
+/* ====================================================================
+ * Copyright (c) 1998-1999 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+ 
+
+
+
+
+#include "MacSocket.h"
+
+#include <Threads.h>
+
+#include <OpenTransport.h>
+#include <OpenTpTInternet.h>
+#include <OpenTptClient.h>
+
+
+
+#include "CPStringUtils.hpp"
+#include "ErrorHandling.hpp"
+
+
+//	#define MACSOCKET_DEBUG		1
+
+#ifdef MACSOCKET_DEBUG
+	#include <stdio.h>
+#endif
+
+
+
+extern int errno;
+
+
+#define kMaxNumSockets			4
+
+
+struct SocketStruct
+{
+	Boolean						mIsInUse;
+
+	Boolean						mEndpointIsBound;
+
+	Boolean						mLocalEndIsConnected;
+	Boolean						mRemoteEndIsConnected;
+
+	Boolean						mReceivedTOpenComplete;
+	Boolean						mReceivedTBindComplete;
+	Boolean						mReceivedTConnect;
+	Boolean						mReceivedTListen;
+	Boolean						mReceivedTPassCon;
+	Boolean						mReceivedTDisconnect;
+	Boolean						mReceivedTOrdRel;
+	Boolean						mReceivedTDisconnectComplete;
+	
+	long						mTimeoutTicks;
+	long						mOperationStartTicks;
+	
+	MacSocket_IdleWaitCallback	mIdleWaitCallback;
+	void						*mUserRefPtr;
+	
+	OTEventCode					mExpectedCode;
+	OTResult					mAsyncOperationResult;
+	
+	EndpointRef		 			mEndPointRef;
+	TBind						*mBindRequestedAddrInfo;
+	TBind						*mAssignedAddrInfo;
+	TCall						*mRemoteAddrInfo;
+	
+	Boolean						mReadyToReadData;
+	Boolean						mReadyToWriteData;
+	
+	Ptr							mReadBuffer;
+	Ptr							mWriteBuffer;
+	
+	int							mLastError;
+	char						mErrMessage[256];
+};
+
+typedef struct SocketStruct	SocketStruct;
+
+
+static SocketStruct			sSockets[kMaxNumSockets];
+static Boolean				sSocketsSetup = false;
+
+
+
+
+static OSErr MyBusyWait(SocketStruct *ioSocket,Boolean returnImmediatelyOnError,OTResult *outOTResult,Boolean *inAsyncOperationCompleteFlag);
+
+static pascal void OTNonYieldingNotifier(void *contextPtr,OTEventCode code,OTResult result,void *cookie);
+
+static Boolean	SocketIndexIsValid(const int inSocketNum);
+
+static void InitSocket(SocketStruct *ioSocket);
+
+static void PrepareForAsyncOperation(SocketStruct *ioSocket,const OTEventCode inExpectedCode);
+
+static Boolean TimeoutElapsed(const SocketStruct *inSocket);
+
+static OSStatus NegotiateIPReuseAddrOption(EndpointRef inEndpoint,const Boolean inEnableReuseIP);
+
+
+
+void MacSocket_GetSocketErrorInfo(const int inSocketNum,int *outSocketErrCode,char *outSocketErrString,const int inSocketErrStringMaxLength)
+{
+	if (outSocketErrCode != nil)
+	{
+		*outSocketErrCode = -1;
+	}
+	
+	if (outSocketErrString != nil)
+	{
+		CopyCStrToCStr("",outSocketErrString,inSocketErrStringMaxLength);
+	}
+	
+	
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+	
+		
+		if (outSocketErrCode != nil)
+		{
+			*outSocketErrCode = theSocketStruct->mLastError;
+		}
+
+		if (outSocketErrString != nil)
+		{
+			CopyCStrToCStr(theSocketStruct->mErrMessage,outSocketErrString,inSocketErrStringMaxLength);
+		}
+	}
+}
+
+
+void MacSocket_SetUserRefPtr(const int inSocketNum,void *inNewRefPtr)
+{
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+
+		theSocketStruct->mUserRefPtr = inNewRefPtr;
+	}
+}
+
+
+
+void MacSocket_GetLocalIPAndPort(const int inSocketNum,char *outIPAndPort,const int inIPAndPortLength)
+{
+	if (outIPAndPort != nil && SocketIndexIsValid(inSocketNum))
+	{
+	char			tempString[256];
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+	
+		
+		CopyCStrToCStr("",tempString,sizeof(tempString));
+
+		if (theSocketStruct->mAssignedAddrInfo != nil)
+		{
+		InetAddress		*theInetAddress = (InetAddress *) theSocketStruct->mAssignedAddrInfo->addr.buf;
+		InetHost		theInetHost = theInetAddress->fHost;
+			
+			if (theInetHost == 0)
+			{
+			InetInterfaceInfo	theInetInterfaceInfo;
+				
+				if (::OTInetGetInterfaceInfo(&theInetInterfaceInfo,kDefaultInetInterface) == noErr)
+				{
+					theInetHost = theInetInterfaceInfo.fAddress;
+				}
+			}
+		
+			::OTInetHostToString(theInetHost,tempString);
+			
+			ConcatCStrToCStr(":",tempString,sizeof(tempString));
+			ConcatLongIntToCStr(theInetAddress->fPort,tempString,sizeof(tempString));
+		}
+		
+		CopyCStrToCStr(tempString,outIPAndPort,inIPAndPortLength);
+	}
+}
+
+
+
+void MacSocket_GetRemoteIPAndPort(const int inSocketNum,char *outIPAndPort,const int inIPAndPortLength)
+{
+	if (outIPAndPort != nil && SocketIndexIsValid(inSocketNum))
+	{
+	char			tempString[256];
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+	
+		
+		CopyCStrToCStr("",tempString,sizeof(tempString));
+
+		if (theSocketStruct->mRemoteAddrInfo != nil)
+		{
+		InetAddress		*theInetAddress = (InetAddress *) theSocketStruct->mRemoteAddrInfo->addr.buf;
+		InetHost		theInetHost = theInetAddress->fHost;
+			
+			if (theInetHost == 0)
+			{
+			InetInterfaceInfo	theInetInterfaceInfo;
+				
+				if (::OTInetGetInterfaceInfo(&theInetInterfaceInfo,kDefaultInetInterface) == noErr)
+				{
+					theInetHost = theInetInterfaceInfo.fAddress;
+				}
+			}
+		
+			::OTInetHostToString(theInetHost,tempString);
+			
+			ConcatCStrToCStr(":",tempString,sizeof(tempString));
+			ConcatLongIntToCStr(theInetAddress->fPort,tempString,sizeof(tempString));
+		}
+		
+		CopyCStrToCStr(tempString,outIPAndPort,inIPAndPortLength);
+	}
+}
+
+
+
+Boolean MacSocket_RemoteEndIsClosing(const int inSocketNum)
+{
+Boolean		theResult = false;
+
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+
+		theResult = theSocketStruct->mReceivedTOrdRel;
+	}
+
+	return(theResult);
+}
+
+
+
+Boolean MacSocket_ListenCompleted(const int inSocketNum)
+{
+Boolean		theResult = false;
+
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+
+		theResult = theSocketStruct->mReceivedTPassCon;
+	}
+
+	return(theResult);
+}
+
+
+
+Boolean MacSocket_RemoteEndIsOpen(const int inSocketNum)
+{
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+	
+		return(theSocketStruct->mRemoteEndIsConnected);
+	}
+	
+	else
+	{
+		return(false);
+	}
+}
+
+
+
+Boolean MacSocket_LocalEndIsOpen(const int inSocketNum)
+{
+	if (SocketIndexIsValid(inSocketNum))
+	{
+	SocketStruct	*theSocketStruct = &(sSockets[inSocketNum]);
+	
+		return(theSocketStruct->mLocalEndIsConnected);
+	}
+	
+	else
+	{
+		return(false);
+	}
+}
+
+
+
+static Boolean TimeoutElapsed(const SocketStruct *inSocket)
+{
+Boolean		timeIsUp = false;
+
+	if (inSocket != nil && inSocket->mTimeoutTicks > 0 && ::TickCount() > inSocket->mOperationStartTicks + inSocket->mTimeoutTicks)
+	{
+		timeIsUp = true;
+	}
+	
+	
+	return(timeIsUp);
+}
+
+
+
+static Boolean SocketIndexIsValid(const int inSocketNum)
+{
+	if (inSocketNum >= 0 && inSocketNum < kMaxNumSockets && sSockets[inSocketNum].mEndPointRef != kOTInvalidEndpointRef)
+	{
+		return(true);
+	}
+	
+	else
+	{
+		return(false);
+	}
+}
+
+
+
+static void InitSocket(SocketStruct *ioSocket)
+{
+	ioSocket->mIsInUse = false;
+	
+	ioSocket->mEndpointIsBound = false;
+	
+	ioSocket->mLocalEndIsConnected = false;
+	ioSocket->mRemoteEndIsConnected = false;
+	
+	ioSocket->mReceivedTOpenComplete = false;
+	ioSocket->mReceivedTBindComplete = false;
+	ioSocket->mReceivedTConnect = false;
+	ioSocket->mReceivedTListen = false;
+	ioSocket->mReceivedTPassCon = false;
+	ioSocket->mReceivedTDisconnect = false;
+	ioSocket->mReceivedTOrdRel = false;
+	ioSocket->mReceivedTDisconnectComplete = false;
+	
+	ioSocket->mTimeoutTicks = 30 * 60;
+	ioSocket->mOperationStartTicks = -1;
+	
+	ioSocket->mIdleWaitCallback = nil;
+	ioSocket->mUserRefPtr = nil;
+	
+	ioSocket->mExpectedCode = 0;
+	ioSocket->mAsyncOperationResult = noErr;
+	
+	ioSocket->mEndPointRef = kOTInvalidEndpointRef;
+	
+	ioSocket->mBindRequestedAddrInfo = nil;
+	ioSocket->mAssignedAddrInfo = nil;
+	ioSocket->mRemoteAddrInfo = nil;
+	
+	ioSocket->mReadyToReadData = false;
+	ioSocket->mReadyToWriteData = true;
+	
+	ioSocket->mReadBuffer = nil;
+	ioSocket->mWriteBuffer = nil;
+
+	ioSocket->mLastError = noErr;
+	CopyCStrToCStr("",ioSocket->mErrMessage,sizeof(ioSocket->mErrMessage));
+}
+
+
+
+static void PrepareForAsyncOperation(SocketStruct *ioSocket,const OTEventCode inExpectedCode)
+{
+	ioSocket->mOperationStartTicks = ::TickCount();
+	
+	ioSocket->mAsyncOperationResult = noErr;
+	
+	ioSocket->mExpectedCode = inExpectedCode;
+}
+
+
+//	The wait function....
+
+static OSErr MyBusyWait(SocketStruct *ioSocket,Boolean returnImmediatelyOnError,OTResult *outOTResult,Boolean *inAsyncOperationCompleteFlag)
+{
+OSErr 		errCode = noErr;
+OTResult	theOTResult = noErr;
+
+	
+	SetErrorMessageAndBailIfNil(ioSocket,"MyBusyWait: Bad parameter, ioSocket = nil");
+	SetErrorMessageAndBailIfNil(inAsyncOperationCompleteFlag,"MyBusyWait: Bad parameter, inAsyncOperationCompleteFlag = nil");
+	
+	for (;;) 
+	{
+		if (*inAsyncOperationCompleteFlag)
+		{
+			theOTResult = ioSocket->mAsyncOperationResult;
+			
+			break;
+		}
+		
+		if (ioSocket->mIdleWaitCallback != nil)
+		{
+			theOTResult = (*(ioSocket->mIdleWaitCallback))(ioSocket->mUserRefPtr);
+			
+			if (theOTResult != noErr && returnImmediatelyOnError)
+			{
+				break;
+			}
+		}
+		
+		if (TimeoutElapsed(ioSocket))
+		{
+			theOTResult = kMacSocket_TimeoutErr;
+			
+			break;
+		}
+	}
+
+
+EXITPOINT:
+	
+	if (outOTResult != nil)
+	{
+		*outOTResult = theOTResult;
+	}
+	
+	return(errCode);
+}
+
+
+
+//	I used to do thread switching, but stopped.  It could easily be rolled back in though....
+
+static pascal void OTNonYieldingNotifier(void *contextPtr,OTEventCode code,OTResult result,void *cookie)
+{
+SocketStruct *theSocketStruct = (SocketStruct *) contextPtr;
+	
+	if (theSocketStruct != nil)
+	{
+		if (theSocketStruct->mExpectedCode != 0 && code == theSocketStruct->mExpectedCode)
+		{
+			theSocketStruct->mAsyncOperationResult = result;
+			
+			theSocketStruct->mExpectedCode = 0;
+		}
+		
+		
+		switch (code) 
+		{
+			case T_OPENCOMPLETE:
+			{
+				theSocketStruct->mReceivedTOpenComplete = true;
+				
+				theSocketStruct->mEndPointRef = (EndpointRef) cookie;
+				
+				break;
+			}
+
+			
+			case T_BINDCOMPLETE:
+			{
+				theSocketStruct->mReceivedTBindComplete = true;
+				
+				break;
+			}
+			
+
+			case T_CONNECT:
+			{
+				theSocketStruct->mReceivedTConnect = true;
+
+				theSocketStruct->mLocalEndIsConnected = true;
+				
+				theSocketStruct->mRemoteEndIsConnected = true;
+
+				break;
+			}
+			
+
+			case T_LISTEN:
+			{
+				theSocketStruct->mReceivedTListen = true;
+				
+				break;
+			}
+			
+
+			case T_PASSCON:
+			{
+				theSocketStruct->mReceivedTPassCon = true;
+				
+				theSocketStruct->mLocalEndIsConnected = true;
+				
+				theSocketStruct->mRemoteEndIsConnected = true;
+
+				break;
+			}
+
+
+			case T_DATA:
+			{
+				theSocketStruct->mReadyToReadData = true;
+				
+				break;
+			}
+			
+			case T_GODATA:
+			{
+				theSocketStruct->mReadyToWriteData = true;
+				
+				break;
+			}
+			
+			case T_DISCONNECT:
+			{
+				theSocketStruct->mReceivedTDisconnect = true;
+				
+				theSocketStruct->mRemoteEndIsConnected = false;
+				
+				theSocketStruct->mLocalEndIsConnected = false;
+				
+				::OTRcvDisconnect(theSocketStruct->mEndPointRef,nil);
+				
+				break;
+			}
+
+			case T_ORDREL:
+			{
+				theSocketStruct->mReceivedTOrdRel = true;
+				
+				//	We can still write data, so don't clear mRemoteEndIsConnected
+				
+				::OTRcvOrderlyDisconnect(theSocketStruct->mEndPointRef);
+				
+				break;
+			}
+			
+			case T_DISCONNECTCOMPLETE:
+			{
+				theSocketStruct->mReceivedTDisconnectComplete = true;
+				
+				theSocketStruct->mRemoteEndIsConnected = false;
+				
+				theSocketStruct->mLocalEndIsConnected = false;
+				
+				break;
+			}
+		}
+	}
+/*
+T_LISTEN OTListen
+T_CONNECT OTRcvConnect
+T_DATA OTRcv, OTRcvUData
+T_DISCONNECT OTRcvDisconnect
+T_ORDREL OTRcvOrderlyDisconnect
+T_GODATA OTSnd, OTSndUData, OTLook
+T_PASSCON none
+
+T_EXDATA OTRcv
+T_GOEXDATA OTSnd, OTLook
+T_UDERR OTRcvUDErr
+*/
+}
+
+
+
+//	Initialize the main socket data structure
+
+OSErr MacSocket_Startup(void)
+{
+	if (!sSocketsSetup)
+	{
+		for (int i = 0;i < kMaxNumSockets;i++)
+		{
+			InitSocket(&(sSockets[i]));
+		}
+
+		::InitOpenTransport();
+		
+		sSocketsSetup = true;
+	}
+	
+	
+	return(noErr);
+}
+
+
+
+//	Cleanup before exiting
+
+OSErr MacSocket_Shutdown(void)
+{
+	if (sSocketsSetup)
+	{
+		for (int i = 0;i < kMaxNumSockets;i++)
+		{
+		SocketStruct *theSocketStruct = &(sSockets[i]);
+		
+			if (theSocketStruct->mIsInUse)
+			{
+				if (theSocketStruct->mEndPointRef != kOTInvalidEndpointRef)
+				{
+				OTResult	theOTResult;
+				
+				
+					//	Since we're killing the endpoint, I don't bother to send the disconnect (sorry!)
+
+/*
+					if (theSocketStruct->mLocalEndIsConnected)
+					{
+						//	This is an abortive action, so we do a hard disconnect instead of an OTSndOrderlyDisconnect
+						
+						theOTResult = ::OTSndDisconnect(theSocketStruct->mEndPointRef, nil);
+						
+						//	Now we have to watch for T_DISCONNECTCOMPLETE event
+						
+						theSocketStruct->mLocalEndIsConnected = false;
+					}
+*/					
+					
+					theOTResult = ::OTCloseProvider(theSocketStruct->mEndPointRef);
+					
+					
+					theSocketStruct->mEndPointRef = kOTInvalidEndpointRef;
+				}
+				
+				if (theSocketStruct->mBindRequestedAddrInfo != nil)
+				{
+					::OTFree((void *) theSocketStruct->mBindRequestedAddrInfo,T_BIND);
+					
+					theSocketStruct->mBindRequestedAddrInfo = nil;
+				}
+				
+				if (theSocketStruct->mAssignedAddrInfo != nil)
+				{
+					::OTFree((void *) theSocketStruct->mAssignedAddrInfo,T_BIND);
+					
+					theSocketStruct->mAssignedAddrInfo = nil;
+				}
+				
+				if (theSocketStruct->mRemoteAddrInfo != nil)
+				{
+					::OTFree((void *) theSocketStruct->mRemoteAddrInfo,T_CALL);
+					
+					theSocketStruct->mRemoteAddrInfo = nil;
+				}
+				
+				
+			}
+		}
+		
+		::CloseOpenTransport();
+
+		sSocketsSetup = false;
+	}
+	
+	return(noErr);
+}
+
+
+
+
+
+
+//	Allocate a socket
+
+OSErr MacSocket_socket(int *outSocketNum,const Boolean inDoThreadSwitching,const long inTimeoutTicks,MacSocket_IdleWaitCallback inIdleWaitCallback,void *inUserRefPtr)
+{
+//	Gotta roll support back in for threads eventually.....
+
+#pragma unused(inDoThreadSwitching)
+
+
+OSErr	errCode = noErr;
+
+	
+	SetErrorMessageAndBailIfNil(outSocketNum,"MacSocket_socket: Bad parameter, outSocketNum == nil");
+	
+	*outSocketNum = -1;
+	
+	
+	//	Find an unused socket
+	
+	for (int i = 0;i < kMaxNumSockets;i++)
+	{
+		if (sSockets[i].mIsInUse == false)
+		{
+		OTResult		theOTResult;
+		SocketStruct	*theSocketStruct = &(sSockets[i]);
+		
+			
+			InitSocket(theSocketStruct);
+			
+			theSocketStruct->mIdleWaitCallback = inIdleWaitCallback;
+			theSocketStruct->mUserRefPtr = inUserRefPtr;
+			
+			theSocketStruct->mTimeoutTicks = inTimeoutTicks;
+			
+
+			//	Set up OT endpoint
+			
+			PrepareForAsyncOperation(theSocketStruct,T_OPENCOMPLETE);
+			
+			theOTResult = ::OTAsyncOpenEndpoint(OTCreateConfiguration(kTCPName),0,nil,OTNonYieldingNotifier,(void *) theSocketStruct);
+			
+			SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_socket: Can't create OT endpoint, OTAsyncOpenEndpoint() = ",theOTResult);
+			
+			BailIfError(MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTOpenComplete)));
+																						
+			SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_socket: Can't create OT endpoint, OTAsyncOpenEndpoint() = ",theOTResult);
+			
+			
+			*outSocketNum = i;
+			
+			errCode = noErr;
+			
+			theSocketStruct->mIsInUse = true;
+			
+			break;
+		}
+		
+		else if (i == kMaxNumSockets - 1)
+		{
+			SetErrorMessageAndBail("MacSocket_socket: No sockets available");
+		}
+	}
+
+
+EXITPOINT:
+	
+	errno = errCode;
+	
+	return(errCode);
+}
+
+
+
+
+OSErr MacSocket_listen(const int inSocketNum,const int inPortNum)
+{
+OSErr			errCode = noErr;
+SocketStruct	*theSocketStruct = nil;
+
+
+	if (!SocketIndexIsValid(inSocketNum))
+	{
+		SetErrorMessageAndBail("MacSocket_listen: Invalid socket number specified");
+	}
+
+
+	theSocketStruct = &(sSockets[inSocketNum]);
+
+
+OTResult		theOTResult;
+	
+	
+	if (theSocketStruct->mBindRequestedAddrInfo == nil)
+	{
+		theSocketStruct->mBindRequestedAddrInfo = (TBind *) ::OTAlloc(theSocketStruct->mEndPointRef,T_BIND,T_ADDR,&theOTResult);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't allocate OT T_BIND structure, OTAlloc() = ",theOTResult);
+		SetErrorMessageAndBailIfNil(theSocketStruct->mBindRequestedAddrInfo,"MacSocket_listen: Can't allocate OT T_BIND structure, OTAlloc() returned nil");
+	}
+	
+	if (theSocketStruct->mAssignedAddrInfo == nil)
+	{
+		theSocketStruct->mAssignedAddrInfo = (TBind *) ::OTAlloc(theSocketStruct->mEndPointRef,T_BIND,T_ADDR,&theOTResult);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't allocate OT T_BIND structure, OTAlloc() = ",theOTResult);
+		SetErrorMessageAndBailIfNil(theSocketStruct->mAssignedAddrInfo,"MacSocket_listen: Can't allocate OT T_BIND structure, OTAlloc() returned nil");
+	}
+	
+	if (theSocketStruct->mRemoteAddrInfo == nil)
+	{
+		theSocketStruct->mRemoteAddrInfo = (TCall *) ::OTAlloc(theSocketStruct->mEndPointRef,T_CALL,T_ADDR,&theOTResult);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't allocate OT T_CALL structure, OTAlloc() = ",theOTResult);
+		SetErrorMessageAndBailIfNil(theSocketStruct->mRemoteAddrInfo,"MacSocket_listen: Can't allocate OT T_CALL structure, OTAlloc() returned nil");
+	}
+	
+
+	if (!theSocketStruct->mEndpointIsBound)
+	{
+	InetInterfaceInfo	theInetInterfaceInfo;
+		
+		theOTResult = ::OTInetGetInterfaceInfo(&theInetInterfaceInfo,kDefaultInetInterface);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't determine OT interface info, OTInetGetInterfaceInfo() = ",theOTResult);
+
+
+	InetAddress	*theInetAddress = (InetAddress *) theSocketStruct->mBindRequestedAddrInfo->addr.buf;
+		
+//		theInetAddress->fAddressType = AF_INET;
+//		theInetAddress->fPort = inPortNum;
+//		theInetAddress->fHost = theInetInterfaceInfo.fAddress;
+		
+		::OTInitInetAddress(theInetAddress,inPortNum,theInetInterfaceInfo.fAddress);
+
+		theSocketStruct->mBindRequestedAddrInfo->addr.len = sizeof(InetAddress);
+		
+		theSocketStruct->mBindRequestedAddrInfo->qlen = 1;
+		
+		
+		theOTResult = ::OTSetSynchronous(theSocketStruct->mEndPointRef);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't set OT endpoint mode, OTSetSynchronous() = ",theOTResult);
+		
+		theOTResult = NegotiateIPReuseAddrOption(theSocketStruct->mEndPointRef,true);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't set OT IP address reuse flag, NegotiateIPReuseAddrOption() = ",theOTResult);
+		
+		theOTResult = ::OTSetAsynchronous(theSocketStruct->mEndPointRef);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't set OT endpoint mode, OTSetAsynchronous() = ",theOTResult);
+
+		
+		PrepareForAsyncOperation(theSocketStruct,T_BINDCOMPLETE);
+				
+		theOTResult = ::OTBind(theSocketStruct->mEndPointRef,theSocketStruct->mBindRequestedAddrInfo,theSocketStruct->mAssignedAddrInfo);
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't bind OT endpoint, OTBind() = ",theOTResult);
+		
+		BailIfError(MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTBindComplete)));
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't bind OT endpoint, OTBind() = ",theOTResult);
+		
+		
+		theSocketStruct->mEndpointIsBound = true;
+	}
+
+
+	PrepareForAsyncOperation(theSocketStruct,T_LISTEN);
+
+	theOTResult = ::OTListen(theSocketStruct->mEndPointRef,theSocketStruct->mRemoteAddrInfo);
+	
+	if (theOTResult == noErr)
+	{
+		PrepareForAsyncOperation(theSocketStruct,T_PASSCON);
+		
+		theOTResult = ::OTAccept(theSocketStruct->mEndPointRef,theSocketStruct->mEndPointRef,theSocketStruct->mRemoteAddrInfo);
+		
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't begin OT accept, OTAccept() = ",theOTResult);
+		
+		BailIfError(MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTPassCon)));
+																					
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_listen: Can't accept OT connection, OTAccept() = ",theOTResult);
+	}
+	
+	else if (theOTResult == kOTNoDataErr)
+	{
+		theOTResult = noErr;
+	}
+	
+	else
+	{
+		SetErrorMessageAndLongIntAndBail("MacSocket_listen: Can't begin OT listen, OTListen() = ",theOTResult);
+	}
+
+
+	errCode = noErr;
+
+
+EXITPOINT:
+	
+	if (theSocketStruct != nil)
+	{
+		theSocketStruct->mLastError = noErr;
+		
+		CopyCStrToCStr("",theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+
+		if (errCode != noErr)
+		{
+			theSocketStruct->mLastError = errCode;
+			
+			CopyCStrToCStr(GetErrorMessage(),theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+		}
+	}
+	
+	errno = errCode;
+	
+	return(errCode);
+}
+
+
+
+
+OSErr MacSocket_connect(const int inSocketNum,char *inTargetAddressAndPort)
+{
+OSErr			errCode = noErr;
+SocketStruct	*theSocketStruct = nil;
+
+
+	if (!SocketIndexIsValid(inSocketNum))
+	{
+		SetErrorMessageAndBail("MacSocket_connect: Invalid socket number specified");
+	}
+
+	theSocketStruct = &(sSockets[inSocketNum]);
+
+	if (theSocketStruct->mEndpointIsBound)
+	{
+		SetErrorMessageAndBail("MacSocket_connect: Socket previously bound");
+	}
+
+	
+OTResult		theOTResult;
+
+	theSocketStruct->mBindRequestedAddrInfo = (TBind *) ::OTAlloc(theSocketStruct->mEndPointRef,T_BIND,T_ADDR,&theOTResult);
+																				
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't allocate OT T_BIND structure, OTAlloc() = ",theOTResult);
+	SetErrorMessageAndBailIfNil(theSocketStruct->mBindRequestedAddrInfo,"MacSocket_connect: Can't allocate OT T_BIND structure, OTAlloc() returned nil");
+	
+
+	theSocketStruct->mAssignedAddrInfo = (TBind *) ::OTAlloc(theSocketStruct->mEndPointRef,T_BIND,T_ADDR,&theOTResult);
+																				
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't allocate OT T_BIND structure, OTAlloc() = ",theOTResult);
+	SetErrorMessageAndBailIfNil(theSocketStruct->mAssignedAddrInfo,"MacSocket_connect: Can't allocate OT T_BIND structure, OTAlloc() returned nil");
+
+
+	theSocketStruct->mRemoteAddrInfo = (TCall *) ::OTAlloc(theSocketStruct->mEndPointRef,T_CALL,T_ADDR,&theOTResult);
+																				
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't allocate OT T_CALL structure, OTAlloc() = ",theOTResult);
+	SetErrorMessageAndBailIfNil(theSocketStruct->mRemoteAddrInfo,"MacSocket_connect: Can't allocate OT T_CALL structure, OTAlloc() returned nil");
+
+	
+	PrepareForAsyncOperation(theSocketStruct,T_BINDCOMPLETE);
+
+	theOTResult = ::OTBind(theSocketStruct->mEndPointRef,nil,theSocketStruct->mAssignedAddrInfo);
+																				
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't bind OT endpoint, OTBind() = ",theOTResult);
+	
+	BailIfError(MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTBindComplete)));
+																				
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't bind OT endpoint, OTBind() = ",theOTResult);
+	
+	theSocketStruct->mEndpointIsBound = true;
+	
+
+TCall		sndCall;
+DNSAddress 	hostDNSAddress;
+	
+	//	Set up target address
+	
+	sndCall.addr.buf = (UInt8 *) &hostDNSAddress;
+	sndCall.addr.len = ::OTInitDNSAddress(&hostDNSAddress,inTargetAddressAndPort);
+	sndCall.opt.buf = nil;
+	sndCall.opt.len = 0;
+	sndCall.udata.buf = nil;
+	sndCall.udata.len = 0;
+	sndCall.sequence = 0;
+		
+	//	Connect!
+	
+	PrepareForAsyncOperation(theSocketStruct,T_CONNECT);
+
+	theOTResult = ::OTConnect(theSocketStruct->mEndPointRef,&sndCall,nil);
+	
+	if (theOTResult == kOTNoDataErr)
+	{
+		theOTResult = noErr;
+	}
+												
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't connect OT endpoint, OTConnect() = ",theOTResult);
+	
+	BailIfError(MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTConnect)));
+	
+	if (theOTResult == kMacSocket_TimeoutErr)
+	{
+		SetErrorMessageAndBail("MacSocket_connect: Can't connect OT endpoint, OTConnect() = kMacSocket_TimeoutErr");
+	}
+	
+	else
+	{
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't connect OT endpoint, OTConnect() = ",theOTResult);
+	}
+
+	theOTResult = ::OTRcvConnect(theSocketStruct->mEndPointRef,nil);
+												
+	SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_connect: Can't complete connect on OT endpoint, OTRcvConnect() = ",theOTResult);
+
+
+	errCode = noErr;
+
+
+#ifdef MACSOCKET_DEBUG
+	printf("MacSocket_connect: connect completed\n");
+#endif
+
+EXITPOINT:
+	
+	if (theSocketStruct != nil)
+	{
+		theSocketStruct->mLastError = noErr;
+		
+		CopyCStrToCStr("",theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+
+		if (errCode != noErr)
+		{
+			theSocketStruct->mLastError = errCode;
+			
+			CopyCStrToCStr(GetErrorMessage(),theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+		}
+	}
+	
+	errno = errCode;
+	
+	return(errCode);
+}
+
+
+
+
+//	Close a connection
+
+OSErr MacSocket_close(const int inSocketNum)
+{
+OSErr			errCode = noErr;
+SocketStruct	*theSocketStruct = nil;
+
+
+	if (!SocketIndexIsValid(inSocketNum))
+	{
+		SetErrorMessageAndBail("MacSocket_close: Invalid socket number specified");
+	}
+
+
+	theSocketStruct = &(sSockets[inSocketNum]);
+	
+	if (theSocketStruct->mEndPointRef != kOTInvalidEndpointRef)
+	{
+	OTResult		theOTResult = noErr;
+	
+		//	Try to play nice
+		
+		if (theSocketStruct->mReceivedTOrdRel)
+		{
+			//	Already did an OTRcvOrderlyDisconnect() in the notifier
+		
+			if (theSocketStruct->mLocalEndIsConnected)
+			{
+				theOTResult = ::OTSndOrderlyDisconnect(theSocketStruct->mEndPointRef);
+				
+				theSocketStruct->mLocalEndIsConnected = false;
+			}
+		}
+		
+		else if (theSocketStruct->mLocalEndIsConnected)
+		{
+			theOTResult = ::OTSndOrderlyDisconnect(theSocketStruct->mEndPointRef);
+			
+			theSocketStruct->mLocalEndIsConnected = false;
+			
+			//	Wait for other end to hang up too!
+			
+//			PrepareForAsyncOperation(theSocketStruct,T_ORDREL);
+//
+//			errCode = MyBusyWait(theSocketStruct,false,&theOTResult,&(theSocketStruct->mReceivedTOrdRel));
+		}
+		
+		
+		if (theOTResult != noErr)
+		{
+			::OTCloseProvider(theSocketStruct->mEndPointRef);
+		}
+		
+		else
+		{
+			theOTResult = ::OTCloseProvider(theSocketStruct->mEndPointRef);
+		}
+
+		theSocketStruct->mEndPointRef = kOTInvalidEndpointRef;
+		
+		errCode = theOTResult;
+	}
+
+
+	theSocketStruct->mIsInUse = false;
+
+	
+EXITPOINT:
+	
+	if (theSocketStruct != nil)
+	{
+		theSocketStruct->mLastError = noErr;
+		
+		CopyCStrToCStr("",theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+
+		if (errCode != noErr)
+		{
+			theSocketStruct->mLastError = errCode;
+			
+			CopyCStrToCStr(GetErrorMessage(),theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+		}
+	}
+
+	errno = errCode;
+		
+	return(errCode);
+}
+
+
+
+
+//	Receive some bytes
+
+int MacSocket_recv(const int inSocketNum,void *outBuff,int outBuffLength,const Boolean inBlock)
+{
+OSErr			errCode = noErr;
+int				totalBytesRead = 0;
+SocketStruct	*theSocketStruct = nil;
+
+	
+	SetErrorMessageAndBailIfNil(outBuff,"MacSocket_recv: Bad parameter, outBuff = nil");
+	
+	if (outBuffLength <= 0)
+	{
+		SetErrorMessageAndBail("MacSocket_recv: Bad parameter, outBuffLength <= 0");
+	}
+	
+	if (!SocketIndexIsValid(inSocketNum))
+	{
+		SetErrorMessageAndBail("MacSocket_recv: Invalid socket number specified");
+	}
+
+	theSocketStruct = &(sSockets[inSocketNum]);
+
+	if (!theSocketStruct->mLocalEndIsConnected)
+	{
+		SetErrorMessageAndBail("MacSocket_recv: Socket not connected");
+	}
+
+	if (theSocketStruct->mReceivedTOrdRel)
+	{
+		totalBytesRead = 0;
+		
+		goto EXITPOINT;
+	}
+
+	
+	PrepareForAsyncOperation(theSocketStruct,0);
+	
+	for (;;)
+	{
+	int			bytesRead;
+	OTResult	theOTResult;
+	
+	
+		theOTResult = ::OTRcv(theSocketStruct->mEndPointRef,(void *) ((unsigned long) outBuff + (unsigned long) totalBytesRead),outBuffLength - totalBytesRead,nil);
+		
+		if (theOTResult >= 0)
+		{
+			bytesRead = theOTResult;
+			
+#ifdef MACSOCKET_DEBUG
+	printf("MacSocket_recv: read %d bytes in part\n",bytesRead);
+#endif
+		}
+		
+		else if (theOTResult == kOTNoDataErr)
+		{
+			bytesRead = 0;
+		}
+		
+		else
+		{
+			SetErrorMessageAndLongIntAndBail("MacSocket_recv: Can't receive OT data, OTRcv() = ",theOTResult);
+		}
+		
+		
+		totalBytesRead += bytesRead;
+		
+		
+		if (totalBytesRead <= 0)
+		{
+			if (theSocketStruct->mReceivedTOrdRel)
+			{
+				break;
+			}
+			
+			//	This seems pretty stupid to me now.  Maybe I'll delete this blocking garbage.
+			
+			if (inBlock)
+			{
+				if (TimeoutElapsed(theSocketStruct))
+				{
+					SetErrorCodeAndMessageAndBail(kMacSocket_TimeoutErr,"MacSocket_recv: Receive operation timed-out");
+				}
+				
+				if (theSocketStruct->mIdleWaitCallback != nil)
+				{
+					theOTResult = (*(theSocketStruct->mIdleWaitCallback))(theSocketStruct->mUserRefPtr);
+					
+					SetErrorMessageAndBailIfError(theOTResult,"MacSocket_recv: User cancelled operation");
+				}
+				
+				continue;
+			}
+		}
+		
+		
+		break;
+	}
+	
+	errCode = noErr;
+
+
+#ifdef MACSOCKET_DEBUG
+	printf("MacSocket_recv: read %d bytes in total\n",totalBytesRead);
+#endif
+	
+	
+EXITPOINT:
+	
+	if (theSocketStruct != nil)
+	{
+		theSocketStruct->mLastError = noErr;
+		
+		CopyCStrToCStr("",theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+
+		if (errCode != noErr)
+		{
+			theSocketStruct->mLastError = errCode;
+			
+			CopyCStrToCStr(GetErrorMessage(),theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+		}
+	}
+
+	errno = errCode;
+	
+	return(totalBytesRead);
+}
+
+
+
+//	Send some bytes
+
+int MacSocket_send(const int inSocketNum,const void *inBuff,int inBuffLength)
+{
+OSErr			errCode = noErr;
+int				bytesSent = 0;
+SocketStruct	*theSocketStruct = nil;
+
+
+	SetErrorMessageAndBailIfNil(inBuff,"MacSocket_send: Bad parameter, inBuff = nil");
+	
+	if (inBuffLength <= 0)
+	{
+		SetErrorMessageAndBail("MacSocket_send: Bad parameter, inBuffLength <= 0");
+	}
+
+	if (!SocketIndexIsValid(inSocketNum))
+	{
+		SetErrorMessageAndBail("MacSocket_send: Invalid socket number specified");
+	}
+	
+
+	theSocketStruct = &(sSockets[inSocketNum]);
+	
+	if (!theSocketStruct->mLocalEndIsConnected)
+	{
+		SetErrorMessageAndBail("MacSocket_send: Socket not connected");
+	}
+
+
+OTResult		theOTResult;
+	
+
+	PrepareForAsyncOperation(theSocketStruct,0);
+
+	while (bytesSent < inBuffLength)
+	{
+		if (theSocketStruct->mIdleWaitCallback != nil)
+		{
+			theOTResult = (*(theSocketStruct->mIdleWaitCallback))(theSocketStruct->mUserRefPtr);
+			
+			SetErrorMessageAndBailIfError(theOTResult,"MacSocket_send: User cancelled");
+		}
+
+
+		theOTResult = ::OTSnd(theSocketStruct->mEndPointRef,(void *) ((unsigned long) inBuff + bytesSent),inBuffLength - bytesSent,0);
+		
+		if (theOTResult >= 0)
+		{
+			bytesSent += theOTResult;
+			
+			theOTResult = noErr;
+			
+			//	Reset timer....
+			
+			PrepareForAsyncOperation(theSocketStruct,0);
+		}
+		
+		if (theOTResult == kOTFlowErr)
+		{
+			if (TimeoutElapsed(theSocketStruct))
+			{
+				SetErrorCodeAndMessageAndBail(kMacSocket_TimeoutErr,"MacSocket_send: Send timed-out")
+			}
+
+			theOTResult = noErr;
+		}
+													
+		SetErrorMessageAndLongIntAndBailIfError(theOTResult,"MacSocket_send: Can't send OT data, OTSnd() = ",theOTResult);
+	}
+
+	
+	errCode = noErr;
+
+#ifdef MACSOCKET_DEBUG
+	printf("MacSocket_send: sent %d bytes\n",bytesSent);
+#endif
+	
+	
+EXITPOINT:
+	
+	if (theSocketStruct != nil)
+	{
+		theSocketStruct->mLastError = noErr;
+		
+		CopyCStrToCStr("",theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+
+		if (errCode != noErr)
+		{
+			theSocketStruct->mLastError = errCode;
+			
+			CopyCStrToCStr(GetErrorMessage(),theSocketStruct->mErrMessage,sizeof(theSocketStruct->mErrMessage));
+		}
+	}
+	
+	if (errCode != noErr)
+	{
+		::SysBeep(1);
+	}
+	
+	errno = errCode;
+	
+	return(bytesSent);
+}
+
+
+
+
+
+static OSStatus NegotiateIPReuseAddrOption(EndpointRef inEndpoint,const Boolean inEnableReuseIP)
+{
+OSStatus	errCode;
+UInt8		buf[kOTFourByteOptionSize];
+TOption*	theOTOption;
+TOptMgmt	theOTRequest;
+TOptMgmt	theOTResult;
+	
+
+	if (!OTIsSynchronous(inEndpoint))
+	{
+		SetErrorMessageAndBail("NegotiateIPReuseAddrOption: Open Transport endpoint is not synchronous");
+	}
+	
+	theOTRequest.opt.buf = buf;
+	theOTRequest.opt.len = sizeof(buf);
+	theOTRequest.flags = T_NEGOTIATE;
+
+	theOTResult.opt.buf = buf;
+	theOTResult.opt.maxlen = kOTFourByteOptionSize;
+
+
+	theOTOption = (TOption *) buf;
+	
+	theOTOption->level = INET_IP;
+	theOTOption->name = IP_REUSEADDR;
+	theOTOption->len = kOTFourByteOptionSize;
+	theOTOption->status = 0;
+	*((UInt32 *) (theOTOption->value)) = inEnableReuseIP;
+
+	errCode = ::OTOptionManagement(inEndpoint,&theOTRequest,&theOTResult);
+	
+	if (errCode == kOTNoError)
+	{
+		if (theOTOption->status != T_SUCCESS)
+		{
+			errCode = theOTOption->status;
+		}
+		
+		else
+		{
+			errCode = kOTNoError;
+		}
+	}
+				
+
+EXITPOINT:
+	
+	errno = errCode;
+	
+	return(errCode);
+}
+
+
+
+
+
+//	Some rough notes....
+
+
+
+//	OTAckSends(ep);
+//	OTAckSends(ep) // enable AckSend option
+//	......
+//	buf = OTAllocMem( nbytes); // Allocate nbytes of memory from OT
+//	OTSnd(ep, buf, nbytes, 0); // send a packet
+//	......
+//	NotifyProc( .... void* theParam) // Notifier Proc
+//	case T_MEMORYRELEASED: // process event
+//	OTFreeMem( theParam); // free up memory
+//	break;
+
+
+
+/*
+struct InetInterfaceInfo
+{
+	InetHost		fAddress;
+	InetHost		fNetmask;
+	InetHost		fBroadcastAddr;
+	InetHost		fDefaultGatewayAddr;
+	InetHost		fDNSAddr;
+	UInt16			fVersion;
+	UInt16			fHWAddrLen;
+	UInt8*			fHWAddr;
+	UInt32			fIfMTU;
+	UInt8*			fReservedPtrs[2];
+	InetDomainName	fDomainName;
+	UInt32			fIPSecondaryCount;
+	UInt8			fReserved[252];			
+};
+typedef struct InetInterfaceInfo InetInterfaceInfo;
+
+
+
+((InetAddress *) addr.buf)->fHost
+
+struct TBind
+{
+	TNetbuf	addr;
+	OTQLen	qlen;
+};
+
+typedef struct TBind	TBind;
+
+struct TNetbuf
+{
+	size_t	maxlen;
+	size_t	len;
+	UInt8*	buf;
+};
+
+typedef struct TNetbuf	TNetbuf;
+
+	
+	struct InetAddress
+{
+		OTAddressType	fAddressType;	// always AF_INET
+		InetPort		fPort;			// Port number 
+		InetHost		fHost;			// Host address in net byte order
+		UInt8			fUnused[8];		// Traditional unused bytes
+};
+typedef struct InetAddress InetAddress;
+*/
+
+
+
+/*
+static pascal void Notifier(void* context, OTEventCode event, OTResult result, void* cookie)
+{
+EPInfo* epi = (EPInfo*) context;
+
+	switch (event)
+	{
+		case T_LISTEN:
+		{
+			DoListenAccept();
+			return;
+		}
+		
+		case T_ACCEPTCOMPLETE:
+		{
+			if (result != kOTNoError)
+				DBAlert1("Notifier: T_ACCEPTCOMPLETE - result %d",result);
+			return;
+		}
+		
+		case T_PASSCON:
+		{
+			if (result != kOTNoError)
+			{
+				DBAlert1("Notifier: T_PASSCON result %d", result);
+				return;
+			}
+
+			OTAtomicAdd32(1, &gCntrConnections);
+			OTAtomicAdd32(1, &gCntrTotalConnections);
+			OTAtomicAdd32(1, &gCntrIntervalConnects);
+			
+			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) != 0 )
+			{
+				ReadData(epi);
+			}
+			
+			return;
+		}
+		
+		case T_DATA:
+		{
+			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) != 0 )
+			{
+				ReadData(epi);
+			}
+			
+			return;
+		}
+		
+		case T_GODATA:
+		{
+			SendData(epi);
+			return;
+		}
+		
+		case T_DISCONNECT:
+		{
+			DoRcvDisconnect(epi);
+			return;
+		}
+		
+		case T_DISCONNECTCOMPLETE:
+		{
+			if (result != kOTNoError)
+				DBAlert1("Notifier: T_DISCONNECT_COMPLETE result %d",result);
+				
+			return;
+		}
+		
+		case T_MEMORYRELEASED:
+		{
+			OTAtomicAdd32(-1, &epi->outstandingSends);
+			return;
+		}
+		
+		default:
+		{
+			DBAlert1("Notifier: unknown event <%x>", event);
+			return;
+		}
+	}
+}
+*/
diff -Nur libressl-3.1.0/MacOS/GetHTTPS.src/MacSocket.h libressl-3.1.0-apple/MacOS/GetHTTPS.src/MacSocket.h
--- libressl-3.1.0/MacOS/GetHTTPS.src/MacSocket.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/GetHTTPS.src/MacSocket.h	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,103 @@
+#pragma once
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+enum
+{
+	kMacSocket_TimeoutErr = -2
+};
+
+
+//	Since MacSocket does busy waiting, I do a callback while waiting
+
+typedef OSErr (*MacSocket_IdleWaitCallback)(void *);
+
+
+//	Call this before anything else!
+
+OSErr MacSocket_Startup(void);
+
+
+//	Call this to cleanup before quitting
+
+OSErr MacSocket_Shutdown(void);
+
+
+//	Call this to allocate a "socket" (reference number is returned in outSocketNum)
+//	Note that inDoThreadSwitching is pretty much irrelevant right now, since I ignore it
+//	The inTimeoutTicks parameter is applied during reads/writes of data
+//	The inIdleWaitCallback parameter specifies a callback which is called during busy-waiting periods
+//	The inUserRefPtr parameter is passed back to the idle-wait callback
+
+OSErr MacSocket_socket(int *outSocketNum,const Boolean inDoThreadSwitching,const long inTimeoutTicks,MacSocket_IdleWaitCallback inIdleWaitCallback,void *inUserRefPtr);
+
+
+//	Call this to connect to an IP/DNS address
+//	Note that inTargetAddressAndPort is in "IP:port" format-- e.g. 10.1.1.1:123
+
+OSErr MacSocket_connect(const int inSocketNum,char *inTargetAddressAndPort);
+
+
+//	Call this to listen on a port
+//	Since this a low-performance implementation, I allow a maximum of 1 (one!) incoming request when I listen
+
+OSErr MacSocket_listen(const int inSocketNum,const int inPortNum);
+
+
+//	Call this to close a socket
+
+OSErr MacSocket_close(const int inSocketNum);
+
+
+//	Call this to receive data on a socket
+//	Most parameters' purpose are obvious-- except maybe "inBlock" which controls whether I wait for data or return immediately
+
+int MacSocket_recv(const int inSocketNum,void *outBuff,int outBuffLength,const Boolean inBlock);
+
+
+//	Call this to send data on a socket
+
+int MacSocket_send(const int inSocketNum,const void *inBuff,int inBuffLength);
+
+
+//	If zero bytes were read in a call to MacSocket_recv(), it may be that the remote end has done a half-close
+//	This function will let you check whether that's true or not
+
+Boolean MacSocket_RemoteEndIsClosing(const int inSocketNum);
+
+
+//	Call this to see if the listen has completed after a call to MacSocket_listen()
+
+Boolean MacSocket_ListenCompleted(const int inSocketNum);
+
+
+//	These really aren't very useful anymore
+
+Boolean MacSocket_LocalEndIsOpen(const int inSocketNum);
+Boolean MacSocket_RemoteEndIsOpen(const int inSocketNum);
+
+
+//	You may wish to change the userRefPtr for a socket callback-- use this to do it
+
+void MacSocket_SetUserRefPtr(const int inSocketNum,void *inNewRefPtr);
+
+
+//	Call these to get the socket's IP:port descriptor
+
+void MacSocket_GetLocalIPAndPort(const int inSocketNum,char *outIPAndPort,const int inIPAndPortLength);
+void MacSocket_GetRemoteIPAndPort(const int inSocketNum,char *outIPAndPort,const int inIPAndPortLength);
+
+
+//	Call this to get error info from a socket
+
+void MacSocket_GetSocketErrorInfo(const int inSocketNum,int *outSocketErrCode,char *outSocketErrString,const int inSocketErrStringMaxLength);
+
+
+#ifdef __cplusplus
+}
+#endif
diff -Nur libressl-3.1.0/MacOS/Randomizer.cpp libressl-3.1.0-apple/MacOS/Randomizer.cpp
--- libressl-3.1.0/MacOS/Randomizer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/Randomizer.cpp	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,476 @@
+/* 
+------- Strong random data generation on a Macintosh (pre - OS X) ------
+		
+--	GENERAL: We aim to generate unpredictable bits without explicit
+	user interaction. A general review of the problem may be found
+	in RFC 1750, "Randomness Recommendations for Security", and some
+	more discussion, of general and Mac-specific issues has appeared
+	in "Using and Creating Cryptographic- Quality Random Numbers" by
+	Jon Callas (www.merrymeet.com/jon/usingrandom.html).
+
+	The data and entropy estimates provided below are based on my
+	limited experimentation and estimates, rather than by any
+	rigorous study, and the entropy estimates tend to be optimistic.
+	They should not be considered absolute.
+
+	Some of the information being collected may be correlated in
+	subtle ways. That includes mouse positions, timings, and disk
+	size measurements. Some obvious correlations will be eliminated
+	by the programmer, but other, weaker ones may remain. The
+	reliability of the code depends on such correlations being
+	poorly understood, both by us and by potential interceptors.
+
+	This package has been planned to be used with OpenSSL, v. 0.9.5.
+	It requires the OpenSSL function RAND_add. 
+
+--	OTHER WORK: Some source code and other details have been
+	published elsewhere, but I haven't found any to be satisfactory
+	for the Mac per se:
+
+	* The Linux random number generator (by Theodore Ts'o, in
+	  drivers/char/random.c), is a carefully designed open-source
+	  crypto random number package. It collects data from a variety
+	  of sources, including mouse, keyboard and other interrupts.
+	  One nice feature is that it explicitly estimates the entropy
+	  of the data it collects. Some of its features (e.g. interrupt
+	  timing) cannot be reliably exported to the Mac without using
+	  undocumented APIs.
+
+	* Truerand by Don P. Mitchell and Matt Blaze uses variations
+	  between different timing mechanisms on the same system. This
+	  has not been tested on the Mac, but requires preemptive
+	  multitasking, and is hardware-dependent, and can't be relied
+	  on to work well if only one oscillator is present.
+
+	* Cryptlib's RNG for the Mac (RNDMAC.C by Peter Gutmann),
+	  gathers a lot of information about the machine and system
+	  environment. Unfortunately, much of it is constant from one
+	  startup to the next. In other words, the random seed could be
+	  the same from one day to the next. Some of the APIs are
+	  hardware-dependent, and not all are compatible with Carbon (OS
+	  X). Incidentally, the EGD library is based on the UNIX entropy
+	  gathering methods in cryptlib, and isn't suitable for MacOS
+	  either.
+
+	* Mozilla (and perhaps earlier versions of Netscape) uses the
+	  time of day (in seconds) and an uninitialized local variable
+	  to seed the random number generator. The time of day is known
+	  to an outside interceptor (to within the accuracy of the
+	  system clock). The uninitialized variable could easily be
+	  identical between subsequent launches of an application, if it
+	  is reached through the same path.
+
+	* OpenSSL provides the function RAND_screen(), by G. van
+	  Oosten, which hashes the contents of the screen to generate a
+	  seed. This is not useful for an extension or for an
+	  application which launches at startup time, since the screen
+	  is likely to look identical from one launch to the next. This
+	  method is also rather slow.
+
+	* Using variations in disk drive seek times has been proposed
+	  (Davis, Ihaka and Fenstermacher, world.std.com/~dtd/;
+	  Jakobsson, Shriver, Hillyer and Juels,
+	  www.bell-labs.com/user/shriver/random.html). These variations
+	  appear to be due to air turbulence inside the disk drive
+	  mechanism, and are very strongly unpredictable. Unfortunately
+	  this technique is slow, and some implementations of it may be
+	  patented (see Shriver's page above.) It of course cannot be
+	  used with a RAM disk.
+
+--	TIMING: On the 601 PowerPC the time base register is guaranteed
+	to change at least once every 10 addi instructions, i.e. 10
+	cycles. On a 60 MHz machine (slowest PowerPC) this translates to
+	a resolution of 1/6 usec. Newer machines seem to be using a 10
+	cycle resolution as well.
+	
+	For 68K Macs, the Microseconds() call may be used. See Develop
+	issue 29 on the Apple developer site
+	(developer.apple.com/dev/techsupport/develop/issue29/minow.html)
+	for information on its accuracy and resolution. The code below
+	has been tested only on PowerPC based machines.
+
+	The time from machine startup to the launch of an application in
+	the startup folder has a variance of about 1.6 msec on a new G4
+	machine with a defragmented and optimized disk, most extensions
+	off and no icons on the desktop. This can be reasonably taken as
+	a lower bound on the variance. Most of this variation is likely
+	due to disk seek time variability. The distribution of startup
+	times is probably not entirely even or uncorrelated. This needs
+	to be investigated, but I am guessing that it not a majpor
+	problem. Entropy = log2 (1600/0.166) ~= 13 bits on a 60 MHz
+	machine, ~16 bits for a 450 MHz machine.
+
+	User-launched application startup times will have a variance of
+	a second or more relative to machine startup time. Entropy >~22
+	bits.
+
+	Machine startup time is available with a 1-second resolution. It
+	is predictable to no better a minute or two, in the case of
+	people who show up punctually to work at the same time and
+	immediately start their computer. Using the scheduled startup
+	feature (when available) will cause the machine to start up at
+	the same time every day, making the value predictable. Entropy
+	>~7 bits, or 0 bits with scheduled startup.
+
+	The time of day is of course known to an outsider and thus has 0
+	entropy if the system clock is regularly calibrated.
+
+--	KEY TIMING: A  very fast typist (120 wpm) will have a typical
+	inter-key timing interval of 100 msec. We can assume a variance
+	of no less than 2 msec -- maybe. Do good typists have a constant
+	rhythm, like drummers? Since what we measure is not the
+	key-generated interrupt but the time at which the key event was
+	taken off the event queue, our resolution is roughly the time
+	between process switches, at best 1 tick (17 msec). I  therefore
+	consider this technique questionable and not very useful for
+	obtaining high entropy data on the Mac.
+
+--	MOUSE POSITION AND TIMING: The high bits of the mouse position
+	are far from arbitrary, since the mouse tends to stay in a few
+	limited areas of the screen. I am guessing that the position of
+	the mouse is arbitrary within a 6 pixel square. Since the mouse
+	stays still for long periods of time, it should be sampled only
+	after it was moved, to avoid correlated data. This gives an
+	entropy of log2(6*6) ~= 5 bits per measurement.
+
+	The time during which the mouse stays still can vary from zero
+	to, say, 5 seconds (occasionally longer). If the still time is
+	measured by sampling the mouse during null events, and null
+	events are received once per tick, its resolution is 1/60th of a
+	second, giving an entropy of log2 (60*5) ~= 8 bits per
+	measurement. Since the distribution of still times is uneven,
+	this estimate is on the high side.
+
+	For simplicity and compatibility across system versions, the
+	mouse is to be sampled explicitly (e.g. in the event loop),
+	rather than in a time manager task.
+
+--	STARTUP DISK TOTAL FILE SIZE: Varies typically by at least 20k
+	from one startup to the next, with 'minimal' computer use. Won't
+	vary at all if machine is started again immediately after
+	startup (unless virtual memory is on), but any application which
+	uses the web and caches information to disk is likely to cause
+	this much variation or more. The variation is probably not
+	random, but I don't know in what way. File sizes tend to be
+	divisible by 4 bytes since file format fields are often
+	long-aligned. Entropy > log2 (20000/4) ~= 12 bits.
+	
+--	STARTUP DISK FIRST AVAILABLE ALLOCATION BLOCK: As the volume
+	gets fragmented this could be anywhere in principle. In a
+	perfectly unfragmented volume this will be strongly correlated
+	with the total file size on the disk. With more fragmentation
+	comes less certainty. I took the variation in this value to be
+	1/8 of the total file size on the volume.
+
+--	SYSTEM REQUIREMENTS: The code here requires System 7.0 and above
+	(for Gestalt and Microseconds calls). All the calls used are
+	Carbon-compatible.
+*/
+
+/*------------------------------ Includes ----------------------------*/
+
+#include "Randomizer.h"
+
+// Mac OS API
+#include <Files.h>
+#include <Folders.h>
+#include <Events.h>
+#include <Processes.h>
+#include <Gestalt.h>
+#include <Resources.h>
+#include <LowMem.h>
+
+// Standard C library
+#include <stdlib.h>
+#include <math.h>
+
+/*---------------------- Function declarations -----------------------*/
+
+// declared in OpenSSL/crypto/rand/rand.h
+extern "C" void RAND_add (const void *buf, int num, double entropy);
+
+unsigned long GetPPCTimer (bool is601);	// Make it global if needed
+					// elsewhere
+
+/*---------------------------- Constants -----------------------------*/
+
+#define kMouseResolution 6		// Mouse position has to differ
+					// from the last one by this
+					// much to be entered
+#define kMousePositionEntropy 5.16	// log2 (kMouseResolution**2)
+#define kTypicalMouseIdleTicks 300.0	// I am guessing that a typical
+					// amount of time between mouse
+					// moves is 5 seconds
+#define kVolumeBytesEntropy 12.0	// about log2 (20000/4),
+					// assuming a variation of 20K
+					// in total file size and
+					// long-aligned file formats.
+#define kApplicationUpTimeEntropy 6.0	// Variance > 1 second, uptime
+					// in ticks  
+#define kSysStartupEntropy 7.0		// Entropy for machine startup
+					// time
+
+
+/*------------------------ Function definitions ----------------------*/
+
+CRandomizer::CRandomizer (void)
+{
+	long	result;
+	
+	mSupportsLargeVolumes =
+		(Gestalt(gestaltFSAttr, &result) == noErr) &&
+		((result & (1L << gestaltFSSupports2TBVols)) != 0);
+	
+	if (Gestalt (gestaltNativeCPUtype, &result) != noErr)
+	{
+		mIsPowerPC = false;
+		mIs601 = false;
+	}
+	else
+	{
+		mIs601 = (result == gestaltCPU601);
+		mIsPowerPC = (result >= gestaltCPU601);
+	}
+	mLastMouse.h = mLastMouse.v = -10;	// First mouse will
+						// always be recorded
+	mLastPeriodicTicks = TickCount();
+	GetTimeBaseResolution ();
+	
+	// Add initial entropy
+	AddTimeSinceMachineStartup ();
+	AddAbsoluteSystemStartupTime ();
+	AddStartupVolumeInfo ();
+	AddFiller ();
+}
+
+void CRandomizer::PeriodicAction (void)
+{
+	AddCurrentMouse ();
+	AddNow (0.0);	// Should have a better entropy estimate here
+	mLastPeriodicTicks = TickCount();
+}
+
+/*------------------------- Private Methods --------------------------*/
+
+void CRandomizer::AddCurrentMouse (void)
+{
+	Point mouseLoc;
+	unsigned long lastCheck;	// Ticks since mouse was last
+					// sampled
+
+#if TARGET_API_MAC_CARBON
+	GetGlobalMouse (&mouseLoc);
+#else
+	mouseLoc = LMGetMouseLocation();
+#endif
+	
+	if (labs (mLastMouse.h - mouseLoc.h) > kMouseResolution/2 &&
+	    labs (mLastMouse.v - mouseLoc.v) > kMouseResolution/2)
+		AddBytes (&mouseLoc, sizeof (mouseLoc),
+				kMousePositionEntropy);
+	
+	if (mLastMouse.h == mouseLoc.h && mLastMouse.v == mouseLoc.v)
+		mMouseStill ++;
+	else
+	{
+		double entropy;
+		
+		// Mouse has moved. Add the number of measurements for
+		// which it's been still. If the resolution is too
+		// coarse, assume the entropy is 0.
+
+		lastCheck = TickCount() - mLastPeriodicTicks;
+		if (lastCheck <= 0)
+			lastCheck = 1;
+		entropy = log2l
+			(kTypicalMouseIdleTicks/(double)lastCheck);
+		if (entropy < 0.0)
+			entropy = 0.0;
+		AddBytes (&mMouseStill, sizeof (mMouseStill), entropy);
+		mMouseStill = 0;
+	}
+	mLastMouse = mouseLoc;
+}
+
+void CRandomizer::AddAbsoluteSystemStartupTime (void)
+{
+	unsigned long	now;		// Time in seconds since
+					// 1/1/1904
+	GetDateTime (&now);
+	now -= TickCount() / 60;	// Time in ticks since machine
+					// startup
+	AddBytes (&now, sizeof (now), kSysStartupEntropy);
+}
+
+void CRandomizer::AddTimeSinceMachineStartup (void)
+{
+	AddNow (1.5);			// Uncertainty in app startup
+					// time is > 1.5 msec (for
+					// automated app startup).
+}
+
+void CRandomizer::AddAppRunningTime (void)
+{
+	ProcessSerialNumber PSN;
+	ProcessInfoRec		ProcessInfo;
+	
+	ProcessInfo.processInfoLength = sizeof (ProcessInfoRec);
+	ProcessInfo.processName = nil;
+	ProcessInfo.processAppSpec = nil;
+	
+	GetCurrentProcess (&PSN);
+	GetProcessInformation (&PSN, &ProcessInfo);
+
+	// Now add the amount of time in ticks that the current process
+	// has been active
+
+	AddBytes (&ProcessInfo, sizeof (ProcessInfoRec),
+			kApplicationUpTimeEntropy);
+}
+
+void CRandomizer::AddStartupVolumeInfo (void)
+{
+	short			vRefNum;
+	long			dirID;
+	XVolumeParam	pb;
+	OSErr			err;
+	
+	if (!mSupportsLargeVolumes)
+		return;
+		
+	FindFolder (kOnSystemDisk, kSystemFolderType, kDontCreateFolder,
+			&vRefNum, &dirID);
+	pb.ioVRefNum = vRefNum;
+	pb.ioCompletion = 0;
+	pb.ioNamePtr = 0;
+	pb.ioVolIndex = 0;
+	err = PBXGetVolInfoSync (&pb);
+	if (err != noErr)
+		return;
+		
+	// Base the entropy on the amount of space used on the disk and
+	// on the next available allocation block. A lot else might be
+	// unpredictable, so might as well toss the whole block in. See
+	// comments for entropy estimate justifications.
+
+	AddBytes (&pb, sizeof (pb),
+		kVolumeBytesEntropy +
+		log2l (((pb.ioVTotalBytes.hi - pb.ioVFreeBytes.hi)
+				* 4294967296.0D +
+			(pb.ioVTotalBytes.lo - pb.ioVFreeBytes.lo))
+				/ pb.ioVAlBlkSiz - 3.0));
+}
+
+/*
+	On a typical startup CRandomizer will come up with about 60
+	bits of good, unpredictable data. Assuming no more input will
+	be available, we'll need some more lower-quality data to give
+	OpenSSL the 128 bits of entropy it desires. AddFiller adds some
+	relatively predictable data into the soup.
+*/
+
+void CRandomizer::AddFiller (void)
+{
+	struct
+	{
+		ProcessSerialNumber psn;	// Front process serial
+						// number
+		RGBColor	hiliteRGBValue;	// User-selected
+						// highlight color
+		long		processCount;	// Number of active
+						// processes
+		long		cpuSpeed;	// Processor speed
+		long		totalMemory;	// Total logical memory
+						// (incl. virtual one)
+		long		systemVersion;	// OS version
+		short		resFile;	// Current resource file
+	} data;
+	
+	GetNextProcess ((ProcessSerialNumber*) kNoProcess);
+	while (GetNextProcess (&data.psn) == noErr)
+		data.processCount++;
+	GetFrontProcess (&data.psn);
+	LMGetHiliteRGB (&data.hiliteRGBValue);
+	Gestalt (gestaltProcClkSpeed, &data.cpuSpeed);
+	Gestalt (gestaltLogicalRAMSize, &data.totalMemory);
+	Gestalt (gestaltSystemVersion, &data.systemVersion);
+	data.resFile = CurResFile ();
+	
+	// Here we pretend to feed the PRNG completely random data. This
+	// is of course false, as much of the above data is predictable
+	// by an outsider. At this point we don't have any more
+	// randomness to add, but with OpenSSL we must have a 128 bit
+	// seed before we can start. We just add what we can, without a
+	// real entropy estimate, and hope for the best.
+
+	AddBytes (&data, sizeof(data), 8.0 * sizeof(data));
+	AddCurrentMouse ();
+	AddNow (1.0);
+}
+
+//-------------------  LOW LEVEL ---------------------
+
+void CRandomizer::AddBytes (void *data, long size, double entropy)
+{
+	RAND_add (data, size, entropy * 0.125);	// Convert entropy bits
+						// to bytes
+}
+
+void CRandomizer::AddNow (double millisecondUncertainty)
+{
+	long time = SysTimer();
+	AddBytes (&time, sizeof (time), log2l (millisecondUncertainty *
+			mTimebaseTicksPerMillisec));
+}
+
+//----------------- TIMING SUPPORT ------------------
+
+void CRandomizer::GetTimeBaseResolution (void)
+{	
+#ifdef __powerc
+	long speed;
+	
+	// gestaltProcClkSpeed available on System 7.5.2 and above
+	if (Gestalt (gestaltProcClkSpeed, &speed) != noErr)
+		// Only PowerPCs running pre-7.5.2 are 60-80 MHz
+		// machines.
+		mTimebaseTicksPerMillisec =  6000.0D;
+	// Assume 10 cycles per clock update, as in 601 spec. Seems true
+	// for later chips as well.
+	mTimebaseTicksPerMillisec = speed / 1.0e4D;
+#else
+	// 68K VIA-based machines (see Develop Magazine no. 29)
+	mTimebaseTicksPerMillisec = 783.360D;
+#endif
+}
+
+unsigned long CRandomizer::SysTimer (void)	// returns the lower 32
+						// bit of the chip timer
+{
+#ifdef __powerc
+	return GetPPCTimer (mIs601);
+#else
+	UnsignedWide usec;
+	Microseconds (&usec);
+	return usec.lo;
+#endif
+}
+
+#ifdef __powerc
+// The timebase is available through mfspr on 601, mftb on later chips.
+// Motorola recommends that an 601 implementation map mftb to mfspr
+// through an exception, but I haven't tested to see if MacOS actually
+// does this. We only sample the lower 32 bits of the timer (i.e. a
+// few minutes of resolution)
+
+asm unsigned long GetPPCTimer (register bool is601)
+{
+	cmplwi	is601, 0	// Check if 601
+	bne	_601		// if non-zero goto _601
+	mftb  	r3		// Available on 603 and later.
+	blr			// return with result in r3
+_601:
+	mfspr r3, spr5  	// Available on 601 only.
+				// blr inserted automatically
+}
+#endif
diff -Nur libressl-3.1.0/MacOS/Randomizer.h libressl-3.1.0-apple/MacOS/Randomizer.h
--- libressl-3.1.0/MacOS/Randomizer.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/Randomizer.h	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,43 @@
+
+//	Gathers unpredictable system data to be used for generating
+//	random bits
+
+#include <MacTypes.h>
+
+class CRandomizer
+{
+public:
+	CRandomizer (void);
+	void PeriodicAction (void);
+	
+private:
+
+	// Private calls
+
+	void		AddTimeSinceMachineStartup (void);
+	void		AddAbsoluteSystemStartupTime (void);
+	void		AddAppRunningTime (void);
+	void		AddStartupVolumeInfo (void);
+	void		AddFiller (void);
+
+	void		AddCurrentMouse (void);
+	void		AddNow (double millisecondUncertainty);
+	void		AddBytes (void *data, long size, double entropy);
+	
+	void		GetTimeBaseResolution (void);
+	unsigned long	SysTimer (void);
+
+	// System Info	
+	bool		mSupportsLargeVolumes;
+	bool		mIsPowerPC;
+	bool		mIs601;
+	
+	// Time info
+	double		mTimebaseTicksPerMillisec;
+	unsigned long	mLastPeriodicTicks;
+	
+	// Mouse info
+	long		mSamplePeriod;
+	Point		mLastMouse;
+	long		mMouseStill;
+};
diff -Nur libressl-3.1.0/MacOS/TODO libressl-3.1.0-apple/MacOS/TODO
--- libressl-3.1.0/MacOS/TODO	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/TODO	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,18 @@
+-------------------------------------------------------------------
+Verify server certificate
+-------------------------------------------------------------------
+Currently omitted from the project:
+
+	crypto/tmdiff.c
+	crypto/bio/bss_conn.c
+	crypto/bio/b_sock.c
+	crypto/bio/bss_acpt.c
+	crypto/bio/bss_log.h
+
+-------------------------------------------------------------------
+Build libraries to link with...
+-------------------------------------------------------------------
+Port openssl application.
+-------------------------------------------------------------------
+BN optimizations (currently PPC version is compiled with BN_LLONG)
+-------------------------------------------------------------------
diff -Nur libressl-3.1.0/MacOS/_MWERKS_GUSI_prefix.h libressl-3.1.0-apple/MacOS/_MWERKS_GUSI_prefix.h
--- libressl-3.1.0/MacOS/_MWERKS_GUSI_prefix.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/_MWERKS_GUSI_prefix.h	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,9 @@
+#include <MacHeaders.h>
+#define B_ENDIAN
+#ifdef __POWERPC__
+#pragma longlong on
+#endif
+#if 1
+#define MAC_OS_GUSI_SOURCE
+#endif
+#define MONOLITH
diff -Nur libressl-3.1.0/MacOS/_MWERKS_prefix.h libressl-3.1.0-apple/MacOS/_MWERKS_prefix.h
--- libressl-3.1.0/MacOS/_MWERKS_prefix.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/_MWERKS_prefix.h	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,9 @@
+#include <MacHeaders.h>
+#define B_ENDIAN
+#ifdef __POWERPC__
+#pragma longlong on
+#endif
+#if 0
+#define MAC_OS_GUSI_SOURCE
+#endif
+#define MONOLITH
diff -Nur libressl-3.1.0/MacOS/buildinf.h libressl-3.1.0-apple/MacOS/buildinf.h
--- libressl-3.1.0/MacOS/buildinf.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/buildinf.h	2020-04-21 08:51:59.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef MK1MF_BUILD
+#  define DATE      __DATE__
+# if   defined(__i386) || defined(__i386__) 
+#  define CFLAGS    "-arch i386 -fmessage-length=0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mmacosx-version-min=10.6"
+#  define PLATFORM  "darwin-i386-llvm"
+# elif defined(__x86_64) || defined(__x86_64__)
+#  define CFLAGS    "-arch x86_64 -fmessage-length=0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DMD32_REG_T=int -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mmacosx-version-min=10.6"
+#  define PLATFORM  "darwin64-x86_64-llvm"
+# elif defined(__powerpc) || defined(__ppc__)
+#  define CFLAGS    "-arch ppc -fmessage-length=0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DB_ENDIAN -DDSO_DLFCN -DHAVE_DLFCN_H -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mtune=G4 -mmacosx-version-min=10.6"
+#  define PLATFORM  "darwin-ppc-llvm"
+# endif
+#endif
diff -Nur libressl-3.1.0/MacOS/mklinks.as.hqx libressl-3.1.0-apple/MacOS/mklinks.as.hqx
--- libressl-3.1.0/MacOS/mklinks.as.hqx	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/mklinks.as.hqx	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,820 @@
+(This file must be converted with BinHex 4.0)
+
+:#QeVE'PZDh-ZBA-!39"36'&`E(3J!!!!!!!!!*LiI6m!!!!!!3!!!*G#!!#@3J!
+!!AChFQPd!!!!K3)"!3m(Fh9`F'pbG!!!!)B#!3%$"(0eFQ8!!!#(!J-%"!3("3C
+cGfPdBfJ!!!#)!J%"#39cH@jMD!!!!)N#"J%$!`-&"3-'FhPcG'9Y!!!!LJ)&"3)
+%!J8("!-#!`4dB@*X!!!!L`))!3-$!`-$!`-$"(4PE'`!!!#-!J)"#38$G'KP!!!
+!M3))(J)@!Ki#!J))!K)#!`)B!Kd%G'KPE3!!!)i#!J%&#`4dD'9j!!!!M`)#!J)
+#$3TdD(*[G@GSEh9d!!!!N!!#!3%&"(4TCQB!!!#4!J%"!`4dD@eP!!!!NJ)"!JS
+#!h4T!!!!'N!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!H!!!!!!!#!!!!!!
+!!!!!!!!!!!!!rrrrr`!!!$3!!!!N!!!!!#"[!!5JAb"[!!5K++!M6R9$9'mJFR9
+Z)(4SDA-JFf0bDA"d)'&`F'aTBf&dD@pZ,#"jEh8JEA9cG#"QDA*cG#"TER0dB@a
+X)%&`F'aP8f0bDA"d,J!!!)C8D'Pc)(0MFQP`G#"MFQ9KG'9c)#iZ,fPZBfaeC'8
+[Eh"PER0cE#"KEQ3JCQPXE(-JDA3JGfPdD#"ZC@0PFh0KFRNJB@aTBA0PFbi0$8P
+d)'eTCfKd)(4KDf8JB5"hD'PXC5"dEb"MEfe`E'9dC5"cEb"`E'9KFf8JBQ8JF'&
+dD@9ZG$SY+3!!!#S!!J!!!!!!$3!+!"!!!!!-!!!!!!!!!!!!63!0!!S!%!%!!!`
+!!!!!!!!!!!!B!!!!+!!!!!!!!!!)!!!!)!#N2c`!!DR`!!!!l!!!!!&19[ri,`0
+f!#m$-$bKVDG'*KmY52ri,`-`2+LITdBQ(b!ZrrLa`'FJ,`-J2'0`ER4"l[rm)NL
+KV5+)*Kp+3'B)5Ulrr'F#GJ%3!bBZrr41ANje6PB!!#m-@Bm[2%j29%Nr2!#!U"m
+SAb!-CJK`!cm!UFKJ+#m-UC)J9#!)d+J!'#&!!"JJ9#!)d+J!(#&!!"a9Mbm8)&q
+JAMk!9%mSE[rm6Pj1G8j@!!![$%kkre4+!'FU@Bm[2'&`E(3[2(0MF(4`)DJU+&m
+J$'F5@Bm[$#mm!!!!!A!!U#UTp&K26VVrG#KZrra1ANje!!!!('&`E(3!!!!"4P*
+&4J!!!!!!J%P$6L-!!!!!!*B!!!!"!!!!!!G"8&"-!!!!!!!"!!!"!!!!!S!!!!4
+!!!"i)!!!K"!!!3))!!)#"!!%"!)!#!J"!"!8!)!J)J"!3%%!)2#!J"#*!%!)KJ!
+J")3!)!*!!"!")!!3!K!!%!3)!"!)"!!J%!)!3#!"!)"!!S%!J!5#!3!)4!)!#%J
+%!!KB#!!%C"!!!m)J!!!"3!!!!)!!!!%!!!!$J!!!"m!!!(rJ!!$rm!!"rrJ!!rr
+m!!IrrJ!2rrm!(rrrJ$rrrm"rrrrJrrrrm2rrrrMrrrrmrrrrrRrrrrmrrrrq(rr
+rr!rrrrJ(rrr`!rrri!(rrm!$rrq!"rrr!!rrrJ!2rr`!$rri!!IRm!!$`q!!!!(
+!!!!!J!!!!!)!!!!!!!!!!!m!!!!!!!!!!!!!!!!!!!$`m!!!!!!!!!!!!!!!!!!
+2!!m!!!!!!!!!!!!!!!rrm!!!m!!!!!!!!!!!!!$`c0m!!!m!!!!!!!!!!!!2!!c
+-m!!!m!!!!!!!!!!!m!$-cI!!!!m!!!!!!!!!$`!-c0m!!!!!m!!!!!!!!2!!c-h
+`!!!!!!m!!!!!!!m!$-cIh`!!!!!!m!!!!!$`!-c0rGh`!!!!!!m!!!!2!!c-hph
+-h`!!!!!!m!!!rrr-cIhF`-h`!!!!!!m!!2lFr0rGc!`-h`!!!!!!m!$pc-rph-$
+!`-h`!!!!!!m!r-`2cF`-$!!-r3!!!!!!m!m!`-c!`-!!$0m!!!!!$-m!m!`-$!`
+!!-cI!!!!!-c`!!m!`-$!!!`-h`!!!!c2!!!!m!`-!!$!c0m!!!$-m!!!!!m!`!!
+-$-hm!!!-c`!!!!!!m!!!`-cIc!!!c2!!!!!!!!m!$!c0r-`!$-m!!!!!!!$pm-$
+-hmc!!-c`!!!!!!!2hI`-cIc-!!c2!!!!!!!!rGc2c0r-`!$-m!!!!!!!!2h-cmh
+mc!!-c`!!!!!!!!$mc!rIr-!!c2!!!!!!!!!!$m$2m!r-$-m!!!!!!!!!!!$rr`!
+!r-c`!!!!!!!!!!!!!!!!!!r2!!!!!!!!!!!!!!!!!!!!m!!!!!!!!!!!!!"!!B!
+13"%J)4"##18%Q)+3!%&!)5!L%%3BL#83*L!G3!#!!B!2`"rJ2r"rq2rmrrlrrhr
+r2riIr"ri2r!ri"h!!)!!!!#!!!!!$r!!!!!!!2r`$`!!!!!2$!m!m!!!!2$!c`!
+2!!!2$!c`!!$`!2r`cpm!!!m!rGrpc2!!!2$p$p`-c`!!$`m!`-$0m!$2!2!-$-h
+`$2!!$`$-hm$2!!!2m-hm$2!!!2h2hm$2!!!!r-rm$2!!!!!2r`r2!!!!!!!!!2!
+!!!!!!!#D8f0bDA"d)%&`F'aTBf&dD@pZ$3e8D'Pc)(0MFQP`G#"MFQ9KG'9c)#i
+Z,fPZBfaeC'8[Eh"PER0cE#"KEQ3JCQPXE(-JDA3JGfPdD#"ZC@0PFh0KFRNJB@a
+TBA0PFbi0$8Pd)'eTCfKd)(4KDf8JB5"hD'PXC5"dEb"MEfe`E'9dC5"cEb"`E'9
+KFf8JBQ8JF'&dD@9ZG$SY+3!!!")!!J!!!!!!!!!!!!%!"J!'%iN!!!!+@1!!!b!
+!!!-J!!!!!"3!+`!(!Cm#@!!V!!F"f!*B!!!!!3!!M`C'BA0N98&6)$%Z-6!a,M%
+`$J!!!!32rrm!!3!#!!-"rrm!!!d!!3!"D`!!!!!!!!!%!J!%!!)!"3!'$3!&!!*
+X!!)!!!U`!!IrrJd!"`!#6`!!!!!+X!!)!!N0!!J!!@X!!!!%#Um!#J)!#J!#!!X
+!$!d!#`!#E!!#!!3!"2rprr`"rrd!!!(rr!!!!J!-!!)!$3!1$3!0!!*X!!%!"!!
+%rrX!$`(rq`!!$!!2!&N!8b"(CA3JF'&dD#"dEb"dD'Pc)%&`F'aP8f0bDA"d)'&
+`F'aPG$XJGA0P)'Pd)(4[)'C[FQdJG'KP)("KG'JJG'mJG'KP)'PZBfaeC'8JCQp
+XC'9b!!)!!!)!$J!#!"!!%3d!%!!#E!!"!!3!"2rk!")"rrS!!!`!%J!Q!#!JB@j
+N)(4SC5"[G'KPFL"bC@aPGQ&ZG#"QEfaNCA*c,J!#!!!#!"%!!J!6!"30!"-!!R-
+!!!!%!"%!&3!@$3!9!!*M!!!!"!!1!"F!'!d!&`!#E!!&!!3!$!!CrrN0!"N!!Qi
+!!!!%!!`!'J!E$3!D!!)d!!!!"3!-rrJ!(!Vrq!!%#Q0[BQS0!"`!!Q`!"3!'!!X
+!(Irh$3!G!!0*!!)!"J!,rrB!([re#[rf!"JZC@&bFfCQC(*KE'Pc!!!!!!!!)!"
+KCQ4b$3!H!!"Q!!!!"J!(![re!!!"rrF!!!d!'`!"E3!!!!3!"3!I$`!I!6J)ER9
+XE!!!!!!!!Gq!rrm!!!!A"NCTEQ4PFJ!!(`*[Me!!ASfm!Qq,i!"HA[!!I&M!!!!
+!!!!!'mi!!JN#!Qq-1!!!Kb%#Ei`J!!!!!%C14&*038e"3e-!!"%!B@aTF`!!!!!
+!fJ!#!!!-6@&MD@jdEh0S)%K%!!!!!!!!!!!!!!!!!!!!XSA5h%*%!!!!!!!A"NC
+TEQ4PFJ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!3rLc#@a!4Nj%8Ne"3e2rrrrr!!!!!!!!!!!!!!!!!!!
+!!!!!!!e6HA0dC@dJ4QpXC'9b!!!"!!3!!!!A!!)!)8eKBfPZG'pcD#")4$T6HA0
+dC@dJ4QpXC'9b1NCTEQ4PFJ$rr`!!!Irj!!!0!"J!!@d!!!!-!!hrp!Vrp!!%#Q0
+dH(30!"B!!@m!!!!!!!$rm`[rm`!5-!!(G'KPF'&dD!!(G'KP8'&dD!)!&!!#!#!
+!)3d!)!!#E!!#!")!%[rbrr%"rr)!!!(rm3!!!J!K!!)!)J!M$3!L!!*b!!!!%J!
+A!#3!*3d!*!!#EJ!$!")!&3!Q!#F0!#B!!6%!!!!6!"Arm!Vrm!!%#R4iC'`0!#F
+!!6%!!!!5!"2rl`Vrl`!%#Q&cBh)0!#8!!@m!!!!!!!$rlJ[rlJ!F-!!-G'KPEfa
+NC'9XD@ec!!adD'92E'4%C@aTEA-#!#-!!J!S!#N0!#J!!R)!!!!B!"d!+J!V$3!
+U!!&Y!!!!'!!C!#`-!#`!"`!"1J!#!!!0!#X!!Qi!!`!!!!!!,3!Z$3!Y!!%a!!!
+!'J!Frqd+rqd!"!TdH'4X$3!Z!!%a!!!!'3!Drq`+rq`!"!TKFf0b!J!T!!)!,`!
+`$3![!!*X!!)!(J!Hrq[rkJ(rk`!!!IrU!!!#!$!!!J!a!$)0!$%!!R)!!!!H!#X
+!-`!d$3!c!!*X!!8!(J!T!$Ark3d!03!#EJ!!!"i!+3!f!$F0!$B!!cF"!!!I!#R
+rk!!i!$N+rqJ!"!TMDA4Y$3!i!!&Y!!!!)`!PrqF$rqF!!3d!13!"E3!!!#B!+2r
+Q!rrQrrd0!$F!!@m!!!!H!"rrj3[rj3!5-!!(G'KPF'&dD!!(G'KP8'&dD!(rk3!
+!$3!d!!&[!!!!!!!!rq3,rq3!)$!!$R4SCA"bEfTPBh4`BA4S!!jdD'93FQpUC@0
+d8'&dD!)!-J!#!$S!1`d!1J!#FJ!!!#`!1`!m!$d0!$`!!Q-!!!!X!$N!2J!r$3!
+q!!*X!!8!,!!h!%$ri`d!3!!#EJ!!!#`!0`""!%)0!%%!!cF"!!!Y!$IriJ"$!%3
++rq)!"!TMDA4Y$3"$!!&Y!!!!-3!crq%$rq%!!3d!4!!"E3!!!$3!0[rJ!rrJrri
+0!%)!!@m!!!!X!#hrh`[rh`!5-!!(G'KPF'&dD!!(G'KP8'&dD!(ri`!!$3!r!!&
+Y!!!!0`!irpi+rpi!"!T849K8$3!p!!&[!!!!!!!!rpd,rpd!&M!!#A4SC@ePF'&
+dD!!*G'KP6@93BA4S!J!l!!)!43"'$3"&!!*X!!)!2!!mrpcrf`(rh!!!!IrE!!!
+#!%B!!J"(!%J0!%F!!R)!!!!m!%8!53"+$3"*!!*M!!!!2!""!%X!6!d!5`!#BJ!
+!!$`!2`"0!%i0!%d!!@m!!!!m!$hrfJ[rfJ!J-!!1G'KPF(*[DQ9MG("KG'J!$R4
+SC9"bEfTPBh43BA4S$3"1!!&Y!!!!23!q!%m-!%m!$3!(D@jME(9NC3!#!!!0!%`
+!!@d!!!!r!%$rf3Vrf3!%#P4&@&30!%S!!@m!!!!!!!$rf![rf!!Q-!!4D@jME(9
+NC@C[E'4PFR"KG'J!%@PZBfaeC'9'EfaNCA*3BA4S!J")!!)!8!"4$3"3!!*b!!!
+!4J"9!&)!8`d!8J!#B`!!!%B!83"8!&80!&3!!Q)!!!"'!%m!9J"A$3"@!!*L!!!
+!4J",!&J!@3d!@!!"E`!!!%B!4rrA#rrA!#!`!!jdD'9`FQpUC@0dF'&dD!!1G'K
+P8(*[DQ9MG&"KG'J0!&N!!@d!!!"(!%S!@J`!@J!0!!GTEQ0XG@4P!!)!!!d!9`!
+"E3!!!%X!6J"E$!"E!!d!"fp`C@jcFf`!!J!!$3"9!!&Y!!!!6`"3rpB+rpB!"!T
+849K8$3"6!!&[!!!!!!!!rp8,rp8!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&
+dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S!J"4!!)!A!"G$3"F!!*b!!!!9J"
+K!&i!A`d!AJ!#B`!!!&B!A3"J!'%0!'!!!Q)!!!"@!&X!BJ"M$3"L!!&[!!!!9J"
+Arp3,rp3!)$!!$R4SCA"bEfTPBh4`BA4S!!jdD'93FQpUC@0d8'&dD!d!B`!"E3!
+!!&F!@J"N$!"N!!`!"Q0bHA"dE`!#!!!0!'%!!@d!!!"E!&crd`Vrd`!%#P4&@&3
+0!&m!!@m!!!!!!!$rdJ[rdJ!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4Qp
+XC'9b8'&dD!)!A3!#!'8!CJd!C3!#FJ!!!')!E3"R!'J0!'F!!Q-!!!"L!'N!D3"
+U$3"T!!*L!!!!BJ"R!'X!E!d!D`!"E`!!!')!Brr4#rr4!#!`!!jdD'9`FQpUC@0
+dF'&dD!!1G'KP8(*[DQ9MG&"KG'J0!'`!!@d!!!"M!'B!E3`!E3!*!!0cFf`!!J!
+!$3"U!!&Y!!!!C`"Srp!+rp!!"!T849K8$3"S!!&[!!!!!!!!rmm,rmm!(M!!$A0
+cE'C[E'4PFR"KG'J!$A0cE%C[E'4PFP"KG'J#!'B!!J"Z!'m0!'i!!R)!!!"Z!(8
+!F!"a$3"`!!*M!!!!EJ"a!()!F`d!FJ!"E`!!!'i!Err1#rr1!#!`!!jdD'9`FQp
+UC@0dF'&dD!!1G'KP8(*[DQ9MG&"KG'J0!(-!!@d!!!"[!($rc3Vrc3!%#P4&@&3
+0!(%!!@m!!!!!!!$rc![rc!!Q-!!4Eh"PER0cE'C[E'4PFR"KG'J!%@p`C@jcFfa
+'EfaNCA*3BA4S!J"[!!)!G!"e$3"d!!*X!!)!GJ"frm[rbJ(rb`!!!Ir+!!!#!(8
+!!J"f!(F0!(B!!R)!!!"f!(X!H!"j$3"i!!&[!!!!GJ"hrmN,rmN!($!!$(4SC@p
+XC'4PE'PYF`!-G'KP6faN4'9XD@ec$3"j!!*Z!!-!!!!!!(S!H`d!HJ!"-3!!!(J
+!H[r)#[r)!!3+G(KNE!d!H`!"-3!!!(F!H2r(#[r(!!3+BA0MFJ)!G`!#!(`!I3d
+!I!!#E!!#!(`!I2r'rm8"rmB!!!(ra3!!!J"p!!)!IJ"r$3"q!!*X!!%!I!"mrm3
+!J!(ra!!!$!#!!%!!1L"NC@aPG'8JEfaN)'PZBfaeC'8kEh"PER0cE#"QEfaNCA)
+JB@jN)(*PBh*PBA4P)'Pd)'0XC@&ZE(N!!J!!!J"r!!)!J3##$3#"!!*X!!)!I!"
+mrm2r`J(r``!!!Ir#!!!#!))!!J#$!)30!)-!!e%!!!"m!+8!K3#'!)F0!)8!!@X
+!!!"r!*`!L!)!L!!#!)N!LJd!L3!$53!#!(m!N[r"!)[r`!Vr`3!B,QeTFf0cE'0
+d+LSU+J!!!!!!!*!!!#SU+LS0!)X!!Qi!!!"r!)i!M!#0$3#-!!)d!!!!K`#1rlm
+!MJVr[`!%#Q0QEf`0!)i!!@d!!!#+!)d!M``!M`!0!!G[F'9ZFh0X!!)!!!d!M3!
+#0!!!!(m!Krqq!*!!#[qq!!3+BfC[E!d!N!!!!@m!!!#$!)Er[3[r[3!Q-!!4D@j
+ME(9NC@C[E'4PFR"KG'J!%@PZBfaeC'9'EfaNCA*3BA4S![r!!!!#!)S!!J#4rl`
+0!*%!!dN!!J#6!*crZ`#5rlS+rlX!'#jMEh*PC'9XEbSU+LS!!!!!!!#3!!!U+LS
+U$3#5!!%a!!!!N`#BrlN+rlN!"!TcC@aP![qk!!!#rl`!!!d!KJ!$8J!!!!!!!2q
+irlIrYJVrZ!!B,Q&cBh*PFR)J+LSU+J!!!!!!!*!!!#SU+LS"rlF!!!,rYJ!!$3#
+(!!*X!!%!T!#Nrl8!N`(rY3!!$!#6!"-!$5"TCfj[FQ8JCA*bEh)!!J!!!J#%!!)
+!P!#9$3#8!!*X!!)!TJ#Qrl6rX`(rY!!!!Iqc!!!#!*8!!J#@!*F0!*B!!dN!!J#
+Q!,lrX[qa!*J+rl)!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Iqa!!!'!*J
+!!rq`!*N!QJVrX!!%#QY[Bf`0!*N!!@d!!!#U!+hrV`VrV`!%#Q0QEf`'!*S!!rq
+Z!*[rV3VrVJ!%#QPZFfJ0!*X!!M3!!!#`!,MrV!#F#[qX!!3+BfC[E!d!R!!"E`!
+!!,3!YrqV#rqV!#B`!"&TEQ0XG@4PCQpXC'9bF'&dD!!4D@jME(9NC8C[E'4PFP"
+KG'J'rkd!!!)!P`!#!*d!RJd!R3!#FJ!!!,m!aJ#I!+!0!*m!!Q`"!!#r!-)!SIq
+U$3#K!!%a!!!![`$#rkN+rkN!"!TbFfad!IqU!!!0!+!!!@m!!!!!!!$rU![rU!!
+Z-!!9G'KPEQ9hCQpXC'9bFQ9QCA*PEQ0P!"9dD'91CAG'EfaNCA*5C@CPFQ9ZBf8
+#!*i!!J#L!+-0!+)!!dN!!J$(!-lrT`#NrkB+rkF!'#jYDA0MFfaMG#SU+LS!!!!
+!!!#3!!!U+LSU$3#N!!&[!!!!a`$+rk8,rk8!,M!!&A4SC@jPGfC[E'4PFR*PCQ9
+bC@jMC3!9G'KP6Q9h4QpXC'9b8Q9QCA*PEQ0P![qQ!!!#!+-!!J#P!+B0!+8!!R)
+!!!$2!0`!T`#S$3#R!!&Y!!!!c`$5!+N-!+N!$3!(Eh"PER0cE!!#!!!0!+J!!Qi
+!!!!!!!!!UJ#V$3#U!!%a!!!!e`$Erk3+rk3!"!T`EQ&Y$3#V!!%a!!!!dJ$Ark-
++rk-!"!TcC@aP!J#Q!!)!V!#Y$3#X!!*X!!)!h3$Grk,rS3(rSJ!!!IqK!!!#!+d
+!!J#Z!+m0!+i!!Q`!!3$G!0hrS!#`!IqJ!!!-!,!!(`!C)&0dBA*d)'eKDfPZCb"
+dD'8JB@aTBA0PF`!#!!!#!+m!!J#a!,)0!,%!!dN!!J$G!3ArRrqH!,-+rjm!'#j
+MEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!IqH!!!'!,-!!rqG!,3!Y3VrR3!%#QY
+[Bf`0!,3!!@d!!!$K!16rR!VrR!!%#Q&XD@%'!,8!!rqE!,B!Y`VrQ`!%#QPZFfJ
+0!,B!!M3!!!$R!1rrQJ#i#[qD!!3+BfC[E!d!Z!!"E`!!!1X!l[qC#rqC!$3`!"K
+[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&
+dD!B!Y`!$rjJ!ZIqA#[qB!!3+G'mJ)!d!Z3!#EJ!!!2)!r`#k!,X0!,S!!M3!!!$
+i!2rrPJ#m#[q@!!3+CQPXC3d![!!"E3!!!2X!rJ#p$!#p!"-!$@p`C@jcFfaMEfj
+Q,QJ!!J!!$3#l!!)d!!!!mJ$irj8![JVrP3!%#Q0QEf`0!,i!!@m!!!$f!2IrP![
+rP!!@-!!*G'KPE@9`BA4S!!PdD'90C9"KG'J'rjF!!!)!XJ!#!,m!`!d![`!#E!!
+#!3B""[q6rj)"rj-!!!(rNJ!!!J$!!!)!`3$#$3$"!!*b!!!""J%4!--!a!d!``!
+#BJ!!!3B"$3$&!-B0!-8!!@m!!!%'!3RrN3[rN3!N-!!3Bh*jF(4[CQpXC'9bF'&
+dD!!3Bh*jF(4[4QpXC'9b8'&dD!d!aJ!"E3!!!3N"$!$($!$(!!X!"6TKFfia!!)
+!!!d!a!!"E`!!!!!!!2q3!![rN!!!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)!`J!
+#!-J!b3d!b!!$53!#!4)"22q2rii!bJVrM`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!
+!!'jeE'`"rii!!!B!bJ!$rid!b`$-#[q0!!3+DfpME!d!b`!"E3!!!4B"'Iq-#[q
+-!!3+B@aTB3B!c!!$riX!c3$1#[q,!!3+D@jcD!d!c3!#0!!!!4`"*2q+!-m+riS
+!"!TMCQpX$3$2!!&[!!!")!%MriN,riN!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9
+bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J$1!!2rL!$3riF+riJ!"!T
+dEb!J$3$3!!*Z!!!"*`%f!0%!dJd!d3!#0!!!!5m"0[q'!0-+riB!"!TQD@aP$3$
+6!!&Y!!!"-J%e!03-!03!$!!'BA0Z-5jS!!)!!!d!dJ!#0!!!!5F",rq&!08+ri8
+!"!TMCQpX$3$9!!&[!!!"+`%Zri3,ri3!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!E
+rK`!!!J$*!!)!eJ$A$3$@!!0*!!)"23&Rri2rJJ$B#[q$!"JZBfpbC@0bC@`U+LS
+U!!!!!!!!N!!!ER9XE!(rJJ!!"J$B!!2rJ3$C!0S+ri%!"!TVEf0X$3$C!!&Y!!!
+"33&%ri!+ri!!"!TKE'PK"J$D!!2rI`$E!0`+rhm!"!TTER0S$3$E!!)d!!!"4`&
+2rhi!h3VrIJ!%#Q0QEf`0!0d!!@m!!!&,!8lrI3[rI3!d-!!BEh"PER0cE'PZBfa
+eC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!0`!!rpm!0l
+rH`VrI!!%#R4[)#!0!0i!!Qi!!!&5!@%!h`$J$3$I!!)d!!!"@J&KrhS!i3VrHJ!
+%#QCTE'80!1%!!@d!!!&G!@!!iJ`!iJ!3!!TKFfiaAfeKBbjS!!)!!!d!i!!#0!!
+!!9)"@[pj!1-+rhN!"!TMCQpX$3$M!!&[!!!"9J&CrhJ,rhJ!&$!!#(4PEA"`BA4
+S!!KdC@e`8'&dD!ErH`!!!J$A!!)!j!$P$3$N!!*X!!)"D!&SrhIrGJ(rG`!!!Ip
+f!!!#!18!!J$Q!1F0!1B!!R)!!!&S!A-!k!$T$3$S!!*L!!!"D!&[!1S!k`d!kJ!
+"E`!!!@J"Drpe#rpe!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*
+3BA4S$3$V!!&Y!!!"D`&Z!1`-!1`!#J!%1Q*TE`!#!!!0!1N!!@m!!!!!!!$rG![
+rG!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J$R!!)!l3$Z$3$Y!!0*!!)"G!'Hrh2
+rFJ$[#[pc!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!(rFJ!!"J$[!!2rF3$
+`!2%+rh%!"!TVEf0X$3$`!!&Y!!!"H!&lrh!+rh!!"!TKE'PK"J$a!!2rE`$b!2-
++rfm!"!TTER0S$3$b!!)d!!!"IJ''rfi!p!VrEJ!%#Q0QEf`0!23!!@m!!!'#!BA
+rE3[rE3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9
+NC8C[E'4PFP"KG'J'!2-!!rpX!2ArD`VrE!!%#R4[)#!0!28!!Qi!!!'*!CJ!pJ$
+h$3$f!!)d!!!"N3'BrfS!q!VrDJ!%#QCTE'80!2J!!@d!!!'8!CF!q3`!q3!,!!9
+LD@mZD!!#!!!0!2F!!M3!!!'*!C(rD3$k#[pT!!3+BfC[E!d!qJ!"E`!!!Bd"N!$
+rD![rD!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[pV!!!#!1i!!J$l!2`0!2X!!Q`
+!!J'I!CrrCrpQ!IpR!!!"rfB!!!)!r!!#!2d!rJd!r3!#FJ!!!Cm"UJ$r!3!0!2m
+!!Q)!!!'I!DB"!3%#$3%"!!&[!!!"R`'Lrf8,rf8!*$!!%'0bHA"dEfC[E'4PFR"
+KG'J!%'0bHA"dEdC[E'4PFP"KG'J0!3)!!@d!!!'L!D8"!``"!`!*!!-kBQB!!J!
+!$3%!!!&[!!!!!!!!rf3,rf3!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)!rJ!#!33
+""3d""!!$53!#!DX"eIpMrf)""JVrB`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'j
+eE'`"rf)!!!B""J!$rf%""`%)#[pK!!3+DfpME!d""`!"E3!!!Dm"X[pJ#[pJ!!3
++B@aTB3B"#!!$rem"#3%+#[pI!!3+D@jcD!d"#3!#0!!!!E8"[IpH!3X+rei!"!T
+MCQpX$3%,!!&[!!!"Z3'mred,red!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&
+dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J%+!!2rA!%-reX+re`!"!TdEb!
+J$3%-!!*Z!!!"`!(2!3d"$Jd"$3!#0!!!!FJ"crpD!3m+reS!"!TQD@aP$3%2!!&
+Y!!!"b`(1!4!-!4!!%!!+BQa[GfCTFfJZD!!#!!!0!3i!!M3!!!(!!FMr@3%4#[p
+C!!3+BfC[E!d"%3!"E`!!!F3"arpB#rpB!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J
+'reX!!!)""3!#!4)"%`d"%J!#E!!#!GB"e[pAreB"reF!!!(r9J!!!J%6!!)"&!%
+9$3%8!!*b!!!"eJ(K!4B"&`d"&J!#BJ!!!GB"h3%B!4N0!4J!!@m!!!(@!GRr93[
+r93!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d"'3!"E3!
+!!GN"h!%D$!%D!!N!!cTLEJ!#!!!0!4F!!@m!!!!!!!$r9![r9!!8-!!)G'9YF("
+KG'J!#(4PEA"3BA4S!J%9!!)"'`%F$3%E!!0*!!)"iJ)-re2r8J%G#[p6!"JZBfp
+bC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!(r8J!!"J%G!!2r83%H!4m+re%!"!TVEf0
+X$3%H!!&Y!!!"jJ(Tre!+re!!"!TKE'PK"J%I!!2r6`%J!5%+rdm!"!TTER0S$3%
+J!!)d!!!"l!(drdi")JVr6J!%#Q0QEf`0!5)!!@m!!!(`!I2r63[r63!d-!!BEh"
+PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J
+'!5%!!rp-!52r5`Vr6!!%#R4[)#!0!5-!!Qi!!!(h!JB"*!%P$3%N!!)d!!!"r`)
+'rdS"*JVr5J!%#QCTE'80!5B!!@d!!!)#!J8"*``"*`!+!!4LELjS!!)!!!d"*3!
+#0!!!!IF"rrp*!5J+rdN!"!TMCQpX$3%S!!&[!!!"q`(qrdJ,rdJ!&$!!#(4PEA"
+`BA4S!!KdC@e`8'&dD!Er5`!!!J%F!!)"+3%U$3%T!!*X!!)#$3)0rdIr4J(r4`!
+!!Ip'!!!#!5S!!J%V!5`0!5X!!R)!!!)0!KJ",3%Z$3%Y!!*L!!!#$3)8!5m"-!d
+",`!"E`!!!Jd#%2p&#rp&!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'Efa
+NCA*3BA4S$3%`!!&Y!!!#%!)6!6%-!6%!$3!(1Q*eCQCPFJ!#!!!0!5i!!@m!!!!
+!!!$r4![r4!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J%X!!)"-J%c$3%b!!0*!!)
+#'3*$rd2r3J%d#[p$!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!(r3J!!"J%
+d!!2r33%e!6B+rd%!"!TVEf0X$3%e!!&Y!!!#(3)Jrd!+rd!!"!TKE'PK"J%f!!2
+r2`%h!6J+rcm!"!TTER0S$3%h!!)d!!!#)`)Vrci"13Vr2J!%#Q0QEf`0!6N!!@m
+!!!)R!LVr23[r23!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0
+-5@jME(9NC8C[E'4PFP"KG'J'!6J!!rmm!6Vr1`Vr2!!%#R4[)#!0!6S!!Qi!!!)
+Z!Md"1`%m$3%l!!)d!!!#0J)prcS"23Vr1J!%#QCTE'80!6d!!@d!!!)j!M`"2J`
+"2J!1!!KLG@CQCA)ZD!!#!!!0!6`!!M3!!!)Z!MEr13%r#[mj!!3+BfC[E!d"2`!
+"E`!!!M)#0Imi#rmi!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'rcX!!!)"-`!#!8!
+"33d"3!!#E!!#!N3#42mhrcB"rcF!!!(r0J!!!J&"!!)"3J&$$3&#!!*b!!!#4!*
+2!83"43d"4!!#BJ!!!N3#5`&'!8F0!8B!!@m!!!*%!NIr03[r03!N-!!3Bh*jF(4
+[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d"4`!"E3!!!NF#5J&)$!&)!!X
+!"6TMBA0d!!)!!!d"43!"E`!!!!!!!2md#rmd!"3`!!KdC@e`F'&dD!!)G'9YF&"
+KG'J#!8-!!J&*!8S0!8N!!dN!!J*3!RVr-rmb!8X+rc-!'#jMEh*PBh*PE#SU+LS
+!!!!!!!#3!!"ZG@aX!Imb!!!'!8X!!rma!8`"63Vr-3!%#QY[Bf`0!8`!!@d!!!*
+8!PIr-!Vr-!!%#Q&XD@%'!8d!!rm[!8i"6`Vr,`!%#QPZFfJ0!8i!!M3!!!*D!Q,
+r,J&3#[mZ!!3+BfC[E!d"8!!"E`!!!Pi#BImY#rmY!$3`!"K[F'9ZFh0XD@jME(9
+NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B"6`!$rb`"8Im
+V#[mX!!3+G'mJ)!d"83!#EJ!!!Q8#G!&5!9-0!9)!!M3!!!*Y!R6r+J&8#[mU!!3
++CQPXC3d"9!!"E3!!!R!#F`&9$!&9!!`!"Q0KFh3ZD!!#!!!0!9-!!M3!!!*P!Qh
+r+3&@#[mT!!3+BfC[E!d"9J!"E`!!!QN#E2mS#rmS!"3`!!KdC@e`F'&dD!!)G'9
+YF&"KG'J'rbX!!!)"5J!#!9F"@!d"9`!#E!!#!RX#HrmRrbB"rbF!!!(r*J!!!J&
+B!!)"@3&D$3&C!!*b!!!#H`+'!9X"A!d"@`!#BJ!!!RX#JJ&G!9i0!9d!!@m!!!*
+l!Rlr*3[r*3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d
+"AJ!"E3!!!Ri#J3&I$!&I!!X!"6TMEfe`!!)!!!d"A!!"E`!!!!!!!2mN#rmN!"3
+`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!9S!!J&J!@%0!@!!!dN!!J+(!V(r)rmL!@)
++rb-!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!ImL!!!'!@)!!rmK!@-"C!V
+r)3!%#QY[Bf`0!@-!!@d!!!+,!Slr)!Vr)!!%#Q&XD@%'!@3!!rmI!@8"CJVr(`!
+%#QPZFfJ0!@8!!M3!!!+4!TRr(J&R#[mH!!3+BfC[E!d"C`!"E`!!!T8#Q2mG#rm
+G!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4Qp
+XC'9b8'&dD!B"CJ!$ra`"D2mE#[mF!!3+G'mJ)!d"D!!#EJ!!!T`#U`&T!@S0!@N
+!!M3!!!+N!U[r'J&V#[mD!!3+CQPXC3d"D`!"E3!!!UF#UJ&X$!&X!!`!"Q0[EA!
+ZD!!#!!!0!@S!!M3!!!+F!U6r'3&Y#[mC!!3+BfC[E!d"E3!"E`!!!U!#SrmB#rm
+B!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'raX!!!)"B3!#!@i"E`d"EJ!#E!!#!V)
+#X[mAraB"raF!!!(r&J!!!J&[!!)"F!&a$3&`!!*b!!!#XJ+p!A)"F`d"FJ!#BJ!
+!!V)#Z3&d!A80!A3!!@m!!!+b!VAr&3[r&3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!
+3Bh*jF(4[4QpXC'9b8'&dD!d"G3!"E3!!!V8#Z!&f$!&f!!X!"6TMEfjQ!!)!!!d
+"F`!"E`!!!!!!!2m8#rm8!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!A%!!J&h!AJ
+0!AF!!dN!!J+q!ZMr%rm5!AN+ra-!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@a
+X!Im5!!!'!AN!!rm4!AS"H`Vr%3!%#QY[Bf`0!AS!!@d!!!,#!XAr%!Vr%!!%#Q&
+XD@%'!AX!!rm2!A`"I3Vr$`!%#QPZFfJ0!A`!!M3!!!,)!Y$r$J&q#[m1!!3+BfC
+[E!d"IJ!"E`!!!X`#crm0#rm0!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J
+!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B"I3!$r``"Irm,#[m-!!3+G'mJ)!d
+"I`!#EJ!!!Y-#iJ'!!B%0!B!!!M3!!!,E!Z,r#J'##[m+!!3+CQPXC3d"JJ!"E3!
+!!Yi#i3'$$!'$!!`!"Q0[EQBZD!!#!!!0!B%!!M3!!!,6!Y[r#3'%#[m*!!3+BfC
+[E!d"K!!"E`!!!YF#f[m)#rm)!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'r`X!!!)
+"H!!#!B8"KJd"K3!#E!!#!ZN#kIm(r`B"r`F!!!(r"J!!!J''!!)"K`')$3'(!!*
+b!!!#k3,d!BN"LJd"L3!#BJ!!!ZN#m!',!B`0!BX!!@m!!!,T!Zcr"3[r"3!N-!!
+3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d"M!!"E3!!!Z`#l`'
+0$!'0!!S!"$TNCA-!!J!!$3'+!!&[!!!!!!!!r`3,r`3!&$!!#(4PEA"`BA4S!!K
+dC@e`8'&dD!)"L!!#!Bi"M`d"MJ!$53!#![8$(rm$r`)"N!!+r`-!'#jMEh*PBh*
+PE#SU+LS!!!!!!!#3!!"ZG@aX!Im#!!!'!C!!!!2r!3'4!C)+r`%!"!TVEf0X$3'
+4!!&Y!!!#q3,mr`!+r`!!"!TKE'PK"J'5!!2qr`'6!C3+r[m!"!TTER0S$3'6!!)
+d!!!#r`-(r[i"P3VqrJ!%#Q0QEf`0!C8!!@m!!!-$!`Eqr3[qr3!d-!!BEh"PER0
+cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!C3
+!!rlm!CEqq`Vqr!!%#R4[)#!0!CB!!Qi!!!-+!aN"P`'B$3'A!!)d!!!$%J-Cr[S
+"Q3VqqJ!%#QCTE'80!CN!!@d!!!-9!aJ"QJ`"QJ!,!!9NCA-ZD!!#!!!0!CJ!!M3
+!!!-+!a,qq3'E#[lj!!3+BfC[E!d"Q`!"E`!!!`i$%Ili#rli!"3`!!KdC@e`F'&
+dD!!)G'9YF&"KG'J'r[X!!!)"M`!#!C`"R3d"R!!#E!!#!b!$)2lhr[B"r[F!!!(
+qpJ!!!J'G!!)"RJ'I$3'H!!*b!!!$)!-V!D!"S3d"S!!#BJ!!!b!$*`'L!D-0!D)
+!!@m!!!-J!b2qp3[qp3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9
+b8'&dD!d"S`!"E3!!!b-$*J'N$!'N!!N!!cTND!!#!!!0!D%!!@m!!!!!!!$qp![
+qp!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J'I!!)"T3'Q$3'P!!0*!!)$,!0@r[2
+qmJ'R#[lc!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!(qmJ!!"J'R!!2qm3'
+S!DN+r[%!"!TVEf0X$3'S!!&Y!!!$-!-cr[!+r[!!"!TKE'PK"J'T!!2ql`'U!DX
++rZm!"!TTER0S$3'U!!)d!!!$0J-qrZi"V!VqlJ!%#Q0QEf`0!D`!!@m!!!-k!ch
+ql3[ql3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9
+NC8C[E'4PFP"KG'J'!DX!!rlX!Dhqk`Vql!!%#R4[)#!0!Dd!!Qi!!!0"!e!"VJ'
+[$3'Z!!)d!!!$5303rZS"X!VqkJ!%#QCTE'80!E!!!@d!!!0-!dm"X3`"X3!+!!4
+ND#jS!!)!!!d"V`!#0!!!!d%$5IlT!E)+rZN!"!TMCQpX$3'b!!&[!!!$430)rZJ
+,rZJ!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!Eqk`!!!J'Q!!)"X`'d$3'c!!*X!!)
+$9`0ArZIqjJ(qj`!!!IlQ!!!#!E3!!J'e!EB0!E8!!R)!!!0A!f)"Y`'i$3'h!!*
+L!!!$9`0H!EN"ZJd"Z3!"E`!!!eF$@[lP#rlP!#3`!""MFRP`G'pQEfaNCA*`BA4
+S!""MFRP`G'p'EfaNCA*3BA4S$3'k!!&Y!!!$@J0G!EX-!EX!#J!%1Q4cB3!#!!!
+0!EJ!!@m!!!!!!!$qj![qj!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J'f!!)"[!'
+p$3'm!!0*!!)$B`10rZ2qiJ'q#[lM!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9
+XE!(qiJ!!"J'q!!2qi3'r!F!+rZ%!"!TVEf0X$3'r!!&Y!!!$C`0UrZ!+rZ!!"!T
+KE'PK"J(!!!2qh`("!F)+rYm!"!TTER0S$3("!!)d!!!$E30erYi"``VqhJ!%#Q0
+QEf`0!F-!!@m!!!0a!h6qh3[qh3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4
+S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!F)!!rlF!F6qf`Vqh!!%#R4[)#!
+0!F3!!Qi!!!0i!iF"a3('$3(&!!)d!!!$J!1(rYS"a`VqfJ!%#QCTE'80!FF!!@d
+!!!1$!iB"b!`"b!!,!!9NFf%ZD!!#!!!0!FB!!M3!!!0i!i$qf3(*#[lC!!3+BfC
+[E!d"b3!"E`!!!h`$IrlB#rlB!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'rYX!!!)
+"[3!#!FS"b`d"bJ!#E!!#!ii$M[lArYB"rYF!!!(qeJ!!!J(,!!)"c!(0$3(-!!*
+b!!!$MJ1C!Fi"c`d"cJ!#BJ!!!ii$P3(3!G%0!G!!!@m!!!11!j(qe3[qe3!N-!!
+3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d"d3!"E3!!!j%$P!(
+5$!(5!!S!"$TPFR)!!J!!$3(2!!&[!!!!!!!!rY3,rY3!&$!!#(4PEA"`BA4S!!K
+dC@e`8'&dD!)"c3!#!G-"e!d"d`!$53!#!jS$a2l6rY)"e3Vqd`!B,Q0[FQ9MFQ9
+X+LSU+J!!!!!!!*!!!'jeE'`"rY)!!!B"e3!$rY%"eJ(A#[l4!!3+DfpME!d"eJ!
+"E3!!!ji$SIl3#[l3!!3+B@aTB3B"e`!$rXm"f!(C#[l2!!3+D@jcD!d"f!!#0!!
+!!k3$V2l1!GS+rXi!"!TMCQpX$3(D!!&[!!!$U!1VrXd,rXd!0$!!''p`C@jcFfa
+TEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J(C!!2
+qc!(ErXX+rX`!"!TdEb!J$3(E!!*Z!!!$V`1q!G`"h3d"h!!#0!!!!lF$[[l+!Gi
++rXS!"!TQD@aP$3(H!!&Y!!!$ZJ1p!Gm-!Gm!#`!&CA*b,QJ!!J!!$3(G!!)d!!!
+$V`1hrXN"i!Vqb3!%#Q0QEf`0!H!!!@m!!!1c!lEqb![qb!!8-!!)G'9YF("KG'J
+!#(4PEA"3BA4S"[l,!!!#!G3!!J(K!H)0!H%!!Q`!!J2&!mAqarl'!Il(!!!"rXB
+!!!)"iJ!#!H-"j!d"i`!#FJ!!!m8$d!(P!HB0!H8!!Q)!!!2&!m`"j`(S$3(R!!&
+[!!!$a32)rX8,rX8!*$!!%'0bHA"dEfC[E'4PFR"KG'J!%'0bHA"dEdC[E'4PFP"
+KG'J0!HJ!!@d!!!2)!mX"k3`"k3!+!!3kCAC`!!)!!!d"jJ!"E`!!!!!!!2l%#rl
+%!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!H3!!J(U!HX0!HS!!dN!!J24!r[q`rl
+#!H`+rX-!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Il#!!!'!H`!!rl"!Hd
+"lJVq`3!%#QY[Bf`0!Hd!!@d!!!29!pMq`!Vq`!!%#Q&XD@%'!Hi!!rkr!Hm"m!V
+q[`!%#QPZFfJ0!Hm!!M3!!!2E!q2q[J(a#[kq!!3+BfC[E!d"m3!"E`!!!pm$i[k
+p#rkp!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4
+P4QpXC'9b8'&dD!B"m!!$rV`"m[kl#[km!!3+G'mJ)!d"mJ!#EJ!!!qB$p3(c!I3
+0!I-!!M3!!!2Z!rAqZJ(e#[kk!!3+CQPXC3d"p3!"E3!!!r%$p!(f$!(f!!X!"@9
+fF#jS!!)!!!d"p!!#0!!!!qB$l[kj!IF+rVN!"!TMCQpX$3(h!!&[!!!$kJ2YrVJ
+,rVJ!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!EqZ`!!!J(V!!)"q!(j$3(i!!*X!!)
+$r!2mrVIqYJ(qY`!!!Ikf!!!#!IN!!J(k!IX0!IS!!R)!!!2m"!F"r!(p$3(m!!*
+L!!!$r!3$!Ii"r`d"rJ!"E`!!!r`$rrke#rke!#3`!""MFRP`G'pQEfaNCA*`BA4
+S!""MFRP`G'p'EfaNCA*3BA4S$3(r!!&Y!!!$r`3#!J!-!J!!#`!&1QKYB@-!!J!
+!$3(p!!&[!!!!!!!!rV3,rV3!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)"q`!#!J%
+#!Jd#!3!$53!#"!J%-[kcrV)#!`VqX`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'j
+eE'`"rV)!!!B#!`!$rV%#"!)&#[ka!!3+DfpME!d#"!!"E3!!"!`%$rk`#[k`!!3
++B@aTB3B#"3!$rUm#"J)(#[k[!!3+D@jcD!d#"J!#0!!!"")%'[kZ!JJ+rUi!"!T
+MCQpX$3))!!&[!!!%&J3CrUd,rUd!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&
+dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J)(!!2qV!)*rUX+rU`!"!TdEb!
+J$3)*!!*Z!!!%(33X!JS##`d##J!#0!!!"#8%,2kU!J`+rUS!"!TQD@aP$3)-!!&
+Y!!!%+!3V!Jd-!Jd!$!!'D'eKBbjS!!)!!!d##`!#0!!!""d%*IkT!Ji+rUN!"!T
+MCQpX$3)1!!&[!!!%)33NrUJ,rUJ!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!EqU`!
+!!J)#!!)#$`)3$3)2!!*X!!)%-`3crUIqTJ(qT`!!!IkQ!!!#!K!!!J)4!K)0!K%
+!!R)!!!3c"$i#%`)8$3)6!!*L!!!%-`3k!K8#&Jd#&3!"E`!!"$-%0[kP#rkP!#3
+`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3)@!!&Y!!!%0J3
+j!KF-!KF!#`!&1QPNC@%!!J!!$3)8!!&[!!!!!!!!rU3,rU3!&$!!#(4PEA"`BA4
+S!!KdC@e`8'&dD!)#%J!#!KJ#'3d#'!!$53!#"$m%DIkMrU)#'JVqS`!B,Q0[FQ9
+MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rU)!!!B#'J!$rU%#'`)F#[kK!!3+DfpME!d
+#'`!"E3!!"%-%4[kJ#[kJ!!3+B@aTB3B#(!!$rTm#(3)H#[kI!!3+D@jcD!d#(3!
+#0!!!"%N%8IkH!Km+rTi!"!TMCQpX$3)I!!&[!!!%6343rTd,rTd!0$!!''p`C@j
+cFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J)
+H!!2qR!)JrTX+rT`!"!TdEb!J$3)J!!*Z!!!%9!4M!L%#)Jd#)3!#0!!!"&`%Brk
+D!L-+rTS!"!TQD@aP$3)M!!&Y!!!%A`4L!L3-!L3!$!!'D@4PB5jS!!)!!!d#)J!
+#0!!!"&3%A2kC!L8+rTN!"!TMCQpX$3)P!!&[!!!%@!4ErTJ,rTJ!&$!!#(4PEA"
+`BA4S!!KdC@e`8'&dD!EqQ`!!!J)C!!)#*J)R$3)Q!!*X!!)%DJ4UrTIqPJ(qP`!
+!!Ik@!!!#!LF!!J)S!LN0!LJ!!R)!!!4U"(8#+J)V$3)U!!*L!!!%DJ4a!L`#,3d
+#,!!"E`!!"'S%EIk9#rk9!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'Efa
+NCA*3BA4S$3)Y!!&Y!!!%E34`!Li-!Li!$!!'1QaSBA0S!!)!!!d#+`!"E`!!!!!
+!!2k8#rk8!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!LN!!J)[!M!0!Lm!!dN!!J4
+f"+$qNrk5!M%+rT-!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Ik5!!!'!M%
+!!rk4!M)#-`VqN3!%#QY[Bf`0!M)!!@d!!!4k"(hqN!!+rT!!!!3+B@aTB3B#-`!
+$rSm#0!)e#[k2!!3+D@jcD!d#0!!#0!!!")!%L2k1!MB+rSi!"!TMCQpX$3)f!!&
+[!!!%K!5(rSd,rSd!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP0
+66%PZBfaeC'9'EfaNCA*3BA4S"J)e!!2qM!)hrSX+rS`!"!TdEb!J$3)h!!*Z!!!
+%L`5D!MJ#13d#1!!#0!!!"*-%Q[k+!MS+rSS!"!TQD@aP$3)k!!&Y!!!%PJ5C!MX
+-!MX!$3!(E'KKFfJZD!!#!!!0!MN!!M3!!!5,"*2qL3)m#[k*!!3+BfC[E!d#2!!
+"E`!!")m%N[k)#rk)!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'rSX!!!)#-!!#!Md
+#2Jd#23!#E!!#"+%%SIk(rSB"rSF!!!(qKJ!!!J)q!!)#2`*!$3)r!!*b!!!%S35
+X!N%#3Jd#33!#BJ!!"+%%U!*$!N30!N-!!@m!!!5K"+6qK3[qK3!N-!!3Bh*jF(4
+[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d#4!!"E3!!"+3%T`*&$!*&!!S
+!"$TYC$)!!J!!$3*#!!&[!!!!!!!!rS3,rS3!&$!!#(4PEA"`BA4S!!KdC@e`8'&
+dD!)#3!!#!NB#4`d#4J!$53!#"+d%erk$rS)#5!VqJ`!B,Q0[FQ9MFQ9X+LSU+J!
+!!!!!!*!!!'jeE'`"rS)!!!B#5!!$rS%#53*+#[k"!!3+DfpME!d#53!"E3!!",%
+%Y2k!#[k!!!3+B@aTB3B#5J!$rRm#5`*-#[jr!!3+D@jcD!d#5`!#0!!!",F%[rj
+q!Nd+rRi!"!TMCQpX$3*0!!&[!!!%Z`5qrRd,rRd!0$!!''p`C@jcFfaTEQ0XG@4
+PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J*-!!2qI!*1rRX
++rR`!"!TdEb!J$3*1!!*Z!!!%`J64!Nm#8!d#6`!#0!!!"-S%dIjk!P%+rRS!"!T
+QD@aP$3*4!!&Y!!!%c363!P)-!P)!#`!&E@3b,QJ!!J!!$3*3!!)d!!!%`J6+rRN
+#8`VqH3!%#Q0QEf`0!P-!!@m!!!6'"-RqH![qH!!8-!!)G'9YF("KG'J!#(4PEA"
+3BA4S"[jl!!!#!NF!!J*8!P80!P3!!Q`!!J6B"0MqGrjf!Ijh!!!"rRB!!!)#93!
+#!PB#9`d#9J!#FJ!!"0J%i`*B!PN0!PJ!!Q)!!!6B"0m#@J*E$3*D!!&[!!!%f!6
+ErR8,rR8!*$!!%'0bHA"dEfC[E'4PFR"KG'J!%'0bHA"dEdC[E'4PFP"KG'J0!PX
+!!@d!!!6E"0i#A!`#A!!+!!3kE@3e!!)!!!d#@3!"E`!!!!!!!2jd#rjd!"3`!!K
+dC@e`F'&dD!!)G'9YF&"KG'J#!PF!!J*G!Pi0!Pd!!dN!!J6N"3lqFrjb!Pm+rR-
+!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Ijb!!!'!Pm!!rja!Q!#B3VqF3!
+%#QY[Bf`0!Q!!!@d!!!6S"1[qF!VqF!!%#Q&XD@%'!Q%!!rj[!Q)#B`VqE`!%#QP
+ZFfJ0!Q)!!M3!!!6Z"2EqEJ*N#[jZ!!3+BfC[E!d#C!!"E`!!"2)%pIjY#rjY!$3
+`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9
+b8'&dD!B#B`!$rQ`#CIjV#[jX!!3+G'mJ)!d#C3!#EJ!!"2N&#!*Q!QF0!QB!!M3
+!!!8""3MqDJ*S#[jU!!3+CQPXC3d#D!!"E3!!"33&"`*T$!*T!!X!"@eN05jS!!)
+!!!d#C`!#0!!!"2N&!IjT!QS+rQN!"!TMCQpX$3*U!!&[!!!%r38!rQJ,rQJ!&$!
+!#(4PEA"`BA4S!!KdC@e`8'&dD!EqD`!!!J*H!!)#D`*X$3*V!!*X!!)&$`82rQI
+qCJ(qC`!!!IjQ!!!#!Q`!!J*Y!Qi0!Qd!!R)!!!82"4S#E`*`$3*[!!*L!!!&$`8
+@!R%#FJd#F3!"E`!!"3m&%[jP#rjP!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP
+`G'p'EfaNCA*3BA4S$3*b!!&Y!!!&%J89!R--!R-!#`!&1QeNBc)!!J!!$3*`!!&
+[!!!!!!!!rQ3,rQ3!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)#EJ!#!R3#G3d#G!!
+$53!#"4X&4IjMrQ)#GJVqB`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rQ)
+!!!B#GJ!$rQ%#G`*i#[jK!!3+DfpME!d#G`!"E3!!"4m&)[jJ#[jJ!!3+B@aTB3B
+#H!!$rPm#H3*k#[jI!!3+D@jcD!d#H3!#0!!!"58&,IjH!RX+rPi!"!TMCQpX$3*
+l!!&[!!!&+38XrPd,rPd!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"
+PEP066%PZBfaeC'9'EfaNCA*3BA4S"J*k!!2qA!*mrPX+rP`!"!TdEb!J$3*m!!*
+Z!!!&-!8r!Rd#IJd#I3!#0!!!"6J&2rjD!Rm+rPS!"!TQD@aP$3*r!!&Y!!!&1`8
+q!S!-!S!!$!!'E@4M-LjS!!)!!!d#IJ!#0!!!"6!&12jC!S%+rPN!"!TMCQpX$3+
+"!!&[!!!&0!8hrPJ,rPJ!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!Eq@`!!!J*e!!)
+#JJ+$$3+#!!*X!!)&4J9'rPIq9J(q9`!!!Ij@!!!#!S-!!J+%!S80!S3!!R)!!!9
+'"9%#KJ+($3+'!!*L!!!&4J90!SJ#L3d#L!!"E`!!"8B&5Ij9#rj9!#3`!""MFRP
+`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3+*!!&Y!!!&539-!SS-!SS
+!$J!)1QpLDQ9MG(-!!J!!$3+(!!&[!!!!!!!!rP3,rP3!&$!!#(4PEA"`BA4S!!K
+dC@e`8'&dD!)#K3!#!SX#M!d#L`!$53!#"9)&I2j6rP)#M3Vq8`!B,Q0[FQ9MFQ9
+X+LSU+J!!!!!!!*!!!'jeE'`"rP)!!!B#M3!$rP%#MJ+2#[j4!!3+DfpME!d#MJ!
+"E3!!"9B&@Ij3#[j3!!3+B@aTB3B#M`!$rNm#N!!#N3Vq6`!%#QPZFfJ0!T!!!!)
+d!!!&A!9NrNi#NJVq6J!%#Q0QEf`0!T)!!@m!!!9J"@2q63[q63!d-!!BEh"PER0
+cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!T%
+!!rj-!T2q5`Vq6!!%#R4[)#!0!T-!!Qi!!!9R"AB#P!+9$3+8!!)d!!!&E`9frNS
+#PJVq5J!%#QCTE'80!TB!!@d!!!9b"A8#P``#P`!2!!P[BQTPBh4c,QJ!!J!!$3+
+9!!)d!!!&C`9[rNN#Q!Vq53!%#Q0QEf`0!TJ!!@m!!!9V"@lq5![q5!!8-!!)G'9
+YF("KG'J!#(4PEA"3BA4S"[j,!!!#!S`!!J+C!TS0!TN!!Q`!!J9p"Ahq4rj'!Ij
+(!!!"rNB!!!)#QJ!#!TX#R!d#Q`!#FJ!!"Ad&L!+G!Ti0!Td!!Q)!!!9p"B3#R`+
+J$3+I!!&[!!!&I3@!rN8,rN8!*$!!%'0bHA"dEfC[E'4PFR"KG'J!%'0bHA"dEdC
+[E'4PFP"KG'J0!U!!!@d!!!@!"B-#S3`#S3!+!!3kF'9Y!!)!!!d#RJ!"E`!!!!!
+!!2j%#rj%!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!T`!!J+L!U-0!U)!!dN!!J@
+*"E2q3rj#!U3+rN-!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Ij#!!!'!U3
+!!rj"!U8#TJVq33!%#QY[Bf`0!U8!!@d!!!@0"C!!rN!+rN!!"!TKE'PK"J+Q!!2
+q2`+R!UJ+rMm!"!TTER0S$3+R!!)d!!!&N`@ErMi#U3Vq2J!%#Q0QEf`0!UN!!@m
+!!!@A"CVq23[q23!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0
+-5@jME(9NC8C[E'4PFP"KG'J'!UJ!!rim!UVq1`Vq2!!%#R4[)#!0!US!!Qi!!!@
+H"Dd#U`+X$3+V!!)d!!!&TJ@YrMS#V3Vq1J!%#QCTE'80!Ud!!@d!!!@T"D`#VJ`
+#VJ!,!!9`C@dZD!!#!!!0!U`!!M3!!!@H"DEq13+[#[ij!!3+BfC[E!d#V`!"E`!
+!"D)&TIii#rii!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'rMX!!!)#S`!#!V!#X3d
+#X!!$53!#"E3&h[ihrMB#XJVq0`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`
+"rMB!!!B#XJ!$rM8#X`+d#[ie!!3+DfpME!d#X`!"E3!!"EJ&Zrid#[id!!3+B@a
+TB3B#Y!!$rM-#Y3+f#[ic!!3+D@jcD!d#Y3!#0!!!"Ei&a[ib!VF+rM)!"!TMCQp
+X$3+h!!&[!!!&`JA&rM%,rM%!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!
+BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J+f!!2q-!+irLm+rM!!"!TdEb!J$3+
+i!!*Z!!!&b3AB!VN#ZJd#Z3!#0!!!"G%&f2iZ!VX+rLi!"!TQD@aP$3+l!!&Y!!!
+&e!AA!V`-!V`!$!!'F'9Y-LjS!!)!!!d#ZJ!#0!!!"FN&dIiY!Vd+rLd!"!TMCQp
+X$3+p!!&[!!!&c3A3rL`,rL`!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!Eq,`!!!J+
+a!!)#[J+r$3+q!!*X!!)&h`AIrL[q+J(q+`!!!IiU!!!#!Vm!!J,!!X%0!X!!!R)
+!!!AI"HS#`J,$$3,#!!*L!!!&h`AQ!X3#a3d#a!!"E`!!"Gm&i[iT#riT!#3`!""
+MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3,&!!&Y!!!&iJAP!XB
+-!XB!$3!(1R"VBh-a-J!#!!!0!X-!!@m!!!!!!!$q+![q+!!8-!!)G'9YF("KG'J
+!#(4PEA"3BA4S!J,"!!)#a`,)$3,(!!0*!!)&k`B9rLIq*J,*#[iR!"JZBfpbC@0
+bC@`U+LSU!!!!!!!!N!!!ER9XE!(q*J!!"J,*!!2q*3,+!XX+rL8!"!TVEf0X$3,
++!!&Y!!!&l`AbrL3+rL3!"!TKE'PK"J,,!!2q)`,-!Xd+rL-!"!TTER0S$3,-!!)
+d!!!&p3AprL)#cJVq)J!%#Q0QEf`0!Xi!!@m!!!Aj"Icq)3[q)3!d-!!BEh"PER0
+cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!Xd
+!!riJ!Xrq(`Vq)!!%#R4[)#!0!Xm!!Qi!!!B!"Jm#d!,4$3,3!!)d!!!'#!B2rKi
+#dJVq(J!%#QCTE'80!Y)!!@d!!!B,"Ji#d``#d`!1!!K`Df0c-6)ZD!!#!!!0!Y%
+!!M3!!!B!"JMq(3,8#[iG!!3+BfC[E!d#e!!"E`!!"J3'"riF#riF!"3`!!KdC@e
+`F'&dD!!)G'9YF&"KG'J'rKm!!!)#b!!#!Y8#eJd#e3!#E!!#"KB'&[iErKS"rKX
+!!!(q'J!!!J,@!!)#e`,B$3,A!!*b!!!'&JBK!YN#fJd#f3!#BJ!!"KB'(3,E!Y`
+0!YX!!@m!!!B@"KRq'3[q'3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4Qp
+XC'9b8'&dD!d#h!!"E3!!"KN'(!,G$!,G!!`!"MT`Df0c0`!#!!!0!YS!!@m!!!!
+!!!$q'![q'!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J,B!!)#hJ,I$3,H!!0*!!)
+')JC-rKIq&J,J#[iA!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!(q&J!!"J,
+J!!2q&3,K!Z)+rK8!"!TVEf0X$3,K!!&Y!!!'*JBTrK3+rK3!"!TKE'PK"J,L!!2
+q%`,M!Z3+rK-!"!TTER0S$3,M!!)d!!!',!BdrK)#j3Vq%J!%#Q0QEf`0!Z8!!@m
+!!!B`"M2q%3[q%3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0
+-5@jME(9NC8C[E'4PFP"KG'J'!Z3!!ri3!ZEq$`Vq%!!%#R4[)#!0!ZB!!Qi!!!B
+h"NB#j`,S$3,R!!)d!!!'2`C'rJi#k3Vq$J!%#QCTE'80!ZN!!@d!!!C#"N8#kJ`
+#kJ!0!!G`Df0c0bjS!!)!!!d#k!!#0!!!"MF'2ri0!ZX+rJd!"!TMCQpX$3,V!!&
+[!!!'1`BqrJ`,rJ`!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!Eq$`!!!J,I!!)#l!,
+Y$3,X!!*X!!)'63C0rJ[q#J(q#`!!!Ii+!!!#!Zd!!J,Z!Zm0!Zi!!R)!!!C0"PJ
+#m!,a$3,`!!*L!!!'63C8![)#m`d#mJ!"E`!!"Nd'82i*#ri*!#3`!""MFRP`G'p
+QEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3,c!!&Y!!!'8!C6![3-![3!#`!
+&1R*KEQ3!!J!!$3,a!!&[!!!!!!!!rJJ,rJJ!&$!!#(4PEA"`BA4S!!KdC@e`8'&
+dD!)#l`!#![8#pJd#p3!$53!#"PN'Jri(rJB#p`Vq"`!B,Q0[FQ9MFQ9X+LSU+J!
+!!!!!!*!!!'jeE'`"rJB!!!B#p`!$rJ8#q!,j#[i&!!3+DfpME!d#q!!"E3!!"Pd
+'B2i%#[i%!!3+B@aTB3B#q3!$rJ-#qJ,l#[i$!!3+D@jcD!d#qJ!#0!!!"Q-'Dri
+#![`+rJ)!"!TMCQpX$3,m!!&[!!!'C`CUrJ%,rJ%!0$!!''p`C@jcFfaTEQ0XG@4
+PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J,l!!2q!!,prIm
++rJ!!"!TdEb!J$3,p!!*Z!!!'EJCp![i#r`d#rJ!#0!!!"RB'IIhq!`!+rIi!"!T
+QD@aP$3-!!!&Y!!!'H3Cm!`%-!`%!$!!'FQ&ZC#jS!!)!!!d#r`!#0!!!"Qi'G[h
+p!`)+rId!"!TMCQpX$3-#!!&[!!!'FJCerI`,rI`!&$!!#(4PEA"`BA4S!!KdC@e
+`8'&dD!Epr`!!!J,f!!)$!`-%$3-$!!*X!!)'K!D%rI[pqJ(pq`!!!Ihk!!!#!`3
+!!J-&!`B0!`8!!R)!!!D%"Sm$"`-)$3-(!!*L!!!'K!D,!`N$#Jd$#3!"E`!!"S3
+'Krhj#rhj!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3-
++!!&Y!!!'K`D+!`X-!`X!#J!%1R*M-J!#!!!0!`J!!@m!!!!!!!$pq![pq!!8-!!
+)G'9YF("KG'J!#(4PEA"3BA4S!J-'!!)$$!-0$3--!!0*!!)'N!!'Z[hhrIB$$JV
+pp`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rIB!!!B$$J!$rI8$$`-3#[h
+e!!3+DfpME!d$$`!"E3!!"T3'Prhd#[hd!!3+B@aTB3B$%!!$rI-$%3-5#[hc!!3
++D@jcD!d$%3!#0!!!"TS'S[hb!a-+rI)!"!TMCQpX$3-6!!&[!!!'RJDKrI%,rI%
+!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'Efa
+NCA*3BA4S"J-5!!2pm!-8rHm+rI!!"!TdEb!J$3-8!!*Z!!!'T3Dd!a8$&Jd$&3!
+#0!!!"Ud'Y2hZ!aF+rHi!"!TQD@aP$3-A!!&Y!!!'X!Dc!aJ-!aJ!#`!&FQ-b,QJ
+!!J!!$3-@!!)d!!!'T3DYrHd$'3Vpl3!%#Q0QEf`0!aN!!@m!!!DT"Ucpl![pl!!
+8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[h[!!!#!`d!!J-D!aX0!aS!!Q`!!JDl"V[
+pkrhU!IhV!!!"rHS!!!)$'`!#!a`$(3d$(!!#FJ!!"VX'aJ-H!am0!ai!!Q)!!!D
+l"X)$)!-K$3-J!!&[!!!'Z`DqrHN,rHN!*$!!%'0bHA"dEfC[E'4PFR"KG'J!%'0
+bHA"dEdC[E'4PFP"KG'J0!b%!!@d!!!Dq"X%$)J`$)J!+!!3kFQ-d!!)!!!d$(`!
+"E`!!!!!!!2hS#rhS!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!ad!!J-M!b30!b-
+!!dN!!JE("[(pjrhQ!b8+rHF!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"ZG@aX!Ih
+Q!!!'!b8!!rhP!bB$*`Vpj3!%#QY[Bf`0!bB!!@d!!!E,"Xlpj!Vpj!!%#Q&XD@%
+'!bF!!rhM!bJ$+3Vpi`!%#QPZFfJ0!bJ!!M3!!!E4"YRpiJ-U#[hL!!3+BfC[E!d
+$+J!"E`!!"Y8'f2hK#rhK!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p
+`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B$+3!$rH!$+rhI#[hJ!!3+G'mJ)!d$+`!
+#EJ!!"Y`'k`-X!bd0!b`!!M3!!!EN"Z[phJ-Z#[hH!!3+CQPXC3d$,J!"E3!!"ZF
+'kJ-[$!-[!!X!"A*M0#jS!!)!!!d$,3!#0!!!"Y`'j2hG!c!+rGd!"!TMCQpX$3-
+`!!&[!!!'i!EMrG`,rG`!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!Eph`!!!J-N!!)
+$-3-b$3-a!!*X!!)'mJEbrG[pfJ(pf`!!!IhD!!!#!c)!!J-c!c30!c-!!R)!!!E
+b"[d$03-f$3-e!!*L!!!'mJEj!cF$1!d$0`!"E`!!"[)'pIhC#rhC!#3`!""MFRP
+`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$3-i!!&Y!!!'p3Ei!cN-!cN
+!#J!%1R*M03!#!!!0!cB!!@m!!!!!!!$pf![pf!!8-!!)G'9YF("KG'J!#(4PEA"
+3BA4S!J-d!!)$1J-l$3-k!!0*!!)'rJFSrGIpeJ-m#[hA!"JZBfpbC@0bC@`U+LS
+U!!!!!!!!N!!!ER9XE!(peJ!!"J-m!!2pe3-p!ci+rG8!"!TVEf0X$3-p!!&Y!!!
+(!JF&rG3+rG3!"!TKE'PK"J-q!!2pd`-r!d!+rG-!"!TTER0S$3-r!!)d!!!(#!F
+3rG)$33VpdJ!%#Q0QEf`0!d%!!@m!!!F-"`rpd3[pd3!d-!!BEh"PER0cE'PZBfa
+eC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!d!!!rh3!d,
+pc`Vpd!!%#R4[)#!0!d)!!Qi!!!F6"b)$3`0%$30$!!)d!!!('`FLrFi$43VpcJ!
+%#QCTE'80!d8!!@d!!!FH"b%$4J`$4J!,!!9bBc8ZD!!#!!!0!d3!!M3!!!F6"a[
+pc30(#[h0!!3+BfC[E!d$4`!"E`!!"aF('[h-#rh-!"3`!!KdC@e`F'&dD!!)G'9
+YF&"KG'J'rFm!!!)$1`!#!dJ$53d$5!!#E!!#"bN(+Ih,rFS"rFX!!!(pbJ!!!J0
+*!!)$5J0,$30+!!*b!!!(+3Fd!d`$63d$6!!#BJ!!"bN(-!01!dm0!di!!@m!!!F
+T"bcpb3[pb3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d
+$6`!"E3!!"b`(,`03$!03!!d!"cTbDA"PE@3!!J!!$300!!&[!!!!!!!!rFJ,rFJ
+!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)$5`!#!e%$8Jd$83!$53!#"c8(Arh(rFB
+$8`Vpa`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rFB!!!B$8`!$rF8$9!0
+9#[h&!!3+DfpME!d$9!!"E3!!"cN(22h%#[h%!!3+B@aTB3B$93!$rF-$9J0A#[h
+$!!3+D@jcD!d$9J!#0!!!"cm(4rh#!eJ+rF)!"!TMCQpX$30B!!&[!!!(3`G'rF%
+,rF%!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9
+'EfaNCA*3BA4S"J0A!!2p`!0CrEm+rF!!"!TdEb!J$30C!!*Z!!!(5JGC!eS$@`d
+$@J!#0!!!"e)(@Ifq!e`+rEi!"!TQD@aP$30F!!&Y!!!(93GB!ed-!ed!$J!)FQP
+`C@eN,QJ!!J!!$30E!!)d!!!(5JG5rEd$AJVp[3!%#Q0QEf`0!ei!!@m!!!G1"e(
+p[![p[!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[fr!!!#!e)!!J0I!f!0!em!!Q`
+!!JGJ"f$pZrfk!Ifl!!!"rES!!!)$B!!#!f%$BJd$B3!#FJ!!"f!(D`0M!f30!f-
+!!Q)!!!GJ"fF$C30Q$30P!!&[!!!(B!GMrEN,rEN!*$!!%'0bHA"dEfC[E'4PFR"
+KG'J!%'0bHA"dEdC[E'4PFP"KG'J0!fB!!@d!!!GM"fB$C``$C`!+!!3kFR0K!!)
+!!!d$C!!"E`!!!!!!!2fi#rfi!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J#!f)!!J0
+S!fN0!fJ!!dN!!JGX"jEpYrff!fS+rEF!'#jMEh*PBh*PE#SU+LS!!!!!!!#3!!"
+ZG@aX!Iff!!!'!fS!!rfe!fX$E!VpY3!%#QY[Bf`0!fX!!@d!!!G`"h2pY!VpY!!
+%#Q&XD@%'!f`!!rfc!fd$EJVpX`!%#QPZFfJ0!fd!!M3!!!Gf"hlpXJ0[#[fb!!3
++BfC[E!d$E`!"E`!!"hS(IIfa#rfa!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4PFR"
+KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B$EJ!$rE!$F2f[#[f`!!3+G'm
+J)!d$F!!#EJ!!"i%(N!!$F30b$30a!!)d!!!(L3H3!2fZ!h-+rDi!"!TQD@aP$30
+c!!&Y!!!(M!H2!h3-!h3!#`!&FR0K,QJ!!J!!$30b!!)d!!!(J3H*rDd$G3VpV3!
+%#Q0QEf`0!h8!!@m!!!H&"iMpV![pV!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[f
+[!!!#!fN!!J0f!hF0!hB!!Q`!!JHA"jIpUrfU!IfV!!!"rDS!!!)$G`!#!hJ$H3d
+$H!!#FJ!!"jF(SJ0k!hX0!hS!!Q)!!!HA"ji$I!0p$30m!!&[!!!(P`HDrDN,rDN
+!*$!!%'0bHA"dEfC[E'4PFR"KG'J!%'0bHA"dEdC[E'4PFP"KG'J0!hd!!@d!!!H
+D"jd$IJ`$IJ!-!!BkFh4KBfX!!J!!$30l!!&[!!!!!!!!rDJ,rDJ!&$!!#(4PEA"
+`BA4S!!KdC@e`8'&dD!)$H3!#!hm$J!d$I`!$53!#"k-(cIfRrDB$J3VpT`!B,Q0
+[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rDB!!!B$J3!$rD8$JJ1$#[fP!!3+Dfp
+ME!d$JJ!"E3!!"kF(U[fN#[fN!!3+B@aTB3B$J`!$rD-$K!1&#[fM!!3+D@jcD!d
+$K!!#0!!!"kd(YIfL!iB+rD)!"!TMCQpX$31'!!&[!!!(X3HdrD%,rD%!0$!!''p
+`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4
+S"J1&!!2pS!1(rCm+rD!!"!TdEb!J$31(!!*Z!!!(Z!I(!iJ$L3d$L!!#0!!!"m!
+(arfH!iS+rCi!"!TQD@aP$31+!!&Y!!!(``I'!iX-!iX!$3!(Fh4KBfXZD!!#!!!
+0!iN!!M3!!!Hi"m$pR31-#[fG!!3+BfC[E!d$M!!"E`!!"l`([rfF#rfF!"3`!!K
+dC@e`F'&dD!!)G'9YF&"KG'J'rCm!!!)$J!!#!id$MJd$M3!$53!#"mi(q2fErCS
+$M`VpQ`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rCS!!!B$M`!$rCN$N!!
+$N3VpQ3!%#QY[Bf`0!j!!!!&Y!!!(dJI9rCJ+rCJ!"!TKE'PK"J14!!2pP`15!j-
++rCF!"!TTER0S$315!!)d!!!(f!IJrCB$P!VpPJ!%#Q0QEf`0!j3!!@m!!!IF"pr
+pP3[pP3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9
+NC8C[E'4PFP"KG'J'!j-!!rf8!jApN`VpP!!%#R4[)#!0!j8!!Qi!!!IM"r)$PJ1
+A$31@!!)d!!!(k`IbrC)$Q!VpNJ!%#QCTE'80!jJ!!@d!!!IZ"r%$Q3`$Q3!4!!Y
+cB@CPFh4KBfXZD!!#!!!0!jF!!M3!!!IM"q[pN31D#[f4!!3+BfC[E!d$QJ!"E`!
+!"qF(k[f3!![pN!!!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!EpN`!!!J11!!)$Q`1
+F$31E!!*X!!)(q3IjrBrpMJ(pM`!!!If1!!!#!j`!!J1G!ji0!jd!!R)!!!Ij#!3
+$R`1J$31I!!*L!!!(q3J!!k%$SJd$S3!"E`!!"rN(r2f0#rf0!#3`!""MFRP`G'p
+QEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S$31L!!&Y!!!(r!Ir!k--!k-!#J!
+%1R0SB3!#!!!0!k!!!@m!!!!!!!$pM![pM!!8-!!)G'9YF("KG'J!#(4PEA"3BA4
+S!J1H!!)$T!1P$31N!!0*!!))"3J[rB[pLJ1Q#[f,!"JZBfpbC@0bC@`U+LSU!!!
+!!!!!N!!!ER9XE!(pLJ!!"J1Q!!2pL31R!kJ+rBN!"!TVEf0X$31R!!&Y!!!)#3J
+-rBJ+rBJ!"!TKE'PK"J1S!!2pK`1T!kS+rBF!"!TTER0S$31T!!)d!!!)$`JArBB
+$U`VpKJ!%#Q0QEf`0!kX!!@m!!!J6#"EpK3[pK3!d-!!BEh"PER0cE'PZBfaeC'9
+QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!kS!!rf%!kcpJ`V
+pK!!%#R4[)#!0!k`!!Qi!!!JD##N$V31Z$31Y!!)d!!!))JJTrB)$V`VpJJ!%#QC
+TE'80!km!!@d!!!JP##J$X!`$X!!,!!9cD'%ZD!!#!!!0!ki!!M3!!!JD##,pJ31
+a#[f"!!3+BfC[E!d$X3!"E`!!#"i))If!#rf!!"3`!!KdC@e`F'&dD!!)G'9YF&"
+KG'J'rB-!!!)$T3!#!l)$X`d$XJ!#E!!##$!)-2errAi"rAm!!!(pIJ!!!J1c!!)
+$Y!1e$31d!!*b!!!)-!Jl!lB$Y`d$YJ!#BJ!!#$!)0`1i!lN0!lJ!!@m!!!J`#$2
+pI3[pI3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD!d$Z3!
+"E3!!#$-)0J1k$!1k!!d!"cTdH(4IC')!!J!!$31h!!&[!!!!!!!!rA`,rA`!&$!
+!#(4PEA"`BA4S!!KdC@e`8'&dD!)$Y3!#!lX$[!d$Z`!$53!##$`)C[elrAS$[3V
+pH`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"rAS!!!B$[3!$rAN$[J1r#[e
+j!!3+DfpME!d$[J!"E3!!#%!)3rei#[ei!!3+B@aTB3B$[`!$rAF$`!2"#[eh!!3
++D@jcD!d$`!!#0!!!#%B)6[ef!m)+rAB!"!TMCQpX$32#!!&[!!!)5JK0rA8,rA8
+!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'Efa
+NCA*3BA4S"J2"!!2pG!2$rA-+rA3!"!TdEb!J$32$!!*Z!!!)83KJ!m3$a3d$a!!
+#0!!!#&N)B2eb!mB+rA)!"!TQD@aP$32'!!&Y!!!)A!KI!mF-!mF!$J!)G(KdAf4
+L,QJ!!J!!$32&!!)d!!!)83KCrA%$b!VpF3!%#Q0QEf`0!mJ!!@m!!!K9#&MpF![
+pF!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[ec!!!#!l`!!J2*!mS0!mN!!Q`!!JK
+R#'IpEreZ!Ie[!!!"r@i!!!)$bJ!#!mX$c!d$b`!#FJ!!#'F)FJ20!mi0!md!!Q)
+!!!KR#'i$c`23$322!!&[!!!)C`KUr@d,r@d!*$!!%'0bHA"dEfC[E'4PFR"KG'J
+!%'0bHA"dEdC[E'4PFP"KG'J0!p!!!@d!!!KU#'d$d3`$d3!,!!8kH$8`13!#!!!
+0!mi!!@m!!!!!!!$pE![pE!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!J2-!!)$dJ2
+6$325!!0*!!))F`LGr@[pDJ28#[eV!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9
+XE!(pDJ!!"J28!!2pD329!pB+r@N!"!TVEf0X$329!!&Y!!!)G`Kkr@J+r@J!"!T
+KE'PK"J2@!!2pC`2A!pJ+r@F!"!TTER0S$32A!!)d!!!)I3L&r@B$f3VpCJ!%#Q0
+QEf`0!pN!!@m!!!L"#)6pC3[pC3!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4
+S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'!pJ!!reN!pVpB`VpC!!%#R4[)#!
+0!pS!!Qi!!!L)#*F$f`2F$32E!!)d!!!)N!!)PreL!pd+r@)!"!TQD@aP$32G!!&
+Y!!!)N`L@!pi-!pi!$!!'H$8`15jS!!)!!!d$h!!#0!!!#)J)N!$pB32I#[eK!!3
++BfC[E!d$h`!"E`!!#)`)MreJ#reJ!"3`!!KdC@e`F'&dD!!)G'9YF&"KG'J'r@-
+!!!)$d`!#!q!$i3d$i!!$53!##*i)b2eIr9i$iJVpA`!B,Q0[FQ9MFQ9X+LSU+J!
+!!!!!!*!!!'jeE'`"r9i!!!B$iJ!$r9d$i`2N#[eG!!3+DfpME!d$i`!"E3!!#+)
+)TIeF#[eF!!3+B@aTB3B$j!!$r9X$j32Q#[eE!!3+D@jcD!d$j3!#0!!!#+J)X2e
+D!qF+r9S!"!TMCQpX$32R!!&[!!!)V!L[r9N,r9N!0$!!''p`C@jcFfaTEQ0XG@4
+PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J2Q!!2p@!2Sr9F
++r9J!"!TdEb!J$32S!!*Z!!!)X`M#!qN$kJd$k3!#0!!!#,X)`[e@!qX+r9B!"!T
+QD@aP$32V!!&Y!!!)[JM"!q`-!q`!%!!+H$8`19pfCRNZD!!#!!!0!qS!!M3!!!L
+c#,[p932Y#[e9!!3+BfC[E!d$l3!"E`!!#,F)Z[e8#re8!"3`!!KdC@e`F'&dD!!
+)G'9YF&"KG'J'r9F!!!)$i3!#!qi$l`d$lJ!#E!!##-N)bIe6r9)"r9-!!!(p8J!
+!!J2[!!)$m!2a$32`!!*b!!!)b3M8!r)$m`d$mJ!#BJ!!#-N)d!2d!r80!r3!!@m
+!!!M*#-cp83[p83!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&
+dD!d$p3!"E3!!#-`)c`2f$!2f!!d!"cTi06!jGM-!!J!!$32c!!&[!!!!!!!!r9!
+,r9!!&$!!#(4PEA"`BA4S!!KdC@e`8'&dD!)$m3!#!rF$q!d$p`!$53!##08)rre
+2r8i$q3Vp6`!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"r8i!!!B$q3!$r8d
+$qJ2l#[e0!!3+DfpME!d$qJ!"E3!!#0N)h2e-#[e-!!3+B@aTB3B$q`!$r8X$r!2
+p#[e,!!3+D@jcD!d$r!!#0!!!#0m)jre+!ri+r8S!"!TMCQpX$32q!!&[!!!)i`M
+Qr8N,r8N!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfa
+eC'9'EfaNCA*3BA4S"J2p!!2p5!2rr8F+r8J!"!TdEb!J$32r!!*Z!!!)kJMj"!!
+%!3d%!!!#0!!!#2))qIe'"!)+r8B!"!TQD@aP$33#!!&Y!!!)p3Mi"!--"!-!$J!
+)H$8`1ABc,QJ!!J!!$33"!!)d!!!)kJMbr88%"!Vp43!%#Q0QEf`0"!3!!@m!!!M
+Z#2(p4![p4!!8-!!)G'9YF("KG'J!#(4PEA"3BA4S"[e(!!!#!rJ!!J3&"!B0"!8
+!!Q`!!JN!#3$p3re#!Ie$!!!"r8)!!!)%"J!#"!F%#!d%"`!$53!##3!*+[e"r8!
+%#3Vp33!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"r8!!!!B%#3!$r6m%#J3
+,#[dr!!3+DfpME!d%#J!"E3!!#33*"rdq#[dq!!3+B@aTB3B%#`!$r6d%$!30#[d
+p!!3+D@jcD!d%$!!#0!!!#3S*%[dm"!i+r6`!"!TMCQpX$331!!&[!!!*$JN4r6X
+,r6X!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9
+'EfaNCA*3BA4S"J30!!2p1J32r6N+r6S!"!TdEb!J$332!!*Z!!!*&3NN""!%%3d
+%%!!#0!!!#4d**2di"")+r6J!"!TQD@aP$335!!&Y!!!*)!NM""--""-!#`!&Fh0
+X,QJ!!J!!$334!!)d!!!*&3NGr6F%&!Vp0`!%#Q0QEf`0""3!!@m!!!NC#4cp0J[
+p0J!H-!!0Fh0XCQpXC'9bF'&dD!!0Fh0X4QpXC'9b8'&dD!Ep13!!!J3)!!)%&33
+@$339!!0*!!)*+`P9r6Ap0!3A#[de!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9
+XE!(p0!!!"J3A!!2p-`3B""N+r6-!"!TVEf0X$33B!!&Y!!!*,`Nbr6)+r6)!"!T
+KE'PK"J3C!!2p-33D""X+r6%!"!TTER0S$33D!!)d!!!*03Npr6!%(!Vp-!!%#Q0
+QEf`0""`!!@m!!!Nj#6cp,`[p,`!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4
+S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'""X!!rdZ""hp,3Vp,J!%#R4[)#!
+0""d!!Qi!!!P!#8m%(J3I$33H!!)d!!!*5!P2r5`%)!Vp,!!%#QCTE'80"#!!!@d
+!!!P,#8i%)3`%)3!-!!CcFf`b,QJ!!J!!$33I!!)d!!!*3!P)r5X%)JVp+`!%#Q0
+QEf`0"#)!!@m!!!P%#8Ip+J[p+J!H-!!0Fh0XCQpXC'9bF'&dD!!0Fh0X4QpXC'9
+b8'&dD!Ep,3!!!J3@!!)%)`3N$33M!!0*!!)*9JQ!r5Rp+!3P#[dT!"JZBfpbC@0
+bC@`U+LSU!!!!!!!!N!!!ER9XE!(p+!!!"J3P!!2p*`3Q"#F+r5F!"!TVEf0X$33
+Q!!&Y!!!*@JPGr5B+r5B!"!TKE'PK"J3R!!2p*33S"#N+r58!"!TTER0S$33S!!)
+d!!!*B!PSr53%+JVp*!!%#Q0QEf`0"#S!!@m!!!PN#@Ip)`[p)`!d-!!BEh"PER0
+cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'"#N
+!!rdL"#[p)3Vp)J!%#R4[)#!0"#X!!Qi!!!PV#AS%,!3Y$33X!!)d!!!*F`Pkr5!
+%,JVp)!!%#QCTE'80"#i!!@d!!!Pf#AN%,``%,`!0!!GcFf`b-bjS!!)!!!d%,3!
+#0!!!#@X*FrdI"$!+r4m!"!TMCQpX$33`!!&[!!!*E`Pbr4i,r4i!(M!!$A0cE'C
+[E'4PFR"KG'J!$A0cE%C[E'4PFP"KG'J'r5%!!!)%*!!#"$%%-Jd%-3!$53!##B%
+*UrdGr4`%-`Vp(3!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"r4`!!!B%-`!
+$r4X%0!3e#[dE!!3+DfpME!d%0!!"E3!!#B8*L2dD#[dD!!3+B@aTB3B%03!$r4N
+%0J3h#[dC!!3+D@jcD!d%0J!#0!!!#BX*NrdB"$J+r4J!"!TMCQpX$33i!!&[!!!
+*M`Q5r4F,r4F!0$!!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%P
+ZBfaeC'9'EfaNCA*3BA4S"J3h!!2p&J3jr48+r4B!"!TdEb!J$33j!!*Z!!!*PJQ
+P"$S%1`d%1J!#0!!!#Ci*TId8"$`+r43!"!TQD@aP$33m!!&Y!!!*S3QN"$d-"$d
+!$!!'Fh0X-bjS!!)!!!d%1`!#0!!!#CB*R[d6"$i+r4-!"!TMCQpX$33q!!&[!!!
+*QJQGr4),r4)!(M!!$A0cE'C[E'4PFR"KG'J!$A0cE%C[E'4PFP"KG'J'r48!!!)
+%-J!#"$m%3!d%2`!$53!##D`*e[d4r4!%33Vp%3!B,Q0[FQ9MFQ9X+LSU+J!!!!!
+!!*!!!'jeE'`"r4!!!!B%33!$r3m%3J4$#[d2!!3+DfpME!d%3J!"E3!!#E!*Xrd
+1#[d1!!3+B@aTB3B%3`!$r3d%4!4&#[d0!!3+D@jcD!d%4!!#0!!!#EB*[[d-"%B
++r3`!"!TMCQpX$34'!!&[!!!*ZJQpr3X,r3X!0$!!''p`C@jcFfaTEQ0XG@4PCQp
+XC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*3BA4S"J4&!!2p#J4(r3N+r3S
+!"!TdEb!J$34(!!*Z!!!*`3R3"%J%53d%5!!#0!!!#FN*d2d)"%S+r3J!"!TQD@a
+P$34+!!&Y!!!*c!R2"%X-"%X!$!!'G'ac-5jS!!)!!!d%53!#0!!!#F%*bId("%`
++r3F!"!TMCQpX$34-!!&[!!!*a3R)r3B,r3B!(M!!$A0cE'C[E'4PFR"KG'J!$A0
+cE%C[E'4PFP"KG'J'r3N!!!)%3!!#"%d%6Jd%63!#E!!##GF*erd&r33"r38!!!(
+p"!!!!J41!!)%6`43$342!!0*!!)*e`S"r32p!J44#[d$!"JZBfpbC@0bC@`U+LS
+U!!!!!!!!N!!!ER9XE!(p!J!!"J44!!2p!345"&-+r3%!"!TVEf0X$345!!&Y!!!
+*f`RHr3!+r3!!"!TKE'PK"J46!!2mr`48"&8+r2m!"!TTER0S$348!!)d!!!*i3R
+Tr2i%9JVmrJ!%#Q0QEf`0"&B!!@m!!!RP#HMmr3[mr3!d-!!BEh"PER0cE'PZBfa
+eC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9NC8C[E'4PFP"KG'J'"&8!!rcm"&I
+mq`Vmr!!%#R4[)#!0"&F!!Qi!!!RX#IX%@!4C$34B!!)d!!!*p!Rlr2S%@JVmqJ!
+%#QCTE'80"&S!!@d!!!Rh#IS%@``%@`!1!!KMFRP`G'mZD!!#!!!0"&N!!M3!!!R
+X#I6mq34F#[cj!!3+BfC[E!d%A!!"E`!!#I!*mrci#rci!#3`!""MFRP`G'pQEfa
+NCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S"[cl!!!#"&!!!J4G"&i0"&d!!Q`!!JS
+##J,mprcf!Ich!!!"r2B!!!)%AJ!#"&m%B!d%A`!$53!##J)+,2cer23%B3Vmp3!
+B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"r23!!!B%B3!$r2-%BJ4M#[cc!!3
++DfpME!d%BJ!"E3!!#JB+#Icb#[cb!!3+B@aTB3B%B`!$r2%%C!4P#[ca!!3+D@j
+cD!d%C!!#0!!!#J`+&2c`"'B+r2!!"!TMCQpX$34Q!!&[!!!+%!S6r1m,r1m!0$!
+!''p`C@jcFfaTEQ0XG@4PCQpXC'9bF'&dD!!BEh"PEP066%PZBfaeC'9'EfaNCA*
+3BA4S"J4P!!2mlJ4Rr1d+r1i!"!TdEb!J$34R!!*Z!!!+&`SQ"'J%D3d%D!!#0!!
+!#Km+*[cX"'S+r1`!"!TQD@aP$34U!!&Y!!!+)JSP"'X-"'X!%!!+Eh"PER0cE(B
+ZD!!#!!!0"'N!!M3!!!SA#Krmk`4X#[cV!!3+BfC[E!d%E!!"E`!!#KX+([cU#rc
+U!#3`!""MFRP`G'pQEfaNCA*`BA4S!""MFRP`G'p'EfaNCA*3BA4S"[cY!!!#"'!
+!!J4Y"'i0"'d!!dN!!JSY#PImkIcS"'m+r1N!'#jMEh*PBh*PE#SU+LS!!!!!!!#
+3!!"ZG@aX!IcS!!!'"'m!!rcR"(!%F3Vmj`!%#QY[Bf`0"(!!!@d!!!Sa#M6mjJV
+mjJ!%#Q&XD@%'"(%!!rcP"()%F`Vmj3!%#QPZFfJ0"()!!M3!!!Sh#Mrmj!4d#[c
+N!!3+BfC[E!d%G!!"E`!!#MX+2[cM#rcM!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4
+PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B%F`!$r1)%GIcK#[cL!!3
++G'mJ)!d%G3!#EJ!!#N)+834f"(F0"(B!!M3!!!T+#P(mi!4i#[cJ!!3+CQPXC3d
+%H!!"E3!!#Nd+8!4j$!4j!!i!#(4YC'PQCLjS!!)!!!d%G`!#0!!!#N)+5[cI"(S
++r0m!"!TMCQpX$34k!!&[!!!+4JT*r0i,r0i!*$!!%'0bHA"dEfC[E'4PFR"KG'J
+!%'0bHA"dEdC[E'4PFP"KG'J'r1%!!!)%EJ!#"(X%I!d%H`!#E!!##PJ+@2cGr0`
+"r0d!!!(mh!!!!J4m!!)%I34q$34p!!*X!!)+@!TBr0[mfJ(mf`!!!IcD!!!#"(i
+!!J4r")!0"(m!!dN!!JTB#S,mfIcB")%+r0N!'#jMEh*PBh*PE#SU+LS!!!!!!!#
+3!!"ZG@aX!IcB!!!'")%!!rcA"))%J`Vme`!%#QY[Bf`0"))!!@d!!!TF#PrmeJV
+meJ!%#Q&XD@%'")-!!rc9")3%K3Vme3!%#QPZFfJ0")3!!M3!!!TL#QVme!5'#[c
+8!!3+BfC[E!d%KJ!"E`!!#QB+DIc6#rc6!$3`!"K[F'9ZFh0XD@jME(9NC@C[E'4
+PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD!B%K3!$r0)%Krc4#[c5!!3
++G'mJ)!d%K`!#EJ!!#Qd+I!5)")N0")J!!M3!!!Te#Rcmd!5+#[c3!!3+CQPXC3d
+%LJ!"E3!!#RJ+H`5,$!5,!!`!"Q9IEh-ZD!!#!!!0")N!!M3!!!TY#RAmc`5-#[c
+2!!3+BfC[E!d%M!!"E`!!#R%+G2c1#rc1!#B`!"&[F'9ZFh0XCQpXC'9bF'&dD!!
+4Eh"PER0cE%C[E'4PFP"KG'J'r0%!!!)%J!!#")d%MJd%M3!$53!##S-+VIc0r-`
+%M`Vmc3!B,Q0[FQ9MFQ9X+LSU+J!!!!!!!*!!!'jeE'`"r-`!!!B%M`!$r-X%N!!
+%N3Vmb`!%#QY[Bf`0"*!!!!&Y!!!+K`U+r-S+r-S!"!TKE'PK"J54!!2mb355"*-
++r-N!"!TTER0S$355!!)d!!!+M3U9r-J%P!Vmb!!%#Q0QEf`0"*3!!@m!!!U4#T6
+ma`[ma`!d-!!BEh"PER0cE'PZBfaeC'9QEfaNCA*`BA4S!"K[F'9Z8e0-5@jME(9
+NC8C[E'4PFP"KG'J'"*-!!rc'"*Ama3VmaJ!%#R4[)#!0"*8!!Qi!!!UB#UF%PJ5
+A$35@!!)d!!!+S!URr-3%Q!Vma!!%#QCTE'80"*J!!@d!!!UM#UB%Q3`%Q3!0!!G
+PAfpc-LjS!!)!!!d%P`!#0!!!#TJ+S2c$"*S+r--!"!TMCQpX$35D!!&[!!!+R!U
+Ir-),r-)!*M!!%@p`C@jcFfaQEfaNCA*`BA4S!"&[F'9ZFh0X4QpXC'9b8'&dD!E
+ma3!!!J51!!)%Qrc"$35E!!*X!!)+VJUZr-$m[`(m`!!!!Ibr!!!#r-%!!!d!#3!
+"E3!!!!!!!3!I!Irq!!!#!!B!!J5F"*d0"*`!!Q`!!J!!!!$m[[bp!Ibq!!!"r,d
+!!!)%R3!#"*i%R`d%RJ!#E!!##V%+b!5Jr,`0"+!!!dN!!JUa#XMmZ`5K"+)+r,X
+!'#jcHA0[C'a[Cf&cDh)!!!!!!!!!!&4&@&30"+%!!@d!!!Ua#V3%S``%S`!'!!!
+!!J!!"J5L!!2mZJ5N"+8+r,S!"!TLG'jc$35N!!&+!!!+Y`Um"+B#"+B!!J5Rr,N
+0"+F!!@d!!!Uh#VS%U!`%U!!+!!4%EfjP!!)!!!,mZ3!!"J5P!!2mZ!5Tr,F+r,J
+!"!TRDACe$35T!!&Y!!!+[`V#r,B$r,B!"3EmY`!!!Ibm!!!#"*m!!J5Ur,80"+S
+!!Q`!!J!!!!$mY2bc!Ibd!!!"r,-!!!,mY3!!$J!#!!!2%!!$!",mXJ5V"+`%V35
+Z"+m%X!5a",)%X`5d",8%YJ5hr,(mX2b[r+i"r,)!!"!%U`!3r+hmV2bVr+VmUIb
+Sr+ImT[bPr+6mSrbLr+(mS2bIr*i+r+d!'#jKCACdEf&`F'jeE'`!!)!!!!#3!!!
+U+LSU#rbX!")`!!GdD'9`BA4S!!GdD'93BA4S#rbV!"``!!adD'9[E'4NC@aTEA-
+!$(4SC8pXC%4PE'PYF`[mUJ!J-!!1G'KPF(*[DQ9MG("KG'J!$R4SC9"bEfTPBh4
+3BA4S#rbT!"B`!!PdD'9YCA"KG'J!#A4SC8eP8'&dD![mU!!Q-!!4D@jME(9NC@C
+[E'4PFR"KG'J!%@PZBfaeC'9'EfaNCA*3BA4S#rbR!$3`!"K[F'9ZFh0XD@jME(9
+NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&dD![mTJ!N-!!3Bh*
+jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD![mT3!H-!!0Fh0XCQpXC'9
+bF'&dD!!0Fh0X4QpXC'9b8'&dD![mT!!Q-!!4Eh"PER0cE'C[E'4PFR"KG'J!%@p
+`C@jcFfa'EfaNCA*3BA4S#rbM!#i`!"9dD'9ZCAGQEfaNCA*bC@CPFQ9ZBf8!&A4
+SC8jPGdC[E'4PFP*PCQ9bC@jMC3[mSJ!8-!!)G'9YF("KG'J!#(4PEA"3BA4S!Ib
+K!!!"r+!!!!(mR`!!!IbH!!!1"+`!"a$mR35ir*cmQ`5j",VmQJVmR3!B,Q&PGR4
+[BA"`ER9XE!!!J!!!!*!!!#SU+LS0",J!!@X!!!!!#XJ%Z`)%Z`!#!!8%[!)%[!!
+#"*lmQ3,mQ3!!!IbF!!!#r*X!!"!%Z3!!%!5k!)B!(rbBr*ImP[b9r*6mNrb5!#c
+mNIb3!2b2r)lmMIb-!%rmL`"D!&[mLJ"Nr)N!EIb)r)ImKJ#2r)AmK2b$r),mJIb
+!r(rmI[apr(cmH`#Tr(VmHIair(F![Iaf!-ImG3$8!1)!l!$j!3-"%!%D!5F"-3%
+q!8J"93&I!@`"GJ'$!Bd"QJ'N!E%"Z`()!G)"h`(T!IB#!!)0!KF#*!)Z!MX#43*
+5!P`#D3*c!S!#LJ+A!U%#VJ+m!XB#d`,G!ZS#p!-"!`X$'!-L!bm$130'!e!$A30
+R!h3$IJ1,!jN$S`1`!lS$a`24!pi$l!2f"!-%%`3K"#m%234,"&X%D`4j")X%Q35
+Mr(3%U2acr(,mF3VmQ!!%#Q0[BQS+r*F!'#jPBA*cCQCNFQ&XDA-!!!!!!!!J!'&
+QC()+r*B!"!TMG(Kd#rb9!")`!!GdD'9`BA4S!!GdD'93BA4S#[b8!!3+BA0MFJV
+mN`!%#R4iC'`,r*)!($!!$(4SC@pXC'4PE'PYF`!-G'KP6faN4'9XD@ec#[b4!!3
++BfPdE32mN!$rr3[mM`!J-!!1G'KPF(*[DQ9MG("KG'J!$R4SC9"bEfTPBh43BA4
+S!rb1rri+r)d!"!T849K8#rb-!"B`!!PdD'9YCA"KG'J!#A4SC8eP8'&dD![mL`!
+Q-!!4D@jME(9NC@C[E'4PFR"KG'J!%@PZBfaeC'9'EfaNCA*3BA4S#rb+!$3`!"K
+[F'9ZFh0XD@jME(9NC@C[E'4PFR"KG'J!''p`C@j68da*EQ0XG@4P4QpXC'9b8'&
+dD![mL3!N-!!3Bh*jF(4[CQpXC'9bF'&dD!!3Bh*jF(4[4QpXC'9b8'&dD![mL!!
+H-!!0Fh0XCQpXC'9bF'&dD!!0Fh0X4QpXC'9b8'&dD![mK`!Q-!!4Eh"PER0cE'C
+[E'4PFR"KG'J!%@p`C@jcFfa'EfaNCA*3BA4S#[b'!!3+BfC[E!VmK3!B,QeTFf0
+cE'0d+LSU+J!!!!!!!*!!!#SU+LS+r)3!"!TcC@aP#[b$!"JZBfpbC@4PE'mU+LS
+U!!!!!!!!N!!!+LSU+J(mJJ!!![b"!!!+r)!!"!TVEf0X#[ar!!3+D@jcD!2mIJ!
+%#[ap!"JZBfpbC@0bC@`U+LSU!!!!!!!!N!!!ER9XE!VmI!!%#R*cE(3,r(X!,M!
+!&A4SC@jPGfC[E'4PFR*PCQ9bC@jMC3!9G'KP6Q9h4QpXC'9b8Q9QCA*PEQ0P#[a
+k!!3+F'jKE3VmH3!%#Q&XD@%+r(J!"!TdEb!J#[ah!!3+CQPXC32mGJ!'#rae!"3
+`!!KdC@e`F'&dD!!)G'9YF&"KG'J+r(3!"!TLG'jc#[ac!!3+CfPfG32mFJ!&#[a
+a!"JZFhPcEf4XEfGKFfYb!!!!!!!!!!"849K8%IbD#XRJ%JUYi1%TDJ`!!LrM*N9
+4e%r&jLa&edrSaHBX4Nr%@qPF@eTVA&VU-NAE6m4Ek9aE@QYF@Z`bl5C&hNr,lbA
+Y*N9J!""2bf%!%59K!")Pl5C&B!!66mYK!"3Pl5C&B!!96mYK!"BPl5C&B!!A6m[
+Y*N9J!"K2amAQ,%C2&!!L+Q%!'9m!%#pK!"PK!"S[DJ`!'dmUB3!F,'S-!"eA!!K
+B!"i!(fK2+Q%!)'%!'@%!)5TK!"PI!"![B3!L$!!M6em!*%9J!#92A`!PDJ`!'dp
+K!#BUB3!F,'%!*ba'6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"R1,f%!+Q%!+bp
+K!#`-!#02A`!9B3!Y*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,Lp
+K!#TK!#m[B3!X$!!M6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3!
+`,f%!,!`!)dpI!"9K!$%P4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!
+Z,f%!+Q%!-LpK!#`-!#02A`!9B3!c*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!
+T+Q%!'9m!,LpK!#TK!$3[B3!X$!!M6em!&@%!059&B!!Z6bTK!#"K!#KK!#%UB3!
+CA`!6,f%!+5TK!"PI!#i[B3!UB3!f,f%!,!`!)dpI!"9K!$FP4@!!,NmUB3!JB3!
+SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!1#pK!#`-!#02A`!9B3!j*89J!#j
+2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!$S[B3!X$!!M6em!&@%
+!1b9&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3!m,f%!,!`
+!)dpI!"9K!$dP4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%
+!2LpK!#`-!#02A`!9B3!r*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m
+!,LpK!#TK!%![B3!X$!!M6em!&@%!359&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%
+!+5TK!"PI!#i[B3!UB3"#,f%!,!`!)dpI!"9K!%-P4@!!,NmUB3!JB3!SB3!K+Q%
+!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!4#pK!#`-!#02A`!9B3"&*89J!#j2+Q%!)'%
+!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!%B[B3!X$!!M6em!&@%!4b9&B!!
+Z6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3"),f%!,!`!)dpI!"9
+K!%NP4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!5LpK!#`
+-!#02A`!9B3",*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#T
+K!%`[B3!X$!!M6em!&@%!659&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"P
+I!#i[B3!UB3"1,f%!,!`!)dpI!"9K!%mP4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bp
+K!#NUB3!CA`!Z,f%!+Q%!8#pK!#`-!#02A`!9B3"4*89J!#j2+Q%!)'%!+'%!)5T
+K!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!&)[B3!X$!!M6em!&@%!8b9&B!!Z6bTK!#"
+K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3"8,f%!,!`!)dpI!"9K!&8P4@!
+!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!9LpK!#`-!#02A`!
+9B3"A*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!&J[B3!
+X$!!M6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3"C,f%!,!`!)dp
+I!"9K!&SP4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!@bp
+K!#`-!#02A`!9B3"F*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,Lp
+K!#TK!&d[B3!X$!!M6em!&@%!AL9&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5T
+K!"PI!#i[B3!UB3"I,f%!,!`!)dpI!"9K!'!P4@!!,NmUB3!JB3!SB3!K+Q%!'9m
+!%bpK!#NUB3!CA`!Z,f%!+Q%!B5pK!#`-!#02A`!9B3"L*89J!#j2+Q%!)'%!+'%
+!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!'-[B3!X$!!M6em!&@%!C#9&B!!Z6bT
+K!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3"P,f%!,!`!)dpI!"9K!'B
+P4@!!,NmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!CbpK!#`-!#0
+2A`!9B3"S*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!,LpK!#TK!'N
+[B3!X$!!M6em!&@%!DL9&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!#i
+[B3!UB3"V,f%!,!`!)dmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%
+!E#pK!#`-!#02A`!9B3"Y*89J!#j2+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m
+!,LpK!#TK!'i[B3!X$!!M6em!&@%!Eb9&B!!Z6bTK!#"K!#KK!#%UB3!CA`!6,f%
+!+5TK!"PI!#i[B3!UB3"`,f%!,!`!)dpI!"9K!(%P4@!!,NmUB3!JB3!SB3!K+Q%
+!'9m!%bpK!#NUB3!CA`!Z,f%!+Q%!FLpK!#`-!#02+Q%!)'%!+'%!)5TK!"PI!"-
+[B3!T+Q%!'9m!,LpK!#TK!(-[B3!X$!!M6em!&@%!G#9&B!!Z6bTK!#"K!#KK!#%
+UB3!CA`!6,f%!+5TK!"PI!#i[B3!UB3"e,f%!,!`!)dmUB3!JB3!SB3!K+Q%!'9m
+!%bpK!#NUB3!CA`!A,f%!+Q%!GLpK!#`-!#02+Q%!)'%!+'%!)5TK!"PI!"-[B3!
+T+Q%!'9m!&bpK!#TK!(F[B3!X$!!M6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"P
+I!"F[B3!UB3"i,f%!,!`!)dmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!A,f%
+!+Q%!H5pK!#`-!#02+Q%!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!&bpK!#TK!(S
+[B3!X$!!M6bTK!#"K!#KK!#%UB3!CA`!6,f%!+5TK!"PI!"8[B3!UB3"l,f%!,!`
+!)dmUB3!JB3!SB3!K+Q%!'9m!%bpK!#NUB3!CA`!9,f%!+Q%!I#pK!#`-!#02+Q%
+!)'%!+'%!)5TK!"PI!"-[B3!T+Q%!'9m!&5pK!#TK!(d[B3!X$!!M6bTK!#"K!#K
+K!#%UB3!CA`!6,f%!+5TK!"PI!"J[B3!UB3"q,f%!,!`!)dmUB3!JB3!SB3!K+Q%
+!'9m!%bpK!#NUB3!CA`!B,f%!+Q%!IbpK!#`-!#028&92B3#!B3#"B3##DhCK!)0
+K!)4K!#)-!)82$!5Y!&%!5deKBfPZG'pcD#")4$T%CA0VG'p`)%C[E'4PFMT*EQ0
+[E@PZCcT[F'9ZFh0X,90139!Y-6Nj16%b-6%k6@&M6e-kE@YXD@jVFbjKF`!#!!!
+1"+i!!J6mF!5p!ra`!!%1",d!!3!%[J`%[J!'!!!!!J!!$J5[!!)%r'm%[`2mE`!
+%$J5r!!3!"-!%`36#"---"-!!%J!-6@&MD@jdEh0S)%K%!!)!!!`%`3!8!!j%CA0
+VG'p`)%C[E'4PFJ!#!!!-"-)!$J!)5@jMEfeTEQF!!J!!$!6$!"X!&@p`C@jcFf`
+Y8dj"8#da16Nj-6)a-3!#!!!-",!!4J"!6@&MD@jdEh0S)%K%1N4PFfYdEh!J4Qp
+XC'9b1NPZBfpYD@jR1Qp`C@jcFf`Y8dj"8#da16Nj-6)a-6T0B@028`!#!!!-",%
+!5!"#6@&MD@jdEh0S)%K%1N4PFfYdEh!J4QpXC'9b1NPZBfpYD@jR1Qp`C@jcFf`
+Y8dj"8#da16Nj-6)a-6TTEQ0XG@4P!!)!!!`%XJ"3!%T0B@0TER4[FfJJ5%3k4'9
+cDh4[F#"'EfaNCA)k5@jMEfeTEQFkEh"PER0cE#e66N&3,6%j16Na-M%a1QPZBfa
+eC'8kEh"PER0cE!!#!!!-",-!4`""6@&MD@jdEh0S)%K%1N4PFfYdEh!J4QpXC'9
+b1NPZBfpYD@jR1Qp`C@jcFf`Y8dj"8#da16Nj-6)a-6TMFRP`G'm!!J!!$!5d!%3
+!2NeKBfPZG'pcD#")4$T%CA0VG'p`)%C[E'4PFMT*EQ0[E@PZCcT[F'9ZFh0X,90
+139!Y-6Nj16%b-6%kFh0X!!)!!!`%Y3"!!$T0B@0TER4[FfJJ5%3k4'9cDh4[F#"
+'EfaNCA)k5@jMEfeTEQFkEh"PER0cE#e66N&3,6%j16Na-M%a!!)!!!i%YJ!"&!6
+%$J6%!!-B"-AmEJ6'$J6&!!-B"-ImE36)$J6(!!-B"-RmE!6+$J6*!!-B!"rmD`6
+,#[aV!!3+BfC[E!`%b`!1!!K*EQ0[E@PZC`!#!!!+r'`!"!TMCQpX$!6+!"X!&@p
+`C@jcFf`Y8dj"8#da16Nj-6)a-3!#!!!+r'd!"!TMCQpX$!6)!!d!"fPZBfaeC'8
+!!J!!#[aZ!!3+BfC[E!`%aJ!9!!peER4TG'aPC#"QEfaNCA)!!J!!$!5h!%i!5%e
+KBfPZG'pcD#")4$T%CA0VG'p`)%C[E'4PFMT*EQ0[E@PZCcT[F'9ZFh0X,90139!
+Y-6Nj16%b-6%kBh*jF(4[1RJe-$Pf-`!#!!!"r,%!!!(mX!!!!Ib[!!!"r+i!!'&
+cBh)!!3!-qYlHV3!!!3!!!*G#!!#@3J!!!AB!!$-8-0J!!!!F!AB!$h0MFhS!!!#
+#6Np853!!!)jcBh"d!!!!QP4&@&3!!3#QFh4jE!!!!,j$6d4&!!%!bN*14%`!!!$
+LBA"XG!!!!1j'8N9'!!!!qNP$6L-!!!%'D@0X0!!!!4*TBh-M!!!"(QPMFc3!!!%
+UD'CNFJ!!!6C659T&!!!"3PG3Eh-!!!&1!!$rr`!!!!!!!!!!!)$rre!!!"i!!!!
+!!)$rr`!!"cJ#DH#m"'Mrr`!!!*S!!!!!%iRrr`!!"Pi!!!!!"'Mrr`!!!53!!!!
+!!!$rrb!!!9)!!!!!!!(rra3!!@i#DG`%!)$rr`!!!Pi#DH"X!!$rr`!!!Ri!!!!
+!!)$rr`!!!S-#DH"d!*Err`!!!Si!!!!!!*Err`!!!j)!!!!!!*Err`!!"CB#DH%
+i!*Err`!!"GS#DH%dkF$rr`!!"[`!!!!!rrrrr`!!"a)!!!!!!)$rr`!!"b!!!!!
+!*4S:
diff -Nur libressl-3.1.0/MacOS/opensslconf.h libressl-3.1.0-apple/MacOS/opensslconf.h
--- libressl-3.1.0/MacOS/opensslconf.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/MacOS/opensslconf.h	2013-02-04 23:33:20.000000000 +0100
@@ -0,0 +1,116 @@
+/* MacOS/opensslconf.h */
+
+#if !(defined(VMS) || defined(__VMS)) /* VMS uses logical names instead */
+#if defined(HEADER_CRYPTLIB_H) && !defined(OPENSSLDIR)
+#define OPENSSLDIR "/usr/local/ssl"
+#endif
+#endif
+
+#if defined(HEADER_IDEA_H) && !defined(IDEA_INT)
+#define IDEA_INT unsigned int
+#endif
+
+#if defined(HEADER_MD2_H) && !defined(MD2_INT)
+#define MD2_INT unsigned int
+#endif
+
+#if defined(HEADER_RC2_H) && !defined(RC2_INT)
+/* I need to put in a mod for the alpha - eay */
+#define RC2_INT unsigned int
+#endif
+
+#if defined(HEADER_RC4_H)
+#if !defined(RC4_INT)
+/* using int types make the structure larger but make the code faster
+ * on most boxes I have tested - up to %20 faster. */
+/*
+ * I don't know what does "most" mean, but declaring "int" is a must on:
+ * - Intel P6 because partial register stalls are very expensive;
+ * - elder Alpha because it lacks byte load/store instructions;
+ */
+#define RC4_INT unsigned char
+#endif
+#if !defined(RC4_CHUNK)
+/*
+ * This enables code handling data aligned at natural CPU word
+ * boundary. See crypto/rc4/rc4_enc.c for further details.
+ */
+#define RC4_CHUNK unsigned long
+#endif
+#endif
+
+#if defined(HEADER_DES_H) && !defined(DES_LONG)
+/* If this is set to 'unsigned int' on a DEC Alpha, this gives about a
+ * %20 speed up (longs are 8 bytes, int's are 4). */
+#ifndef DES_LONG
+#define DES_LONG unsigned long
+#endif
+#endif
+
+#if defined(HEADER_BN_H) && !defined(CONFIG_HEADER_BN_H)
+#define CONFIG_HEADER_BN_H
+#if __option(longlong)
+#  define BN_LLONG
+#else
+#  undef BN_LLONG
+#endif
+
+/* Should we define BN_DIV2W here? */
+
+/* Only one for the following should be defined */
+/* The prime number generation stuff may not work when
+ * EIGHT_BIT but I don't care since I've only used this mode
+ * for debuging the bignum libraries */
+#undef SIXTY_FOUR_BIT_LONG
+#undef SIXTY_FOUR_BIT
+#define THIRTY_TWO_BIT
+#undef SIXTEEN_BIT
+#undef EIGHT_BIT
+#endif
+
+#if defined(HEADER_RC4_LOCL_H) && !defined(CONFIG_HEADER_RC4_LOCL_H)
+#define CONFIG_HEADER_RC4_LOCL_H
+/* if this is defined data[i] is used instead of *data, this is a %20
+ * speedup on x86 */
+#undef RC4_INDEX
+#endif
+
+#if defined(HEADER_BF_LOCL_H) && !defined(CONFIG_HEADER_BF_LOCL_H)
+#define CONFIG_HEADER_BF_LOCL_H
+#define BF_PTR
+#endif /* HEADER_BF_LOCL_H */
+
+#if defined(HEADER_DES_LOCL_H) && !defined(CONFIG_HEADER_DES_LOCL_H)
+#define CONFIG_HEADER_DES_LOCL_H
+/* the following is tweaked from a config script, that is why it is a
+ * protected undef/define */
+#ifndef DES_PTR
+#define DES_PTR
+#endif
+
+/* This helps C compiler generate the correct code for multiple functional
+ * units.  It reduces register dependancies at the expense of 2 more
+ * registers */
+#ifndef DES_RISC1
+#define DES_RISC1
+#endif
+
+#ifndef DES_RISC2
+#undef DES_RISC2
+#endif
+
+#if defined(DES_RISC1) && defined(DES_RISC2)
+YOU SHOULD NOT HAVE BOTH DES_RISC1 AND DES_RISC2 DEFINED!!!!!
+#endif
+
+/* Unroll the inner loop, this sometimes helps, sometimes hinders.
+ * Very mucy CPU dependant */
+#ifndef DES_UNROLL
+#define DES_UNROLL
+#endif
+
+#endif /* HEADER_DES_LOCL_H */
+
+#ifndef __POWERPC__
+#define MD32_XARRAY
+#endif
diff -Nur libressl-3.1.0/crypto/dso/dso_dlfcn.c libressl-3.1.0-apple/crypto/dso/dso_dlfcn.c
--- libressl-3.1.0/crypto/dso/dso_dlfcn.c	2017-11-14 17:25:15.000000000 +0100
+++ libressl-3.1.0-apple/crypto/dso/dso_dlfcn.c	2020-04-21 08:47:20.000000000 +0200
@@ -282,8 +282,13 @@
 	return (merged);
 }
 
+#ifdef _APPLE__
+#define DSO_ext ".dylib"
+#define DSO_extlen 6
+#else 
 #define DSO_ext	".so"
 #define DSO_extlen 3
+#endif
 
 static char *
 dlfcn_name_converter(DSO *dso, const char *filename)
diff -Nur libressl-3.1.0/crypto/err/err.c libressl-3.1.0-apple/crypto/err/err.c
--- libressl-3.1.0/crypto/err/err.c	2019-10-27 15:22:15.000000000 +0100
+++ libressl-3.1.0-apple/crypto/err/err.c	2020-04-21 08:40:52.000000000 +0200
@@ -129,7 +129,13 @@
 
 static void ERR_STATE_free(ERR_STATE *s);
 #ifndef OPENSSL_NO_ERR
-static ERR_STRING_DATA ERR_str_libraries[] = {
+#if __APPLE__
+#define CONST_DATA const // we want to mark these items const on OSX
+#else
+#define CONST_DATA       // but not on Windows
+#endif
+
+CONST_DATA static ERR_STRING_DATA ERR_str_libraries[] = {
 	{ERR_PACK(ERR_LIB_NONE,0,0),		"unknown library"},
 	{ERR_PACK(ERR_LIB_SYS,0,0),		"system library"},
 	{ERR_PACK(ERR_LIB_BN,0,0),		"bignum routines"},
@@ -162,7 +168,7 @@
 	{0, NULL},
 };
 
-static ERR_STRING_DATA ERR_str_functs[] = {
+CONST_DATA static ERR_STRING_DATA ERR_str_functs[] = {
 	{ERR_PACK(0,SYS_F_FOPEN, 0),     	"fopen"},
 	{ERR_PACK(0,SYS_F_CONNECT, 0),		"connect"},
 	{ERR_PACK(0,SYS_F_GETSERVBYNAME, 0),	"getservbyname"},
@@ -176,7 +182,7 @@
 	{0, NULL},
 };
 
-static ERR_STRING_DATA ERR_str_reasons[] = {
+CONST_DATA static ERR_STRING_DATA ERR_str_reasons[] = {
 	{ERR_R_SYS_LIB,				"system lib"},
 	{ERR_R_BN_LIB,				"BN lib"},
 	{ERR_R_RSA_LIB,				"RSA lib"},
diff -Nur libressl-3.1.0/crypto/pkcs12/p12_crt.c libressl-3.1.0-apple/crypto/pkcs12/p12_crt.c
--- libressl-3.1.0/crypto/pkcs12/p12_crt.c	2018-12-04 11:49:18.000000000 +0100
+++ libressl-3.1.0-apple/crypto/pkcs12/p12_crt.c	2020-04-21 08:49:01.000000000 +0200
@@ -91,6 +91,7 @@
 	int i;
 	unsigned char keyid[EVP_MAX_MD_SIZE];
 	unsigned int keyidlen = 0;
+	unsigned int namelen = name ? strlen(name) : -1;
 
 	/* Set defaults */
 	if (!nid_cert) {
@@ -116,7 +117,7 @@
 
 	if (cert) {
 		bag = PKCS12_add_cert(&bags, cert);
-		if (name && !PKCS12_add_friendlyname(bag, name, -1))
+		if(name && !PKCS12_add_friendlyname(bag, name, namelen))
 			goto err;
 		if (keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
 			goto err;
@@ -145,7 +146,7 @@
 		if (!copy_bag_attr(bag, pkey, NID_LocalKeySet))
 			goto err;
 
-		if (name && !PKCS12_add_friendlyname(bag, name, -1))
+		if(name && !PKCS12_add_friendlyname(bag, name, namelen))
 			goto err;
 		if (keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
 			goto err;
diff -Nur libressl-3.1.0/crypto/x509/x509_vfy.c libressl-3.1.0-apple/crypto/x509/x509_vfy.c
--- libressl-3.1.0/crypto/x509/x509_vfy.c	2019-03-19 11:24:51.000000000 +0100
+++ libressl-3.1.0-apple/crypto/x509/x509_vfy.c	2020-04-21 08:37:53.000000000 +0200
@@ -115,6 +115,13 @@
 
 #define CRL_SCORE_TIME_DELTA	0x002
 
+/*
+ * If we are using Trust Evaluation Agent, rename the original function
+ */
+#ifdef __APPLE__
+#define X509_verify_cert X509_verify_cert_orig
+#endif
+
 static int null_callback(int ok, X509_STORE_CTX *e);
 static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);
 static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);
diff -Nur libressl-3.1.0/crypto/x509/x509_vfy.c.orig libressl-3.1.0-apple/crypto/x509/x509_vfy.c.orig
--- libressl-3.1.0/crypto/x509/x509_vfy.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/crypto/x509/x509_vfy.c.orig	2019-03-19 11:24:51.000000000 +0100
@@ -0,0 +1,2433 @@
+/* $OpenBSD: x509_vfy.c,v 1.72 2019/03/06 05:06:58 tb Exp $ */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <openssl/opensslconf.h>
+
+#include <openssl/asn1.h>
+#include <openssl/buffer.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/lhash.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include "asn1_locl.h"
+#include "vpm_int.h"
+#include "x509_lcl.h"
+
+/* CRL score values */
+
+/* No unhandled critical extensions */
+
+#define CRL_SCORE_NOCRITICAL	0x100
+
+/* certificate is within CRL scope */
+
+#define CRL_SCORE_SCOPE		0x080
+
+/* CRL times valid */
+
+#define CRL_SCORE_TIME		0x040
+
+/* Issuer name matches certificate */
+
+#define CRL_SCORE_ISSUER_NAME	0x020
+
+/* If this score or above CRL is probably valid */
+
+#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)
+
+/* CRL issuer is certificate issuer */
+
+#define CRL_SCORE_ISSUER_CERT	0x018
+
+/* CRL issuer is on certificate path */
+
+#define CRL_SCORE_SAME_PATH	0x008
+
+/* CRL issuer matches CRL AKID */
+
+#define CRL_SCORE_AKID		0x004
+
+/* Have a delta CRL with valid times */
+
+#define CRL_SCORE_TIME_DELTA	0x002
+
+static int null_callback(int ok, X509_STORE_CTX *e);
+static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);
+static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);
+static int check_chain_extensions(X509_STORE_CTX *ctx);
+static int check_name_constraints(X509_STORE_CTX *ctx);
+static int check_trust(X509_STORE_CTX *ctx);
+static int check_revocation(X509_STORE_CTX *ctx);
+static int check_cert(X509_STORE_CTX *ctx);
+static int check_policy(X509_STORE_CTX *ctx);
+
+static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
+    unsigned int *preasons, X509_CRL *crl, X509 *x);
+static int get_crl_delta(X509_STORE_CTX *ctx,
+    X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);
+static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pcrl_score,
+    X509_CRL *base, STACK_OF(X509_CRL) *crls);
+static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,
+    int *pcrl_score);
+static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
+    unsigned int *preasons);
+static int check_crl_path(X509_STORE_CTX *ctx, X509 *x);
+static int check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,
+    STACK_OF(X509) *crl_path);
+static int X509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time,
+    int clamp_notafter);
+
+static int internal_verify(X509_STORE_CTX *ctx);
+
+int ASN1_time_tm_clamp_notafter(struct tm *tm);
+
+static int
+null_callback(int ok, X509_STORE_CTX *e)
+{
+	return ok;
+}
+
+#if 0
+static int
+x509_subject_cmp(X509 **a, X509 **b)
+{
+	return X509_subject_name_cmp(*a, *b);
+}
+#endif
+
+/* Return 1 if a certificate is self signed */
+static int
+cert_self_signed(X509 *x)
+{
+	X509_check_purpose(x, -1, 0);
+	if (x->ex_flags & EXFLAG_SS)
+		return 1;
+	else
+		return 0;
+}
+
+static int
+check_id_error(X509_STORE_CTX *ctx, int errcode)
+{
+	ctx->error = errcode;
+	ctx->current_cert = ctx->cert;
+	ctx->error_depth = 0;
+	return ctx->verify_cb(0, ctx);
+}
+
+static int
+check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)
+{
+	size_t i, n;
+	char *name;
+
+	n = sk_OPENSSL_STRING_num(id->hosts);
+	free(id->peername);
+	id->peername = NULL;
+
+	for (i = 0; i < n; ++i) {
+		name = sk_OPENSSL_STRING_value(id->hosts, i);
+		if (X509_check_host(x, name, strlen(name), id->hostflags,
+		    &id->peername) > 0)
+			return 1;
+	}
+	return n == 0;
+}
+
+static int
+check_id(X509_STORE_CTX *ctx)
+{
+	X509_VERIFY_PARAM *vpm = ctx->param;
+	X509_VERIFY_PARAM_ID *id = vpm->id;
+	X509 *x = ctx->cert;
+
+	if (id->hosts && check_hosts(x, id) <= 0) {
+		if (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))
+			return 0;
+	}
+	if (id->email != NULL && X509_check_email(x, id->email, id->emaillen, 0)
+	    <= 0) {
+		if (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))
+			return 0;
+	}
+	if (id->ip != NULL && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {
+		if (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))
+			return 0;
+	}
+	return 1;
+}
+
+int
+X509_verify_cert(X509_STORE_CTX *ctx)
+{
+	X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
+	int bad_chain = 0;
+	X509_VERIFY_PARAM *param = ctx->param;
+	int depth, i, ok = 0;
+	int num, j, retry, trust;
+	int (*cb) (int xok, X509_STORE_CTX *xctx);
+	STACK_OF(X509) *sktmp = NULL;
+
+	if (ctx->cert == NULL) {
+		X509error(X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
+		ctx->error = X509_V_ERR_INVALID_CALL;
+		return -1;
+	}
+	if (ctx->chain != NULL) {
+		/*
+		 * This X509_STORE_CTX has already been used to verify
+		 * a cert. We cannot do another one.
+		 */
+		X509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+		ctx->error = X509_V_ERR_INVALID_CALL;
+		return -1;
+	}
+	if (ctx->param->id->poisoned) {
+		/*
+		 * This X509_STORE_CTX had failures setting
+		 * up verify parameters. We can not use it.
+		 */
+		X509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+		ctx->error = X509_V_ERR_INVALID_CALL;
+		return -1;
+	}
+	if (ctx->error != X509_V_ERR_INVALID_CALL) {
+		/*
+		 * This X509_STORE_CTX has not been properly initialized.
+		 */
+		X509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+		ctx->error = X509_V_ERR_INVALID_CALL;
+		return -1;
+	}
+	ctx->error = X509_V_OK; /* Initialize to OK */
+
+	cb = ctx->verify_cb;
+
+	/*
+	 * First we make sure the chain we are going to build is
+	 * present and that the first entry is in place.
+	 */
+	ctx->chain = sk_X509_new_null();
+	if (ctx->chain == NULL || !sk_X509_push(ctx->chain, ctx->cert)) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		ctx->error = X509_V_ERR_OUT_OF_MEM;
+		goto end;
+	}
+	X509_up_ref(ctx->cert);
+	ctx->last_untrusted = 1;
+
+	/* We use a temporary STACK so we can chop and hack at it */
+	if (ctx->untrusted != NULL &&
+	    (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		ctx->error = X509_V_ERR_OUT_OF_MEM;
+		goto end;
+	}
+
+	num = sk_X509_num(ctx->chain);
+	x = sk_X509_value(ctx->chain, num - 1);
+	depth = param->depth;
+
+	for (;;) {
+		/* If we have enough, we break */
+		/* FIXME: If this happens, we should take
+		 * note of it and, if appropriate, use the
+		 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
+		 * later.
+		 */
+		if (depth < num)
+			break;
+		/* If we are self signed, we break */
+		if (cert_self_signed(x))
+			break;
+		/*
+		 * If asked see if we can find issuer in trusted store first
+		 */
+		if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {
+			ok = ctx->get_issuer(&xtmp, ctx, x);
+			if (ok < 0) {
+				ctx->error = X509_V_ERR_STORE_LOOKUP;
+				goto end;
+			}
+			/*
+			 * If successful for now free up cert so it
+			 * will be picked up again later.
+			 */
+			if (ok > 0) {
+				X509_free(xtmp);
+				break;
+			}
+		}
+		/* If we were passed a cert chain, use it first */
+		if (ctx->untrusted != NULL) {
+			xtmp = find_issuer(ctx, sktmp, x);
+			if (xtmp != NULL) {
+				if (!sk_X509_push(ctx->chain, xtmp)) {
+					X509error(ERR_R_MALLOC_FAILURE);
+					ctx->error = X509_V_ERR_OUT_OF_MEM;
+					ok = 0;
+					goto end;
+				}
+				X509_up_ref(xtmp);
+				(void)sk_X509_delete_ptr(sktmp, xtmp);
+				ctx->last_untrusted++;
+				x = xtmp;
+				num++;
+				/*
+				 * reparse the full chain for the next one
+				 */
+				continue;
+			}
+		}
+		break;
+	}
+	/* Remember how many untrusted certs we have */
+	j = num;
+
+	/*
+	 * At this point, chain should contain a list of untrusted
+	 * certificates.  We now need to add at least one trusted one,
+	 * if possible, otherwise we complain.
+	 */
+
+	do {
+		/*
+		 * Examine last certificate in chain and see if it is
+		 * self signed.
+		 */
+		i = sk_X509_num(ctx->chain);
+		x = sk_X509_value(ctx->chain, i - 1);
+		if (cert_self_signed(x)) {
+			/* we have a self signed certificate */
+			if (i == 1) {
+				/*
+				 * We have a single self signed
+				 * certificate: see if we can find it
+				 * in the store. We must have an exact
+				 * match to avoid possible
+				 * impersonation.
+				 */
+				ok = ctx->get_issuer(&xtmp, ctx, x);
+				if ((ok <= 0) || X509_cmp(x, xtmp)) {
+					ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
+					ctx->current_cert = x;
+					ctx->error_depth = i - 1;
+					if (ok == 1)
+						X509_free(xtmp);
+					bad_chain = 1;
+					ok = cb(0, ctx);
+					if (!ok)
+						goto end;
+				} else {
+					/*
+					 * We have a match: replace
+					 * certificate with store
+					 * version so we get any trust
+					 * settings.
+					 */
+					X509_free(x);
+					x = xtmp;
+					(void)sk_X509_set(ctx->chain, i - 1, x);
+					ctx->last_untrusted = 0;
+				}
+			} else {
+				/*
+				 * extract and save self signed
+				 * certificate for later use
+				 */
+				chain_ss = sk_X509_pop(ctx->chain);
+				ctx->last_untrusted--;
+				num--;
+				j--;
+				x = sk_X509_value(ctx->chain, num - 1);
+			}
+		}
+		/* We now lookup certs from the certificate store */
+		for (;;) {
+			/* If we have enough, we break */
+			if (depth < num)
+				break;
+			/* If we are self signed, we break */
+			if (cert_self_signed(x))
+				break;
+			ok = ctx->get_issuer(&xtmp, ctx, x);
+
+			if (ok < 0) {
+				ctx->error = X509_V_ERR_STORE_LOOKUP;
+				goto end;
+			}
+			if (ok == 0)
+				break;
+			x = xtmp;
+			if (!sk_X509_push(ctx->chain, x)) {
+				X509_free(xtmp);
+				X509error(ERR_R_MALLOC_FAILURE);
+				ctx->error = X509_V_ERR_OUT_OF_MEM;
+				ok = 0;
+				goto end;
+			}
+			num++;
+		}
+
+		/* we now have our chain, lets check it... */
+		trust = check_trust(ctx);
+
+		/* If explicitly rejected error */
+		if (trust == X509_TRUST_REJECTED) {
+			ok = 0;
+			goto end;
+		}
+		/*
+		 * If it's not explicitly trusted then check if there
+		 * is an alternative chain that could be used. We only
+		 * do this if we haven't already checked via
+		 * TRUSTED_FIRST and the user hasn't switched off
+		 * alternate chain checking
+		 */
+		retry = 0;
+		if (trust != X509_TRUST_TRUSTED &&
+		    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) &&
+		    !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
+			while (j-- > 1) {
+				xtmp2 = sk_X509_value(ctx->chain, j - 1);
+				ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
+				if (ok < 0)
+					goto end;
+				/* Check if we found an alternate chain */
+				if (ok > 0) {
+					/*
+					 * Free up the found cert
+					 * we'll add it again later
+					 */
+					X509_free(xtmp);
+					/*
+					 * Dump all the certs above
+					 * this point - we've found an
+					 * alternate chain
+					 */
+					while (num > j) {
+						xtmp = sk_X509_pop(ctx->chain);
+						X509_free(xtmp);
+						num--;
+					}
+					ctx->last_untrusted = sk_X509_num(ctx->chain);
+					retry = 1;
+					break;
+				}
+			}
+		}
+	} while (retry);
+
+	/*
+	 * If not explicitly trusted then indicate error unless it's a single
+	 * self signed certificate in which case we've indicated an error already
+	 * and set bad_chain == 1
+	 */
+	if (trust != X509_TRUST_TRUSTED && !bad_chain) {
+		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
+			if (ctx->last_untrusted >= num)
+				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+			else
+				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
+			ctx->current_cert = x;
+		} else {
+			if (!sk_X509_push(ctx->chain, chain_ss)) {
+				X509error(ERR_R_MALLOC_FAILURE);
+				ctx->error = X509_V_ERR_OUT_OF_MEM;
+				ok = 0;
+				goto end;
+			}
+			num++;
+			ctx->last_untrusted = num;
+			ctx->current_cert = chain_ss;
+			ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
+			chain_ss = NULL;
+		}
+
+		ctx->error_depth = num - 1;
+		bad_chain = 1;
+		ok = cb(0, ctx);
+		if (!ok)
+			goto end;
+	}
+
+	/* We have the chain complete: now we need to check its purpose */
+	ok = check_chain_extensions(ctx);
+	if (!ok)
+		goto end;
+
+	/* Check name constraints */
+	ok = check_name_constraints(ctx);
+	if (!ok)
+		goto end;
+
+	ok = check_id(ctx);
+	if (!ok)
+		goto end;
+	/*
+	 * Check revocation status: we do this after copying parameters because
+	 * they may be needed for CRL signature verification.
+	 */
+	ok = ctx->check_revocation(ctx);
+	if (!ok)
+		goto end;
+
+	/* At this point, we have a chain and need to verify it */
+	if (ctx->verify != NULL)
+		ok = ctx->verify(ctx);
+	else
+		ok = internal_verify(ctx);
+	if (!ok)
+		goto end;
+
+	/* If we get this far evaluate policies */
+	if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
+		ok = ctx->check_policy(ctx);
+
+ end:
+	sk_X509_free(sktmp);
+	X509_free(chain_ss);
+
+	/* Safety net, error returns must set ctx->error */
+	if (ok <= 0 && ctx->error == X509_V_OK)
+		ctx->error = X509_V_ERR_UNSPECIFIED;
+	return ok;
+}
+
+/* Given a STACK_OF(X509) find the issuer of cert (if any)
+ */
+
+static X509 *
+find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x)
+{
+	int i;
+	X509 *issuer, *rv = NULL;
+
+	for (i = 0; i < sk_X509_num(sk); i++) {
+		issuer = sk_X509_value(sk, i);
+		if (ctx->check_issued(ctx, x, issuer)) {
+			rv = issuer;
+			if (x509_check_cert_time(ctx, rv, -1))
+				break;
+		}
+	}
+	return rv;
+}
+
+/* Given a possible certificate and issuer check them */
+
+static int
+check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
+{
+	int ret;
+
+	ret = X509_check_issued(issuer, x);
+	if (ret == X509_V_OK)
+		return 1;
+	/* If we haven't asked for issuer errors don't set ctx */
+	if (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))
+		return 0;
+
+	ctx->error = ret;
+	ctx->current_cert = x;
+	ctx->current_issuer = issuer;
+	return ctx->verify_cb(0, ctx);
+}
+
+/* Alternative lookup method: look from a STACK stored in other_ctx */
+
+static int
+get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
+{
+	*issuer = find_issuer(ctx, ctx->other_ctx, x);
+	if (*issuer) {
+		CRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);
+		return 1;
+	} else
+		return 0;
+}
+
+/* Check a certificate chains extensions for consistency
+ * with the supplied purpose
+ */
+
+static int
+check_chain_extensions(X509_STORE_CTX *ctx)
+{
+#ifdef OPENSSL_NO_CHAIN_VERIFY
+	return 1;
+#else
+	int i, ok = 0, must_be_ca, plen = 0;
+	X509 *x;
+	int (*cb)(int xok, X509_STORE_CTX *xctx);
+	int proxy_path_length = 0;
+	int purpose;
+	int allow_proxy_certs;
+
+	cb = ctx->verify_cb;
+
+	/* must_be_ca can have 1 of 3 values:
+	   -1: we accept both CA and non-CA certificates, to allow direct
+	       use of self-signed certificates (which are marked as CA).
+	   0:  we only accept non-CA certificates.  This is currently not
+	       used, but the possibility is present for future extensions.
+	   1:  we only accept CA certificates.  This is currently used for
+	       all certificates in the chain except the leaf certificate.
+	*/
+	must_be_ca = -1;
+
+	/* CRL path validation */
+	if (ctx->parent) {
+		allow_proxy_certs = 0;
+		purpose = X509_PURPOSE_CRL_SIGN;
+	} else {
+		allow_proxy_certs =
+		    !!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
+		purpose = ctx->param->purpose;
+	}
+
+	/* Check all untrusted certificates */
+	for (i = 0; i < ctx->last_untrusted; i++) {
+		int ret;
+		x = sk_X509_value(ctx->chain, i);
+		if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&
+		    (x->ex_flags & EXFLAG_CRITICAL)) {
+			ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ok = cb(0, ctx);
+			if (!ok)
+				goto end;
+		}
+		if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {
+			ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ok = cb(0, ctx);
+			if (!ok)
+				goto end;
+		}
+		ret = X509_check_ca(x);
+		switch (must_be_ca) {
+		case -1:
+			if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
+			    (ret != 1) && (ret != 0)) {
+				ret = 0;
+				ctx->error = X509_V_ERR_INVALID_CA;
+			} else
+				ret = 1;
+			break;
+		case 0:
+			if (ret != 0) {
+				ret = 0;
+				ctx->error = X509_V_ERR_INVALID_NON_CA;
+			} else
+				ret = 1;
+			break;
+		default:
+			if ((ret == 0) ||
+			    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
+			    (ret != 1))) {
+				ret = 0;
+				ctx->error = X509_V_ERR_INVALID_CA;
+			} else
+				ret = 1;
+			break;
+		}
+		if (ret == 0) {
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ok = cb(0, ctx);
+			if (!ok)
+				goto end;
+		}
+		if (ctx->param->purpose > 0) {
+			ret = X509_check_purpose(x, purpose, must_be_ca > 0);
+			if ((ret == 0) ||
+			    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
+			    (ret != 1))) {
+				ctx->error = X509_V_ERR_INVALID_PURPOSE;
+				ctx->error_depth = i;
+				ctx->current_cert = x;
+				ok = cb(0, ctx);
+				if (!ok)
+					goto end;
+			}
+		}
+		/* Check pathlen if not self issued */
+		if ((i > 1) && !(x->ex_flags & EXFLAG_SI) &&
+		    (x->ex_pathlen != -1) &&
+		    (plen > (x->ex_pathlen + proxy_path_length + 1))) {
+			ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ok = cb(0, ctx);
+			if (!ok)
+				goto end;
+		}
+		/* Increment path length if not self issued */
+		if (!(x->ex_flags & EXFLAG_SI))
+			plen++;
+		/* If this certificate is a proxy certificate, the next
+		   certificate must be another proxy certificate or a EE
+		   certificate.  If not, the next certificate must be a
+		   CA certificate.  */
+		if (x->ex_flags & EXFLAG_PROXY) {
+			if (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {
+				ctx->error =
+				    X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
+				ctx->error_depth = i;
+				ctx->current_cert = x;
+				ok = cb(0, ctx);
+				if (!ok)
+					goto end;
+			}
+			proxy_path_length++;
+			must_be_ca = 0;
+		} else
+			must_be_ca = 1;
+	}
+	ok = 1;
+
+end:
+	return ok;
+#endif
+}
+
+static int
+check_name_constraints(X509_STORE_CTX *ctx)
+{
+	X509 *x;
+	int i, j, rv;
+
+	/* Check name constraints for all certificates */
+	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--) {
+		x = sk_X509_value(ctx->chain, i);
+		/* Ignore self issued certs unless last in chain */
+		if (i && (x->ex_flags & EXFLAG_SI))
+			continue;
+		/* Check against constraints for all certificates higher in
+		 * chain including trust anchor. Trust anchor not strictly
+		 * speaking needed but if it includes constraints it is to be
+		 * assumed it expects them to be obeyed.
+		 */
+		for (j = sk_X509_num(ctx->chain) - 1; j > i; j--) {
+			NAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;
+			if (nc) {
+				rv = NAME_CONSTRAINTS_check(x, nc);
+				if (rv != X509_V_OK) {
+					ctx->error = rv;
+					ctx->error_depth = i;
+					ctx->current_cert = x;
+					if (!ctx->verify_cb(0, ctx))
+						return 0;
+				}
+			}
+		}
+	}
+	return 1;
+}
+
+/* Given a certificate try and find an exact match in the store */
+
+static X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)
+{
+	STACK_OF(X509) *certs;
+	X509 *xtmp = NULL;
+	size_t i;
+
+	/* Lookup all certs with matching subject name */
+	certs = ctx->lookup_certs(ctx, X509_get_subject_name(x));
+	if (certs == NULL)
+		return NULL;
+
+	/* Look for exact match */
+	for (i = 0; i < sk_X509_num(certs); i++) {
+		xtmp = sk_X509_value(certs, i);
+		if (!X509_cmp(xtmp, x))
+			break;
+	}
+
+	if (i < sk_X509_num(certs))
+		X509_up_ref(xtmp);
+	else
+		xtmp = NULL;
+
+	sk_X509_pop_free(certs, X509_free);
+	return xtmp;
+}
+
+static int check_trust(X509_STORE_CTX *ctx)
+{
+	size_t i;
+	int ok;
+	X509 *x = NULL;
+	int (*cb) (int xok, X509_STORE_CTX *xctx);
+
+	cb = ctx->verify_cb;
+	/* Check all trusted certificates in chain */
+	for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
+		x = sk_X509_value(ctx->chain, i);
+		ok = X509_check_trust(x, ctx->param->trust, 0);
+
+		/* If explicitly trusted return trusted */
+		if (ok == X509_TRUST_TRUSTED)
+			return X509_TRUST_TRUSTED;
+		/*
+		 * If explicitly rejected notify callback and reject if not
+		 * overridden.
+		 */
+		if (ok == X509_TRUST_REJECTED) {
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			ctx->error = X509_V_ERR_CERT_REJECTED;
+			ok = cb(0, ctx);
+			if (!ok)
+				return X509_TRUST_REJECTED;
+		}
+	}
+	/*
+	 * If we accept partial chains and have at least one trusted certificate
+	 * return success.
+	 */
+	if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+		X509 *mx;
+		if (ctx->last_untrusted < (int)sk_X509_num(ctx->chain))
+			return X509_TRUST_TRUSTED;
+		x = sk_X509_value(ctx->chain, 0);
+		mx = lookup_cert_match(ctx, x);
+		if (mx) {
+			(void)sk_X509_set(ctx->chain, 0, mx);
+			X509_free(x);
+			ctx->last_untrusted = 0;
+			return X509_TRUST_TRUSTED;
+		}
+	}
+
+	/*
+	 * If no trusted certs in chain at all return untrusted and allow
+	 * standard (no issuer cert) etc errors to be indicated.
+	 */
+	return X509_TRUST_UNTRUSTED;
+}
+
+static int
+check_revocation(X509_STORE_CTX *ctx)
+{
+	int i, last, ok;
+
+	if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))
+		return 1;
+	if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)
+		last = sk_X509_num(ctx->chain) - 1;
+	else {
+		/* If checking CRL paths this isn't the EE certificate */
+		if (ctx->parent)
+			return 1;
+		last = 0;
+	}
+	for (i = 0; i <= last; i++) {
+		ctx->error_depth = i;
+		ok = check_cert(ctx);
+		if (!ok)
+			return ok;
+	}
+	return 1;
+}
+
+static int
+check_cert(X509_STORE_CTX *ctx)
+{
+	X509_CRL *crl = NULL, *dcrl = NULL;
+	X509 *x;
+	int ok = 0, cnum;
+	unsigned int last_reasons;
+
+	cnum = ctx->error_depth;
+	x = sk_X509_value(ctx->chain, cnum);
+	ctx->current_cert = x;
+	ctx->current_issuer = NULL;
+	ctx->current_crl_score = 0;
+	ctx->current_reasons = 0;
+	while (ctx->current_reasons != CRLDP_ALL_REASONS) {
+		last_reasons = ctx->current_reasons;
+		/* Try to retrieve relevant CRL */
+		if (ctx->get_crl)
+			ok = ctx->get_crl(ctx, &crl, x);
+		else
+			ok = get_crl_delta(ctx, &crl, &dcrl, x);
+		/* If error looking up CRL, nothing we can do except
+		 * notify callback
+		 */
+		if (!ok) {
+			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
+			ok = ctx->verify_cb(0, ctx);
+			goto err;
+		}
+		ctx->current_crl = crl;
+		ok = ctx->check_crl(ctx, crl);
+		if (!ok)
+			goto err;
+
+		if (dcrl) {
+			ok = ctx->check_crl(ctx, dcrl);
+			if (!ok)
+				goto err;
+			ok = ctx->cert_crl(ctx, dcrl, x);
+			if (!ok)
+				goto err;
+		} else
+			ok = 1;
+
+		/* Don't look in full CRL if delta reason is removefromCRL */
+		if (ok != 2) {
+			ok = ctx->cert_crl(ctx, crl, x);
+			if (!ok)
+				goto err;
+		}
+
+		ctx->current_crl = NULL;
+		X509_CRL_free(crl);
+		X509_CRL_free(dcrl);
+		crl = NULL;
+		dcrl = NULL;
+		/* If reasons not updated we wont get anywhere by
+		 * another iteration, so exit loop.
+		 */
+		if (last_reasons == ctx->current_reasons) {
+			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
+			ok = ctx->verify_cb(0, ctx);
+			goto err;
+		}
+	}
+
+err:
+	ctx->current_crl = NULL;
+	X509_CRL_free(crl);
+	X509_CRL_free(dcrl);
+	return ok;
+}
+
+/* Check CRL times against values in X509_STORE_CTX */
+
+static int
+check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)
+{
+	time_t *ptime = NULL;
+	int i;
+
+	if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)
+		return (1);
+
+	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
+		ptime = &ctx->param->check_time;
+
+	if (notify)
+		ctx->current_crl = crl;
+
+	i = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
+	if (i == 0) {
+		if (!notify)
+			return 0;
+		ctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
+		if (!ctx->verify_cb(0, ctx))
+			return 0;
+	}
+
+	if (i > 0) {
+		if (!notify)
+			return 0;
+		ctx->error = X509_V_ERR_CRL_NOT_YET_VALID;
+		if (!ctx->verify_cb(0, ctx))
+			return 0;
+	}
+
+	if (X509_CRL_get_nextUpdate(crl)) {
+		i = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);
+
+		if (i == 0) {
+			if (!notify)
+				return 0;
+			ctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
+			if (!ctx->verify_cb(0, ctx))
+				return 0;
+		}
+		/* Ignore expiry of base CRL is delta is valid */
+		if ((i < 0) &&
+		    !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {
+			if (!notify)
+				return 0;
+			ctx->error = X509_V_ERR_CRL_HAS_EXPIRED;
+			if (!ctx->verify_cb(0, ctx))
+				return 0;
+		}
+	}
+
+	if (notify)
+		ctx->current_crl = NULL;
+
+	return 1;
+}
+
+static int
+get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
+    X509 **pissuer, int *pscore, unsigned int *preasons,
+    STACK_OF(X509_CRL) *crls)
+{
+	int i, crl_score, best_score = *pscore;
+	unsigned int reasons, best_reasons = 0;
+	X509 *x = ctx->current_cert;
+	X509_CRL *crl, *best_crl = NULL;
+	X509 *crl_issuer = NULL, *best_crl_issuer = NULL;
+
+	for (i = 0; i < sk_X509_CRL_num(crls); i++) {
+		crl = sk_X509_CRL_value(crls, i);
+		reasons = *preasons;
+		crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
+
+		if (crl_score > best_score) {
+			best_crl = crl;
+			best_crl_issuer = crl_issuer;
+			best_score = crl_score;
+			best_reasons = reasons;
+		}
+	}
+
+	if (best_crl) {
+		if (*pcrl)
+			X509_CRL_free(*pcrl);
+		*pcrl = best_crl;
+		*pissuer = best_crl_issuer;
+		*pscore = best_score;
+		*preasons = best_reasons;
+		CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
+		if (*pdcrl) {
+			X509_CRL_free(*pdcrl);
+			*pdcrl = NULL;
+		}
+		get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
+	}
+
+	if (best_score >= CRL_SCORE_VALID)
+		return 1;
+
+	return 0;
+}
+
+/* Compare two CRL extensions for delta checking purposes. They should be
+ * both present or both absent. If both present all fields must be identical.
+ */
+
+static int
+crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)
+{
+	ASN1_OCTET_STRING *exta, *extb;
+	int i;
+
+	i = X509_CRL_get_ext_by_NID(a, nid, -1);
+	if (i >= 0) {
+		/* Can't have multiple occurrences */
+		if (X509_CRL_get_ext_by_NID(a, nid, i) != -1)
+			return 0;
+		exta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));
+	} else
+		exta = NULL;
+
+	i = X509_CRL_get_ext_by_NID(b, nid, -1);
+
+	if (i >= 0) {
+		if (X509_CRL_get_ext_by_NID(b, nid, i) != -1)
+			return 0;
+		extb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));
+	} else
+		extb = NULL;
+
+	if (!exta && !extb)
+		return 1;
+
+	if (!exta || !extb)
+		return 0;
+
+	if (ASN1_OCTET_STRING_cmp(exta, extb))
+		return 0;
+
+	return 1;
+}
+
+/* See if a base and delta are compatible */
+
+static int
+check_delta_base(X509_CRL *delta, X509_CRL *base)
+{
+	/* Delta CRL must be a delta */
+	if (!delta->base_crl_number)
+		return 0;
+	/* Base must have a CRL number */
+	if (!base->crl_number)
+		return 0;
+	/* Issuer names must match */
+	if (X509_NAME_cmp(X509_CRL_get_issuer(base),
+	    X509_CRL_get_issuer(delta)))
+		return 0;
+	/* AKID and IDP must match */
+	if (!crl_extension_match(delta, base, NID_authority_key_identifier))
+		return 0;
+	if (!crl_extension_match(delta, base, NID_issuing_distribution_point))
+		return 0;
+	/* Delta CRL base number must not exceed Full CRL number. */
+	if (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)
+		return 0;
+	/* Delta CRL number must exceed full CRL number */
+	if (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)
+		return 1;
+	return 0;
+}
+
+/* For a given base CRL find a delta... maybe extend to delta scoring
+ * or retrieve a chain of deltas...
+ */
+
+static void
+get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore, X509_CRL *base,
+    STACK_OF(X509_CRL) *crls)
+{
+	X509_CRL *delta;
+	int i;
+
+	if (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))
+		return;
+	if (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))
+		return;
+	for (i = 0; i < sk_X509_CRL_num(crls); i++) {
+		delta = sk_X509_CRL_value(crls, i);
+		if (check_delta_base(delta, base)) {
+			if (check_crl_time(ctx, delta, 0))
+				*pscore |= CRL_SCORE_TIME_DELTA;
+			CRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);
+			*dcrl = delta;
+			return;
+		}
+	}
+	*dcrl = NULL;
+}
+
+/* For a given CRL return how suitable it is for the supplied certificate 'x'.
+ * The return value is a mask of several criteria.
+ * If the issuer is not the certificate issuer this is returned in *pissuer.
+ * The reasons mask is also used to determine if the CRL is suitable: if
+ * no new reasons the CRL is rejected, otherwise reasons is updated.
+ */
+
+static int
+get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer, unsigned int *preasons,
+    X509_CRL *crl, X509 *x)
+{
+	int crl_score = 0;
+	unsigned int tmp_reasons = *preasons, crl_reasons;
+
+	/* First see if we can reject CRL straight away */
+
+	/* Invalid IDP cannot be processed */
+	if (crl->idp_flags & IDP_INVALID)
+		return 0;
+	/* Reason codes or indirect CRLs need extended CRL support */
+	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {
+		if (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))
+			return 0;
+	} else if (crl->idp_flags & IDP_REASONS) {
+		/* If no new reasons reject */
+		if (!(crl->idp_reasons & ~tmp_reasons))
+			return 0;
+	}
+	/* Don't process deltas at this stage */
+	else if (crl->base_crl_number)
+		return 0;
+	/* If issuer name doesn't match certificate need indirect CRL */
+	if (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {
+		if (!(crl->idp_flags & IDP_INDIRECT))
+			return 0;
+	} else
+		crl_score |= CRL_SCORE_ISSUER_NAME;
+
+	if (!(crl->flags & EXFLAG_CRITICAL))
+		crl_score |= CRL_SCORE_NOCRITICAL;
+
+	/* Check expiry */
+	if (check_crl_time(ctx, crl, 0))
+		crl_score |= CRL_SCORE_TIME;
+
+	/* Check authority key ID and locate certificate issuer */
+	crl_akid_check(ctx, crl, pissuer, &crl_score);
+
+	/* If we can't locate certificate issuer at this point forget it */
+
+	if (!(crl_score & CRL_SCORE_AKID))
+		return 0;
+
+	/* Check cert for matching CRL distribution points */
+
+	if (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {
+		/* If no new reasons reject */
+		if (!(crl_reasons & ~tmp_reasons))
+			return 0;
+		tmp_reasons |= crl_reasons;
+		crl_score |= CRL_SCORE_SCOPE;
+	}
+
+	*preasons = tmp_reasons;
+
+	return crl_score;
+}
+
+static void
+crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,
+    int *pcrl_score)
+{
+	X509 *crl_issuer = NULL;
+	X509_NAME *cnm = X509_CRL_get_issuer(crl);
+	int cidx = ctx->error_depth;
+	int i;
+
+	if (cidx != sk_X509_num(ctx->chain) - 1)
+		cidx++;
+
+	crl_issuer = sk_X509_value(ctx->chain, cidx);
+
+	if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+		if (*pcrl_score & CRL_SCORE_ISSUER_NAME) {
+			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_ISSUER_CERT;
+			*pissuer = crl_issuer;
+			return;
+		}
+	}
+
+	for (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {
+		crl_issuer = sk_X509_value(ctx->chain, cidx);
+		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
+			continue;
+		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_SAME_PATH;
+			*pissuer = crl_issuer;
+			return;
+		}
+	}
+
+	/* Anything else needs extended CRL support */
+
+	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
+		return;
+
+	/* Otherwise the CRL issuer is not on the path. Look for it in the
+	 * set of untrusted certificates.
+	 */
+	for (i = 0; i < sk_X509_num(ctx->untrusted); i++) {
+		crl_issuer = sk_X509_value(ctx->untrusted, i);
+		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
+			continue;
+		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+			*pissuer = crl_issuer;
+			*pcrl_score |= CRL_SCORE_AKID;
+			return;
+		}
+	}
+}
+
+/* Check the path of a CRL issuer certificate. This creates a new
+ * X509_STORE_CTX and populates it with most of the parameters from the
+ * parent. This could be optimised somewhat since a lot of path checking
+ * will be duplicated by the parent, but this will rarely be used in
+ * practice.
+ */
+
+static int
+check_crl_path(X509_STORE_CTX *ctx, X509 *x)
+{
+	X509_STORE_CTX crl_ctx;
+	int ret;
+
+	/* Don't allow recursive CRL path validation */
+	if (ctx->parent)
+		return 0;
+	if (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted)) {
+		ret = -1;
+		goto err;
+	}
+
+	crl_ctx.crls = ctx->crls;
+	/* Copy verify params across */
+	X509_STORE_CTX_set0_param(&crl_ctx, ctx->param);
+
+	crl_ctx.parent = ctx;
+	crl_ctx.verify_cb = ctx->verify_cb;
+
+	/* Verify CRL issuer */
+	ret = X509_verify_cert(&crl_ctx);
+
+	if (ret <= 0)
+		goto err;
+
+	/* Check chain is acceptable */
+	ret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);
+
+err:
+	X509_STORE_CTX_cleanup(&crl_ctx);
+	return ret;
+}
+
+/* RFC3280 says nothing about the relationship between CRL path
+ * and certificate path, which could lead to situations where a
+ * certificate could be revoked or validated by a CA not authorised
+ * to do so. RFC5280 is more strict and states that the two paths must
+ * end in the same trust anchor, though some discussions remain...
+ * until this is resolved we use the RFC5280 version
+ */
+
+static int
+check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,
+    STACK_OF(X509) *crl_path)
+{
+	X509 *cert_ta, *crl_ta;
+
+	cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);
+	crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);
+	if (!X509_cmp(cert_ta, crl_ta))
+		return 1;
+	return 0;
+}
+
+/* Check for match between two dist point names: three separate cases.
+ * 1. Both are relative names and compare X509_NAME types.
+ * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.
+ * 3. Both are full names and compare two GENERAL_NAMES.
+ * 4. One is NULL: automatic match.
+ */
+
+static int
+idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
+{
+	X509_NAME *nm = NULL;
+	GENERAL_NAMES *gens = NULL;
+	GENERAL_NAME *gena, *genb;
+	int i, j;
+
+	if (!a || !b)
+		return 1;
+	if (a->type == 1) {
+		if (!a->dpname)
+			return 0;
+		/* Case 1: two X509_NAME */
+		if (b->type == 1) {
+			if (!b->dpname)
+				return 0;
+			if (!X509_NAME_cmp(a->dpname, b->dpname))
+				return 1;
+			else
+				return 0;
+		}
+		/* Case 2: set name and GENERAL_NAMES appropriately */
+		nm = a->dpname;
+		gens = b->name.fullname;
+	} else if (b->type == 1) {
+		if (!b->dpname)
+			return 0;
+		/* Case 2: set name and GENERAL_NAMES appropriately */
+		gens = a->name.fullname;
+		nm = b->dpname;
+	}
+
+	/* Handle case 2 with one GENERAL_NAMES and one X509_NAME */
+	if (nm) {
+		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
+			gena = sk_GENERAL_NAME_value(gens, i);
+			if (gena->type != GEN_DIRNAME)
+				continue;
+			if (!X509_NAME_cmp(nm, gena->d.directoryName))
+				return 1;
+		}
+		return 0;
+	}
+
+	/* Else case 3: two GENERAL_NAMES */
+
+	for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {
+		gena = sk_GENERAL_NAME_value(a->name.fullname, i);
+		for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {
+			genb = sk_GENERAL_NAME_value(b->name.fullname, j);
+			if (!GENERAL_NAME_cmp(gena, genb))
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int
+crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)
+{
+	int i;
+	X509_NAME *nm = X509_CRL_get_issuer(crl);
+
+	/* If no CRLissuer return is successful iff don't need a match */
+	if (!dp->CRLissuer)
+		return !!(crl_score & CRL_SCORE_ISSUER_NAME);
+	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {
+		GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
+		if (gen->type != GEN_DIRNAME)
+			continue;
+		if (!X509_NAME_cmp(gen->d.directoryName, nm))
+			return 1;
+	}
+	return 0;
+}
+
+/* Check CRLDP and IDP */
+
+static int
+crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score, unsigned int *preasons)
+{
+	int i;
+
+	if (crl->idp_flags & IDP_ONLYATTR)
+		return 0;
+	if (x->ex_flags & EXFLAG_CA) {
+		if (crl->idp_flags & IDP_ONLYUSER)
+			return 0;
+	} else {
+		if (crl->idp_flags & IDP_ONLYCA)
+			return 0;
+	}
+	*preasons = crl->idp_reasons;
+	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {
+		DIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);
+		if (crldp_check_crlissuer(dp, crl, crl_score)) {
+			if (!crl->idp ||
+			    idp_check_dp(dp->distpoint, crl->idp->distpoint)) {
+				*preasons &= dp->dp_reasons;
+				return 1;
+			}
+		}
+	}
+	if ((!crl->idp || !crl->idp->distpoint) &&
+	    (crl_score & CRL_SCORE_ISSUER_NAME))
+		return 1;
+	return 0;
+}
+
+/* Retrieve CRL corresponding to current certificate.
+ * If deltas enabled try to find a delta CRL too
+ */
+
+static int
+get_crl_delta(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)
+{
+	int ok;
+	X509 *issuer = NULL;
+	int crl_score = 0;
+	unsigned int reasons;
+	X509_CRL *crl = NULL, *dcrl = NULL;
+	STACK_OF(X509_CRL) *skcrl;
+	X509_NAME *nm = X509_get_issuer_name(x);
+
+	reasons = ctx->current_reasons;
+	ok = get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons,
+	    ctx->crls);
+	if (ok)
+		goto done;
+
+	/* Lookup CRLs from store */
+	skcrl = ctx->lookup_crls(ctx, nm);
+
+	/* If no CRLs found and a near match from get_crl_sk use that */
+	if (!skcrl && crl)
+		goto done;
+
+	get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);
+
+	sk_X509_CRL_pop_free(skcrl, X509_CRL_free);
+
+done:
+
+	/* If we got any kind of CRL use it and return success */
+	if (crl) {
+		ctx->current_issuer = issuer;
+		ctx->current_crl_score = crl_score;
+		ctx->current_reasons = reasons;
+		*pcrl = crl;
+		*pdcrl = dcrl;
+		return 1;
+	}
+
+	return 0;
+}
+
+/* Check CRL validity */
+static int
+check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)
+{
+	X509 *issuer = NULL;
+	EVP_PKEY *ikey = NULL;
+	int ok = 0, chnum, cnum;
+
+	cnum = ctx->error_depth;
+	chnum = sk_X509_num(ctx->chain) - 1;
+	/* if we have an alternative CRL issuer cert use that */
+	if (ctx->current_issuer) {
+		issuer = ctx->current_issuer;
+	} else if (cnum < chnum) {
+		/* Else find CRL issuer: if not last certificate then issuer
+	 	* is next certificate in chain.
+	 	*/
+		issuer = sk_X509_value(ctx->chain, cnum + 1);
+	} else {
+		issuer = sk_X509_value(ctx->chain, chnum);
+		/* If not self signed, can't check signature */
+		if (!ctx->check_issued(ctx, issuer, issuer)) {
+			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;
+			ok = ctx->verify_cb(0, ctx);
+			if (!ok)
+				goto err;
+		}
+	}
+
+	if (issuer) {
+		/* Skip most tests for deltas because they have already
+		 * been done
+		 */
+		if (!crl->base_crl_number) {
+			/* Check for cRLSign bit if keyUsage present */
+			if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
+			    !(issuer->ex_kusage & KU_CRL_SIGN)) {
+				ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
+				ok = ctx->verify_cb(0, ctx);
+				if (!ok)
+					goto err;
+			}
+
+			if (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {
+				ctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;
+				ok = ctx->verify_cb(0, ctx);
+				if (!ok)
+					goto err;
+			}
+
+			if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {
+				if (check_crl_path(ctx,
+				    ctx->current_issuer) <= 0) {
+					ctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;
+					ok = ctx->verify_cb(0, ctx);
+					if (!ok)
+						goto err;
+				}
+			}
+
+			if (crl->idp_flags & IDP_INVALID) {
+				ctx->error = X509_V_ERR_INVALID_EXTENSION;
+				ok = ctx->verify_cb(0, ctx);
+				if (!ok)
+					goto err;
+			}
+
+
+		}
+
+		if (!(ctx->current_crl_score & CRL_SCORE_TIME)) {
+			ok = check_crl_time(ctx, crl, 1);
+			if (!ok)
+				goto err;
+		}
+
+		/* Attempt to get issuer certificate public key */
+		ikey = X509_get_pubkey(issuer);
+
+		if (!ikey) {
+			ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
+			ok = ctx->verify_cb(0, ctx);
+			if (!ok)
+				goto err;
+		} else {
+			/* Verify CRL signature */
+			if (X509_CRL_verify(crl, ikey) <= 0) {
+				ctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;
+				ok = ctx->verify_cb(0, ctx);
+				if (!ok)
+					goto err;
+			}
+		}
+	}
+
+	ok = 1;
+
+err:
+	EVP_PKEY_free(ikey);
+	return ok;
+}
+
+/* Check certificate against CRL */
+static int
+cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)
+{
+	int ok;
+	X509_REVOKED *rev;
+
+	/* The rules changed for this... previously if a CRL contained
+	 * unhandled critical extensions it could still be used to indicate
+	 * a certificate was revoked. This has since been changed since
+	 * critical extension can change the meaning of CRL entries.
+	 */
+	if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&
+	    (crl->flags & EXFLAG_CRITICAL)) {
+		ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
+		ok = ctx->verify_cb(0, ctx);
+		if (!ok)
+			return 0;
+	}
+	/* Look for serial number of certificate in CRL
+	 * If found make sure reason is not removeFromCRL.
+	 */
+	if (X509_CRL_get0_by_cert(crl, &rev, x)) {
+		if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
+			return 2;
+		ctx->error = X509_V_ERR_CERT_REVOKED;
+		ok = ctx->verify_cb(0, ctx);
+		if (!ok)
+			return 0;
+	}
+
+	return 1;
+}
+
+static int
+check_policy(X509_STORE_CTX *ctx)
+{
+	int ret;
+
+	if (ctx->parent)
+		return 1;
+	ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
+	    ctx->param->policies, ctx->param->flags);
+	if (ret == 0) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		return 0;
+	}
+	/* Invalid or inconsistent extensions */
+	if (ret == -1) {
+		/* Locate certificates with bad extensions and notify
+		 * callback.
+		 */
+		X509 *x;
+		int i;
+		for (i = 1; i < sk_X509_num(ctx->chain); i++) {
+			x = sk_X509_value(ctx->chain, i);
+			if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
+				continue;
+			ctx->current_cert = x;
+			ctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;
+			if (!ctx->verify_cb(0, ctx))
+				return 0;
+		}
+		return 1;
+	}
+	if (ret == -2) {
+		ctx->current_cert = NULL;
+		ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
+		return ctx->verify_cb(0, ctx);
+	}
+
+	if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {
+		ctx->current_cert = NULL;
+		ctx->error = X509_V_OK;
+		if (!ctx->verify_cb(2, ctx))
+			return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * Inform the verify callback of an error.
+ *
+ * If x is not NULL it is the error cert, otherwise use the chain cert
+ * at depth.
+ *
+ * If err is not X509_V_OK, that's the error value, otherwise leave
+ * unchanged (presumably set by the caller).
+ *
+ * Returns 0 to abort verification with an error, non-zero to continue.
+ */
+static int
+verify_cb_cert(X509_STORE_CTX *ctx, X509 *x, int depth, int err)
+{
+	ctx->error_depth = depth;
+	ctx->current_cert = (x != NULL) ? x : sk_X509_value(ctx->chain, depth);
+	if (err != X509_V_OK)
+		ctx->error = err;
+	return ctx->verify_cb(0, ctx);
+}
+
+/*
+ * Check certificate validity times.
+ *
+ * If depth >= 0, invoke verification callbacks on error, otherwise just return
+ * the validation status.
+ *
+ * Return 1 on success, 0 otherwise.
+ */
+int
+x509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int depth)
+{
+	time_t *ptime;
+	int i;
+
+	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
+		ptime = &ctx->param->check_time;
+	else if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)
+		return 1;
+	else
+		ptime = NULL;
+
+	i = X509_cmp_time(X509_get_notBefore(x), ptime);
+	if (i >= 0 && depth < 0)
+		return 0;
+	if (i == 0 && !verify_cb_cert(ctx, x, depth,
+	    X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD))
+		return 0;
+	if (i > 0 && !verify_cb_cert(ctx, x, depth,
+		X509_V_ERR_CERT_NOT_YET_VALID))
+		return 0;
+
+	i = X509_cmp_time_internal(X509_get_notAfter(x), ptime, 1);
+	if (i <= 0 && depth < 0)
+		return 0;
+	if (i == 0 && !verify_cb_cert(ctx, x, depth,
+	    X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD))
+		return 0;
+	if (i < 0 && !verify_cb_cert(ctx, x, depth,
+	    X509_V_ERR_CERT_HAS_EXPIRED))
+		return 0;
+	return 1;
+}
+
+static int
+internal_verify(X509_STORE_CTX *ctx)
+{
+	int n = sk_X509_num(ctx->chain) - 1;
+	X509 *xi = sk_X509_value(ctx->chain, n);
+	X509 *xs;
+
+	if (ctx->check_issued(ctx, xi, xi))
+		xs = xi;
+	else {
+		if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+			xs = xi;
+			goto check_cert;
+		}
+		if (n <= 0)
+			return verify_cb_cert(ctx, xi, 0,
+			    X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE);
+		n--;
+		ctx->error_depth = n;
+		xs = sk_X509_value(ctx->chain, n);
+	}
+
+	/*
+	 * Do not clear ctx->error=0, it must be "sticky", only the
+	 * user's callback is allowed to reset errors (at its own
+	 * peril).
+	 */
+	while (n >= 0) {
+
+		/*
+		 * Skip signature check for self signed certificates
+		 * unless explicitly asked for.  It doesn't add any
+		 * security and just wastes time.  If the issuer's
+		 * public key is unusable, report the issuer
+		 * certificate and its depth (rather than the depth of
+		 * the subject).
+		 */
+		if (xs != xi || (ctx->param->flags &
+			X509_V_FLAG_CHECK_SS_SIGNATURE)) {
+			EVP_PKEY *pkey;
+			if ((pkey = X509_get_pubkey(xi)) == NULL) {
+				if (!verify_cb_cert(ctx, xi, xi != xs ? n+1 : n,
+					X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY))
+					return 0;
+			} else if (X509_verify(xs, pkey) <= 0) {
+				if (!verify_cb_cert(ctx, xs, n,
+					X509_V_ERR_CERT_SIGNATURE_FAILURE)) {
+					EVP_PKEY_free(pkey);
+					return 0;
+				}
+			}
+			EVP_PKEY_free(pkey);
+		}
+check_cert:
+		/* Calls verify callback as needed */
+		if (!x509_check_cert_time(ctx, xs, n))
+			return 0;
+
+		/*
+		 * Signal success at this depth.  However, the
+		 * previous error (if any) is retained.
+		 */
+		ctx->current_issuer = xi;
+		ctx->current_cert = xs;
+		ctx->error_depth = n;
+		if (!ctx->verify_cb(1, ctx))
+			return 0;
+
+		if (--n >= 0) {
+			xi = xs;
+			xs = sk_X509_value(ctx->chain, n);
+		}
+	}
+	return 1;
+}
+
+int
+X509_cmp_current_time(const ASN1_TIME *ctm)
+{
+	return X509_cmp_time(ctm, NULL);
+}
+
+/*
+ * Compare a possibly unvalidated ASN1_TIME string against a time_t
+ * using RFC 5280 rules for the time string. If *cmp_time is NULL
+ * the current system time is used.
+ *
+ * XXX NOTE that unlike what you expect a "cmp" function to do in C,
+ * XXX this one is "special", and returns 0 for error.
+ *
+ * Returns:
+ * -1 if the ASN1_time is earlier than OR the same as *cmp_time.
+ * 1 if the ASN1_time is later than *cmp_time.
+ * 0 on error.
+ */
+static int
+X509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time, int clamp_notafter)
+{
+	time_t time1, time2;
+	struct tm tm1, tm2;
+	int ret = 0;
+	int type;
+
+	if (cmp_time == NULL)
+		time2 = time(NULL);
+	else
+		time2 = *cmp_time;
+
+	memset(&tm1, 0, sizeof(tm1));
+
+	type = ASN1_time_parse(ctm->data, ctm->length, &tm1, ctm->type);
+	if (type == -1)
+		goto out; /* invalid time */
+
+	/* RFC 5280 section 4.1.2.5 */
+	if (tm1.tm_year < 150 && type != V_ASN1_UTCTIME)
+		goto out;
+	if (tm1.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)
+		goto out;
+
+	if (clamp_notafter) {
+		/* Allow for completely broken operating systems. */
+		if (!ASN1_time_tm_clamp_notafter(&tm1))
+			goto out;
+	}
+
+	/*
+	 * Defensively fail if the time string is not representable as
+	 * a time_t. A time_t must be sane if you care about times after
+	 * Jan 19 2038.
+	 */
+	if ((time1 = timegm(&tm1)) == -1)
+		goto out;
+
+	if (gmtime_r(&time2, &tm2) == NULL)
+		goto out;
+
+	ret = ASN1_time_tm_cmp(&tm1, &tm2);
+	if (ret == 0)
+		ret = -1; /* 0 is used for error, so map same to less than */
+ out:
+	return (ret);
+}
+
+int
+X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
+{
+	return X509_cmp_time_internal(ctm, cmp_time, 0);
+}
+
+
+ASN1_TIME *
+X509_gmtime_adj(ASN1_TIME *s, long adj)
+{
+	return X509_time_adj(s, adj, NULL);
+}
+
+ASN1_TIME *
+X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_time)
+{
+	return X509_time_adj_ex(s, 0, offset_sec, in_time);
+}
+
+ASN1_TIME *
+X509_time_adj_ex(ASN1_TIME *s, int offset_day, long offset_sec, time_t *in_time)
+{
+	time_t t;
+	if (in_time == NULL)
+		t = time(NULL);
+	else
+		t = *in_time;
+
+	return ASN1_TIME_adj(s, t, offset_day, offset_sec);
+}
+
+int
+X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
+{
+	EVP_PKEY *ktmp = NULL, *ktmp2;
+	int i, j;
+
+	if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))
+		return 1;
+
+	for (i = 0; i < sk_X509_num(chain); i++) {
+		ktmp = X509_get_pubkey(sk_X509_value(chain, i));
+		if (ktmp == NULL) {
+			X509error(X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
+			return 0;
+		}
+		if (!EVP_PKEY_missing_parameters(ktmp))
+			break;
+		else {
+			EVP_PKEY_free(ktmp);
+			ktmp = NULL;
+		}
+	}
+	if (ktmp == NULL) {
+		X509error(X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
+		return 0;
+	}
+
+	/* first, populate the other certs */
+	for (j = i - 1; j >= 0; j--) {
+		ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));
+		EVP_PKEY_copy_parameters(ktmp2, ktmp);
+		EVP_PKEY_free(ktmp2);
+	}
+
+	if (pkey != NULL)
+		EVP_PKEY_copy_parameters(pkey, ktmp);
+	EVP_PKEY_free(ktmp);
+	return 1;
+}
+
+int
+X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+	/* This function is (usually) called only once, by
+	 * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c). */
+	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX,
+	    argl, argp, new_func, dup_func, free_func);
+}
+
+int
+X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
+{
+	return CRYPTO_set_ex_data(&ctx->ex_data, idx, data);
+}
+
+void *
+X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
+{
+	return CRYPTO_get_ex_data(&ctx->ex_data, idx);
+}
+
+int
+X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
+{
+	return ctx->error;
+}
+
+void
+X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)
+{
+	ctx->error = err;
+}
+
+int
+X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
+{
+	return ctx->error_depth;
+}
+
+X509 *
+X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
+{
+	return ctx->current_cert;
+}
+
+STACK_OF(X509) *
+X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)
+{
+	return ctx->chain;
+}
+
+STACK_OF(X509) *
+X509_STORE_CTX_get0_chain(X509_STORE_CTX *xs)
+{
+	return xs->chain;
+}
+
+STACK_OF(X509) *
+X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)
+{
+	int i;
+	X509 *x;
+	STACK_OF(X509) *chain;
+
+	if (!ctx->chain || !(chain = sk_X509_dup(ctx->chain)))
+		return NULL;
+	for (i = 0; i < sk_X509_num(chain); i++) {
+		x = sk_X509_value(chain, i);
+		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
+	}
+	return chain;
+}
+
+X509 *
+X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)
+{
+	return ctx->current_issuer;
+}
+
+X509_CRL *
+X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)
+{
+	return ctx->current_crl;
+}
+
+X509_STORE_CTX *
+X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)
+{
+	return ctx->parent;
+}
+
+X509_STORE *
+X509_STORE_CTX_get0_store(X509_STORE_CTX *xs)
+{
+	return xs->ctx;
+}
+
+void
+X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)
+{
+	ctx->cert = x;
+}
+
+void
+X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+	ctx->untrusted = sk;
+}
+
+void
+X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)
+{
+	ctx->crls = sk;
+}
+
+int
+X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
+{
+	return X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);
+}
+
+int
+X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
+{
+	return X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);
+}
+
+/* This function is used to set the X509_STORE_CTX purpose and trust
+ * values. This is intended to be used when another structure has its
+ * own trust and purpose values which (if set) will be inherited by
+ * the ctx. If they aren't set then we will usually have a default
+ * purpose in mind which should then be used to set the trust value.
+ * An example of this is SSL use: an SSL structure will have its own
+ * purpose and trust settings which the application can set: if they
+ * aren't set then we use the default of SSL client/server.
+ */
+
+int
+X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
+    int purpose, int trust)
+{
+	int idx;
+
+	/* If purpose not set use default */
+	if (!purpose)
+		purpose = def_purpose;
+	/* If we have a purpose then check it is valid */
+	if (purpose) {
+		X509_PURPOSE *ptmp;
+		idx = X509_PURPOSE_get_by_id(purpose);
+		if (idx == -1) {
+			X509error(X509_R_UNKNOWN_PURPOSE_ID);
+			return 0;
+		}
+		ptmp = X509_PURPOSE_get0(idx);
+		if (ptmp->trust == X509_TRUST_DEFAULT) {
+			idx = X509_PURPOSE_get_by_id(def_purpose);
+			if (idx == -1) {
+				X509error(X509_R_UNKNOWN_PURPOSE_ID);
+				return 0;
+			}
+			ptmp = X509_PURPOSE_get0(idx);
+		}
+		/* If trust not set then get from purpose default */
+		if (!trust)
+			trust = ptmp->trust;
+	}
+	if (trust) {
+		idx = X509_TRUST_get_by_id(trust);
+		if (idx == -1) {
+			X509error(X509_R_UNKNOWN_TRUST_ID);
+			return 0;
+		}
+	}
+
+	if (purpose && !ctx->param->purpose)
+		ctx->param->purpose = purpose;
+	if (trust && !ctx->param->trust)
+		ctx->param->trust = trust;
+	return 1;
+}
+
+X509_STORE_CTX *
+X509_STORE_CTX_new(void)
+{
+	X509_STORE_CTX *ctx;
+
+	ctx = calloc(1, sizeof(X509_STORE_CTX));
+	if (!ctx) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		return NULL;
+	}
+	return ctx;
+}
+
+void
+X509_STORE_CTX_free(X509_STORE_CTX *ctx)
+{
+	if (ctx == NULL)
+		return;
+
+	X509_STORE_CTX_cleanup(ctx);
+	free(ctx);
+}
+
+int
+X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
+    STACK_OF(X509) *chain)
+{
+	int param_ret = 1;
+
+	/*
+	 * Make sure everything is initialized properly even in case of an
+	 * early return due to an error.
+	 *
+	 * While this 'ctx' can be reused, X509_STORE_CTX_cleanup() will have
+	 * freed everything and memset ex_data anyway.  This also allows us
+	 * to safely use X509_STORE_CTX variables from the stack which will
+	 * have uninitialized data.
+	 */
+	memset(ctx, 0, sizeof(*ctx));
+
+	/*
+	 * Start with this set to not valid - it will be set to valid
+	 * in X509_verify_cert.
+	 */
+	ctx->error = X509_V_ERR_INVALID_CALL;
+
+	/*
+	 * Set values other than 0.  Keep this in the same order as
+	 * X509_STORE_CTX except for values that may fail.  All fields that
+	 * may fail should go last to make sure 'ctx' is as consistent as
+	 * possible even on early exits.
+	 */
+	ctx->ctx = store;
+	ctx->cert = x509;
+	ctx->untrusted = chain;
+
+	if (store && store->verify)
+		ctx->verify = store->verify;
+	else
+		ctx->verify = internal_verify;
+
+	if (store && store->verify_cb)
+		ctx->verify_cb = store->verify_cb;
+	else
+		ctx->verify_cb = null_callback;
+
+	if (store && store->get_issuer)
+		ctx->get_issuer = store->get_issuer;
+	else
+		ctx->get_issuer = X509_STORE_CTX_get1_issuer;
+
+	if (store && store->check_issued)
+		ctx->check_issued = store->check_issued;
+	else
+		ctx->check_issued = check_issued;
+
+	if (store && store->check_revocation)
+		ctx->check_revocation = store->check_revocation;
+	else
+		ctx->check_revocation = check_revocation;
+
+	if (store && store->get_crl)
+		ctx->get_crl = store->get_crl;
+	else
+		ctx->get_crl = NULL;
+
+	if (store && store->check_crl)
+		ctx->check_crl = store->check_crl;
+	else
+		ctx->check_crl = check_crl;
+
+	if (store && store->cert_crl)
+		ctx->cert_crl = store->cert_crl;
+	else
+		ctx->cert_crl = cert_crl;
+
+	ctx->check_policy = check_policy;
+
+	if (store && store->lookup_certs)
+		ctx->lookup_certs = store->lookup_certs;
+	else
+		ctx->lookup_certs = X509_STORE_get1_certs;
+
+	if (store && store->lookup_crls)
+		ctx->lookup_crls = store->lookup_crls;
+	else
+		ctx->lookup_crls = X509_STORE_get1_crls;
+
+	if (store && store->cleanup)
+		ctx->cleanup = store->cleanup;
+	else
+		ctx->cleanup = NULL;
+
+	ctx->param = X509_VERIFY_PARAM_new();
+	if (!ctx->param) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		return 0;
+	}
+
+	/* Inherit callbacks and flags from X509_STORE if not set
+	 * use defaults.
+	 */
+	if (store)
+		param_ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);
+	else
+		ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;
+
+	if (param_ret)
+		param_ret = X509_VERIFY_PARAM_inherit(ctx->param,
+		    X509_VERIFY_PARAM_lookup("default"));
+
+	if (param_ret == 0) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		return 0;
+	}
+
+	if (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
+	    &(ctx->ex_data)) == 0) {
+		X509error(ERR_R_MALLOC_FAILURE);
+		return 0;
+	}
+	return 1;
+}
+
+/* Set alternative lookup method: just a STACK of trusted certificates.
+ * This avoids X509_STORE nastiness where it isn't needed.
+ */
+
+void
+X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+	ctx->other_ctx = sk;
+	ctx->get_issuer = get_issuer_sk;
+}
+
+void
+X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+	X509_STORE_CTX_trusted_stack(ctx, sk);
+}
+
+void
+X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
+{
+	if (ctx->cleanup)
+		ctx->cleanup(ctx);
+	if (ctx->param != NULL) {
+		if (ctx->parent == NULL)
+			X509_VERIFY_PARAM_free(ctx->param);
+		ctx->param = NULL;
+	}
+	if (ctx->tree != NULL) {
+		X509_policy_tree_free(ctx->tree);
+		ctx->tree = NULL;
+	}
+	if (ctx->chain != NULL) {
+		sk_X509_pop_free(ctx->chain, X509_free);
+		ctx->chain = NULL;
+	}
+	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX,
+	    ctx, &(ctx->ex_data));
+	memset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));
+}
+
+void
+X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
+{
+	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
+}
+
+void
+X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)
+{
+	X509_VERIFY_PARAM_set_flags(ctx->param, flags);
+}
+
+void
+X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)
+{
+	X509_VERIFY_PARAM_set_time(ctx->param, t);
+}
+
+void
+X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
+    int (*verify_cb)(int, X509_STORE_CTX *))
+{
+	ctx->verify_cb = verify_cb;
+}
+
+X509 *
+X509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx)
+{
+	return ctx->cert;
+}
+
+STACK_OF(X509) *
+X509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx)
+{
+	return ctx->untrusted;
+}
+
+void
+X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+	ctx->untrusted = sk;
+}
+
+X509_POLICY_TREE *
+X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)
+{
+	return ctx->tree;
+}
+
+int
+X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)
+{
+	return ctx->explicit_policy;
+}
+
+int
+X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
+{
+	const X509_VERIFY_PARAM *param;
+	param = X509_VERIFY_PARAM_lookup(name);
+	if (!param)
+		return 0;
+	return X509_VERIFY_PARAM_inherit(ctx->param, param);
+}
+
+X509_VERIFY_PARAM *
+X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
+{
+	return ctx->param;
+}
+
+void
+X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
+{
+	if (ctx->param)
+		X509_VERIFY_PARAM_free(ctx->param);
+	ctx->param = param;
+}
diff -Nur libressl-3.1.0/crypto/x509/x509_vfy_apple.c libressl-3.1.0-apple/crypto/x509/x509_vfy_apple.c
--- libressl-3.1.0/crypto/x509/x509_vfy_apple.c	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/crypto/x509/x509_vfy_apple.c	2020-04-21 08:36:53.000000000 +0200
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2009 Apple Inc. All Rights Reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ *
+ */
+
+#include <stdint.h>
+#include <inttypes.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <TrustEvaluationAgent/TrustEvaluationAgent.h>
+#include <syslog.h>
+
+#include "cryptlib.h"
+#include "x509_vfy_apple.h"
+
+#define TEA_might_correct_error(err) (err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY || err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT || err == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)
+
+/*
+ * Please see comment in x509_vfy_apple.h
+ */
+int
+X509_verify_cert(X509_STORE_CTX *ctx)
+{
+	TEAResult		ret = kTEAResultCertNotTrusted;
+	TEACertificateChainRef	inputChain = NULL;
+	TEACertificateChainRef	outputChain = NULL;
+	__block uint64_t	certCount = 0;
+	uint64_t		certLastIndex = 0;
+	uint64_t		i = 0;
+	int			error = 0;
+	TEAParams		params = { 0 };
+
+
+	if (ctx == NULL || ctx->cert == NULL)
+        return kTEAResultErrorOccured;
+
+	/* Try OpenSSL, if we get a local certificate issue verify against trusted roots */
+	ret = X509_verify_cert_orig(ctx);
+
+	/* Verify TEA is enabled and should be used. */
+	if (0 != X509_TEA_is_enabled() &&
+		ret != 1 && TEA_might_correct_error(ctx->error)) {
+
+		/* Verify that the certificate chain exists, otherwise make it. */
+		if (ctx->chain == NULL && (ctx->chain = sk_X509_new_null()) == NULL) {
+			TEALogDebug("Could not create the certificate chain");
+			ret = kTEAResultCertNotTrusted;
+			goto bail;
+		}
+
+		/* Verify chain depth */
+		certLastIndex = sk_X509_num(ctx->untrusted);
+		if (certLastIndex > ctx->param->depth) {
+			TEALogInfo("Pruning certificate chain to %" PRIu64, certLastIndex);
+			certLastIndex = ctx->param->depth;
+		}
+
+		inputChain = TEACertificateChainCreate();
+		if (inputChain == NULL) {
+			TEALogDebug("Certificate chain creation failed");
+			goto bail;
+		}
+
+		unsigned char *asn1_cert_data = NULL;
+		int asn1_cert_len = i2d_X509(ctx->cert, &asn1_cert_data);
+		error = TEACertificateChainAddCert(inputChain, asn1_cert_data, asn1_cert_len);
+		// TEACertificateChainAddCert made a copy of the ASN.1 data, so we get to free ours here
+		OPENSSL_free(asn1_cert_data);
+		if (error) {
+			TEALogDebug("An error occured while inserting the certificate into the chain");
+			goto bail;
+		}
+
+		for (i = 0; i < certLastIndex; ++i) {
+			X509	*t = sk_X509_value(ctx->untrusted, i);
+
+			asn1_cert_data = NULL;
+			asn1_cert_len = i2d_X509(t, &asn1_cert_data);
+			error = TEACertificateChainAddCert(inputChain, asn1_cert_data, asn1_cert_len);
+			// TEACertificateChainAddCert made a copy of the ASN.1 data, so we get to free ours here
+			OPENSSL_free(asn1_cert_data);
+			if (error) {
+				TEALogDebug("An error occured while inserting an untrusted certificate into the chain");
+				goto bail;
+			}
+		}
+
+		// We put ASN.1 encoded X509 on the CertificateChain, so we don't call TEACertificateChainSetEncodingHandler
+		
+		params.purpose = ctx->param->purpose;
+		if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
+			params.time = ctx->param->check_time;
+
+		outputChain = TEAVerifyCert(inputChain, &params);
+
+		TEACertificateChainRelease(inputChain);
+		inputChain = NULL;
+
+		if (outputChain == NULL) {
+			TEALogDebug("TEAVerifyCert() returned NULL.");
+			goto bail;
+		}
+
+		/* Empty the context chain */
+		for (i = 0; i < sk_X509_num(ctx->chain); ++i)
+			sk_X509_pop(ctx->chain);
+
+		error = TEACertificateChainGetCerts(outputChain, ^(const TEACertificateRef cert) {
+			const unsigned char	*ptr = TEACertificateGetData(cert);
+			X509			*c = NULL;
+
+			if (certCount++ > certLastIndex)
+				return 0;
+
+			c = d2i_X509(NULL, &ptr, TEACertificateGetSize(cert));
+			if (c == NULL) {
+				TEALogDebug("Could not parse certificate");
+				return 1;
+			}
+
+			if (!sk_X509_push(ctx->chain, c)) {
+				TEALogDebug("Could not insert certificate into the chain");
+				return 1;
+			}
+
+			return 0;
+		});
+		if (error) {
+			TEALogDebug("An error occured while deserializing the trusted certificate chain");
+			ret = kTEAResultCertNotTrusted;
+			goto bail;
+		}
+
+		TEACertificateChainRelease(outputChain);
+		outputChain = NULL;
+
+		/* Fixup context data */
+		ctx->current_cert   = sk_X509_value(ctx->chain, 0);
+		ctx->current_issuer = sk_X509_value(ctx->chain, sk_X509_num(ctx->chain) - 1);
+		ctx->error_depth = 0;
+		ctx->error = 0;
+		X509_get_pubkey_parameters(NULL, ctx->chain);
+
+		ret = kTEAResultCertTrusted;
+	}
+
+bail:
+	if (inputChain) {
+		TEACertificateChainRelease(inputChain);
+		inputChain = NULL;
+	}
+	if (outputChain) {
+		TEACertificateChainRelease(outputChain);
+		outputChain = NULL;
+	}
+	return ret;
+}
+
+#pragma mark Trust Evaluation Agent
+
+/* -1: not set
+ *  0: set to false
+ *  1: set to true
+ */
+static int tea_enabled = -1;
+
+void
+X509_TEA_set_state(int change)
+{
+	tea_enabled = (change) ? 1 : 0;
+}
+
+int
+X509_TEA_is_enabled()
+{
+	if (tea_enabled < 0)
+		tea_enabled = (NULL == getenv(X509_TEA_ENV_DISABLE));
+
+	return tea_enabled != 0;
+}
diff -Nur libressl-3.1.0/crypto/x509/x509_vfy_apple.h libressl-3.1.0-apple/crypto/x509/x509_vfy_apple.h
--- libressl-3.1.0/crypto/x509/x509_vfy_apple.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/crypto/x509/x509_vfy_apple.h	2020-04-21 08:36:53.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2009 Apple Inc. All Rights Reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ *
+ */
+
+#ifndef HEADER_X509_H
+#include <openssl/x509.h>
+#endif
+
+#ifndef HEADER_X509_VFY_APPLE_H
+#define HEADER_X509_VFY_APPLE_H
+
+/* Environment variable name to disable TEA. */
+#define X509_TEA_ENV_DISABLE "OPENSSL_X509_TEA_DISABLE"
+
+/*
+ * X509_verify_cert
+ *
+ * Originally located in x509_vfy.c.
+ *
+ * Verify certificate with OpenSSL created X509_verify_cert. If and only if
+ * OpenSSL cannot get certificate issuer locally then OS X security API will
+ * verify the certificate, using Trust Evaluation Agent.
+ *
+ * Return values:
+ * --------------
+ * -1: Null was passed for either ctx or ctx->cert.
+ *  0: Certificate is trusted.
+ *  1: Certificate is not trusted.
+ */
+int X509_verify_cert(X509_STORE_CTX *ctx);
+
+/*
+ * X509_TEA_is_enabled
+ *
+ * Is the Trust Evaluation Agent (TEA) used for certificate verification when
+ * the issuer cannot be verified.
+ *
+ * Returns 0 if TEA is disabled and 1 if TEA is enabled.
+ */
+int X509_TEA_is_enabled();
+
+/*
+ * X509_TEA_set_state
+ *
+ * Enables/disables certificate verification with Trust Evaluation Agent (TEA)
+ * when the issuer cannot be verified.
+ *
+ * Pass 0 to disable TEA and non-zero to enable TEA.
+ */
+void X509_TEA_set_state(int change);
+
+int X509_verify_cert_orig(X509_STORE_CTX *ctx);
+
+#endif /* HEADER_X509_VFY_APPLE_H */
Binary files libressl-3.1.0/include/.DS_Store and libressl-3.1.0-apple/include/.DS_Store differ
Binary files libressl-3.1.0/include/TrustEvaluationAgent/.DS_Store and libressl-3.1.0-apple/include/TrustEvaluationAgent/.DS_Store differ
Binary files libressl-3.1.0/include/TrustEvaluationAgent/.TrustEvaluationAgent.h.swp and libressl-3.1.0-apple/include/TrustEvaluationAgent/.TrustEvaluationAgent.h.swp differ
diff -Nur libressl-3.1.0/include/TrustEvaluationAgent/TrustEvaluationAgent.h libressl-3.1.0-apple/include/TrustEvaluationAgent/TrustEvaluationAgent.h
--- libressl-3.1.0/include/TrustEvaluationAgent/TrustEvaluationAgent.h	1970-01-01 01:00:00.000000000 +0100
+++ libressl-3.1.0-apple/include/TrustEvaluationAgent/TrustEvaluationAgent.h	2020-04-07 11:00:41.000000000 +0200
@@ -0,0 +1,43 @@
+#ifndef APPLE_TEA_H
+#define APPLE_TEA_H
+
+#include <sys/time.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+
+typedef int TEAResult;
+
+/*typedef void *TEACertificateChainRef;
+typedef struct TEAParams
+{
+    void *purpose;
+    time_t check_time;
+    time_t time;
+} TEAParams;
+
+typedef void *TEACertificateRef;*/
+
+typedef X509_STORE_CTX * TEACertificateChainRef;
+typedef X509 * TEACertificateRef;
+typedef X509_VERIFY_PARAM TEAParams;
+
+TEACertificateChainRef TEACertificateChainCreate();
+TEACertificateChainRef TEAVerifyCert(TEACertificateChainRef cert, TEAParams *params);
+
+const unsigned char *TEACertificateGetData(TEACertificateRef cert);
+
+int TEACertificateChainGetCerts(TEACertificateChainRef, int (^)(const TEACertificateRef cert));
+int TEACertificateGetSize(TEACertificateRef cert);
+int TEACertificateChainAddCert(TEACertificateChainRef cert, unsigned char *data, int len);
+int TEACertificateChainRelease(TEACertificateChainRef cert);
+
+#define kTEAResultErrorOccured -1
+#define kTEAResultCertNotTrusted 0
+#define kTEAResultCertTrusted 1
+
+#define TEALogInfo(x, ...)
+#define TEALogDebug(x, ...)
+
+#endif
